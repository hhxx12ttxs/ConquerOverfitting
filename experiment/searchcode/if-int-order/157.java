/* =================================================================
Copyright (C) 2009 ADV/web-engineering All rights reserved.

This file is part of Mozart.

Mozart is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Mozart is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Foobar.  If not, see <http://www.gnu.org/licenses/>.

Mozart
http://www.mozartcms.ru
================================================================= */
// -*- java -*-
// $Id: GetInstruction.java 1317 2009-09-10 15:41:22Z vic $

package ru.adv.db.app.request;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.w3c.dom.Element;
import org.w3c.dom.Node;

import ru.adv.db.base.Ancestor;
import ru.adv.db.base.ContextAttrXmlGenerator;
import ru.adv.db.base.Id;
import ru.adv.db.base.MObject;
import ru.adv.db.base.MValue;
import ru.adv.db.base.MValueCollection;
import ru.adv.db.base.SingleAncestor;
import ru.adv.db.base.link.LinkPaths;
import ru.adv.db.base.link.LinkPathsImpl;
import ru.adv.db.config.DBConfig;
import ru.adv.db.config.DBConfigException;
import ru.adv.db.config.ObjectAttr;
import ru.adv.db.handler.Handler;
import ru.adv.db.handler.HandlerI;
import ru.adv.db.handler.Limit;
import ru.adv.db.handler.RowSet;
import ru.adv.db.handler.RowSetCallback;
import ru.adv.db.handler.RowSetException;
import ru.adv.db.handler.SContextCollection;
import ru.adv.db.handler.SelectAttributes;
import ru.adv.db.handler.SelectAttributesItem;
import ru.adv.db.handler.SelectOptions;
import ru.adv.db.handler.SelectTreeOptions;
import ru.adv.db.handler.Sort;
import ru.adv.db.handler.SortParserException;
import ru.adv.db.handler.wrapper.LazyProxyHandler;
import ru.adv.http.QueryValue;
import ru.adv.logger.TLogger;
import ru.adv.util.BadNumberException;
import ru.adv.util.ErrorCodeException;
import ru.adv.util.StringParser;
import ru.adv.util.XmlUtils;
import ru.adv.xml.newt.ActionExecutorContext;

/**
 ?????????? ????????? ? ?? ?? ?????? ??????????? ?????? ? {@link ContextStack}.
 <BR/>
 ?????????????? ????????:
 <UL>
 <LI>object</LI> ???????????? ???????, ????????? ???????? ??????? ??? ???????
 <LI>depend</LI> ???? ????????????, ?? ???????? ????????????? ???? ????????
 ??????????? <code>get</code> ????? ??????? ??? ??????.
 ?? ???????????? ???????? ?? ??????????? ? ????????? ??
 Ancestor
 <LI>exclude</LI> ???? ????????????, ?? ???????? ????????????? ???? ????????
 ????? ??????? ??? ??????; ?????? ???????????? ???? ????????????
 ??? ?????????? {@link ru.adv.db.base.link.LinkPathsImpl RegularLinkPaths}
 <LI>include</LI> ???? ????????????, ?? ???????? ????????????? ???? ????????
 ????? ??????? ??? ??????; ?????? ???????????? ???? ????????????
 ??? ?????????? {@link ru.adv.db.base.link.LinkPathsImpl RegularLinkPaths}
 <LI>page-size</LI> ???? ??????, ?? ???????? ??????????? ??????, ????????????
 ?????? ???????? ??? ?????????????? ???????;
 ????? ????????????? ???????????? ????? ??????? ?????? ? ???
 ??????, ???? ??? ??????? <code>get</code> ?????????? ????????????
 ???????????? ???
 <LI>page</LI> ???? ?????????, ?? ???????? ??????????? ??????, ????????? ?? ???????
 ????????;
 ???? ?? ?????????, ?? ???????????? ???????? ?? <code>query</code>
 ? ?????? <code>"_page_"+objectName</code>
 ???? page ?? ??????????, ?? ???????????? <code>1</code>
 <LI>limit</LI> ???? ??????????, ?? ???????? ??????????? ??????, ????????? ????????????
 ??????????? ????????? ?????????? ????????
 <LI>tree-mode</LI> ?? ??????? ??? tree object ????? <code>tree</code>, ??? plain object
 <code>plain</code>; ??? tree object ????? ????????? ???????? ??? ?? <code>plain</code>
 <LI>tree</LI> ?? ??????? ????? <code>sibling</code>, ??? ?? ?????? {@link Tree}
 ??? ???????? ?? ?????????? ???? <code>tree</code> ????????? ???????? ????????:<br/>
 <code>sibling+</code> - ??? ????????? ??????? ?????????? ?? ?????????????? ???????? <code>get</code><br/>
 <code>sibling</code> - ?? ?????????????? ???????? <code>get</code> ?????????? ??????
 ???????, ??? ??????? id ???????????? ? <code>query</code> c ?????? <code>objectName_id</code>
 <LI>sort</LI> ?????????? ??????? ??????? ????????; ?????? {@link ru.adv.db.handler.Sort#Sort(DBConfig,String,String) Sort}

 </UL>

 <PRE>
 ???????? <code>page</code>,<code>page-size</code>,<code>limit</code> ????? ?????????
 ???????? ?? ????????????? ????? HTTP query,
 ???? ???????? ???????? ????? ??? <code>"query://querykey"</code>


 </PRE>

 */
public class GetInstruction extends Instruction {

    public static final String PAGE_QUERY_PREFIX = "_page_";
    
    final static String PARAM_SET = "set";
    final static String PARAM_SORT = "sort";
    final static String PARAM_TREE_MODE = "tree-mode";
    final static String PARAM_TREE = "tree";
    final static String PARAM_LIMIT = "limit";
    final static String PARAM_PAGE = "page";
    final static String PARAM_PAGE_SIZE = "page-size";
    final static String PARAM_PAGE_COUNT = "page-count";
    final static String PARAM_REMOVE_FROM_QUERY = "remove-from-query";
    final static String PARAM_INCLUDE_DEPRECATED = "include";
    final static String PARAM_EXCLUDE_DEPRICATED = "exclude";
    final static String PARAM_DEPEND = "depend";
    final static String PARAM_OBJECT = "object";
    final static String PARAM_CONTEXT_FOUND = "mark-found-context";

    /** ??? ??????? */
	private String object = null;  
	/** ???????????? ???? ???????? */
	private Collection<String> dependObjects = null;  
	/** ???????????? ???? ???????? */
	private List<String> pathExclude = null; 
	/** ???????????? ???? ???????? */
	private List<String> pathInclude = null; 
	/** ????? ?????????? query ??????? ?? ?????? ? ??? ?????????*/
	private Set<String> removeFromQuery = null; 
	/** ??????????? ????????????? ???????? */
	private Limit limit = null; 
	/** ??????????? ??????????? ?????? ???????? */
	private Paginator paginator = null; 
	/** ?????????? ????????? */
	private Tree tree = null;  
	/** ???????? ???????? tree-mode */
	private String strTreeMode = null;  
	/** ????? ?????? GET; tree || palin */
	private boolean treeMode = false;  
	/** ??????????? ?????????? */
	private Sort sort = null;
	/** ??????????? ????????? ???? ??? isNextProcessing ???????? */
	private GetSetAttrCollection setAttrCollection = null; 
	/** ?????? ?? ??? ?????? GET ? */
	private boolean isProccesGet = true;  
	/** ????????? ? Id ?????????? ? Query */
	private Collection<Id> objectQueryIds = null; 
    /** ???????? ?? ?????????? <context> ????????? ?????? ? ????????   */
    private boolean isMarkFoundContext = false;
    /** ??????? ?????? get ??????????, ???????????? ?????? get*/
	private boolean isFirst = false; 
    
    private boolean isSomethingFound = false;
    /** */
    private RObject parentRObject = null;

    private int fetchedRowsCounter = 0;
    
    /** ?????? ??????????? ???????? {@link InfoInstruction} */
    private ChildInfoInstructionData childInfoInstructionData = null;
    
    private TLogger logger = new TLogger(GetInstruction.class);
    
    public GetInstruction() {
    }

	/**
	 * ?????????? ??? ???????? ?? ????????? ? ??, ??????? ????? {@link Context}
	 * ? ??????? ? {@link ContextStack}
	 */
	protected boolean onStartTag() throws RequestException {
		Context context = _contextStack.peek();
		
		RObjectCollection robjects = _contextStack.peek().getParents();

		if (context.getParents().sizeToProcess() == 0) {
			this.isProccesGet = false;
			return false; // ?????? ????? ??????
		}

		parseAttributes(); // ?????? ????????? ???? get ? ????????? ??????????

		this.objectQueryIds = calculateObjectQueryIds(this.object);
        
		try {

			MObject tmpMObject = createMObject();
			
			this.setAttrCollection = new GetSetAttrCollection( createActionExecutorContext(), this._node );
			
			// ?????????? ????? ????????? get (?????????? ??? ????????????)
			this.setTreeMode(tmpMObject);
			tmpMObject = null;

            // if tree="self" and plain request and no id in query then nothing to do
            if (!this.treeMode && this.objectQueryIds==null && tree.isOnlySelf() ) {
                this.isProccesGet = false;
                return false; // ?????? ????? ??????
            }

			if (robjects.size() == 1 && robjects.get(0).isRoot()) {
				// first level
				this.isFirst = true;
			}
			else {
				// next level
				this.isFirst = false;
			}
			processLevel();
			return this.isSomethingFound;

		}
		catch (ErrorCodeException e) {
			throw new RequestException(e);
		}
	}

	private ActionExecutorContext createActionExecutorContext() {
		ActionExecutorContext actionExecutorContext;
		actionExecutorContext = new ActionExecutorContext( getNewtContext(), this, new LazyProxyHandler() {
			@Override
			public void destroy() {
				// 
			}
			@Override
			public HandlerI createHandler() {
				return getDBHandler();
			}
		}
		);
		return actionExecutorContext;
	}

	/**
	 * ????????? ??????????? ????????? Pages
	 */
	private void setParentIdToAncestorForPagesIfNeed(RObjectCollection parents, SingleAncestor ancestor) {
		// ???????? ? ancestor ??????? ????????????? id, ???? ??
		// ??????????, ?? ????? ? ??????????? ???????, ?????
		// ?????????? ??????? ?????? ??? ???????????? ???????
		if ( !isFirst && parents.sizeToProcess() > 0) {
			String parentName = parents.get(0).getName();
			if (parentName != null) {
                ancestor.set( parentName, "id", new MValue(null,parents.get(0).getId()) );
			}
		}
	}

	/**
	 * ??????????????? ?????????????? ????????
	 *
	 */
	protected void onEndTag() throws RequestException {
		if (this.isProccesGet) {
			// ??????? ?????????? ????????
			_contextStack.pop();
		}
	}

	/**
	 * ????????????? ?????? ?? ???????? ????????????? ?????? ??? GET
	 */
	private boolean gotoNext(RowSet rs) throws RowSetException {
		fetchedRowsCounter ++;
		boolean success = false;
		// go to next item on the current page
		if (paginator != null) {
			if ( paginator.isNextRowBelongsCurrentPage(rs.getRow()) ) {
				success = rs.next();	
			}
		} else {
			success = rs.next();
		}
		return success;
	}

	/**
	 * ?????????? ???????? xml ??? ???????????? ????????
	 * TODO run it in transaction block
	 */
	private void processLevel() throws ErrorCodeException {
		
		Context context = _contextStack.peek();
		SingleAncestor ancestor = context.getAncestor().group().copy();
		final SContextCollection sContextCollection = context.getSContextCollection(); //getSContextCollection(this.object);
		MObject mObject = createMObject();
		
		final MValueCollection idCollection = new MValueCollection(); // ?????????? ID ??? ????????? ??????????????
		final RObjectCollection rObjects = new RObjectCollection();
		final RObjectCollection parentRObjects = context.getParents();
		final Depend depend = context.getDepend().copy();

		
		Sort dependSort = null;

		if (this.isFirst) {
			this.parentRObject = parentRObjects.get(0);
			dependSort = this.sort;
		} else {
			if (this.dependObjects.size() > 0) {
				// ??? ??? ?? ???????? ??? ??????? ??????????? ?? ?????????, ?? ?? ????????
				// ????????? ???????? ??????? ????????????? ???????????, ?????? ??????????? ????????.
				// ?????????? ???????? ????????? ????????, ?? ??????? ????????? ? ??????? ????? ????????,
				// ? ?????? ??, ??? ??????? ? ??????????? ?????? toProcess.
				// ? ??????? ????????(depend ?? ????????), ??????? ??????? ?? ????????
				depend.recalculate(_contextStack, this.dependObjects);
				ancestor.retainObjects(this.dependObjects);
				if (depend.getObjects().contains(parentRObjects.get(0).getName())) {
					MValueCollection ancestorParentIds = ancestor.get(parentRObjects.get(0).getName(), "id");
					if (ancestorParentIds == null || ancestorParentIds.isEmpty()) {
                        if (this.paginator == null) {
						    ancestor.set(parentRObjects.get(0).getName(), "id", parentRObjects.idToProcess());
                        }
					}
				}

			}

            if (this.paginator != null) {
                // ?????????? page ? ???? ?????????? ? ancestor id ??????? ???????
                // ???????????? ????? ???????? ?????? ??? ????????????? ???????
                setParentIdToAncestorForPagesIfNeed(parentRObjects,ancestor);
            }

			// ???????????: ????????? ?????????? ?????? ?? id ????????(parent) ??????? (??? ???????????????)
			if ( this.paginator == null && depend.getObjects().contains(parentRObjects.get(0).getName()) ) {
				MValueCollection ancestorParentIds = ancestor.get(parentRObjects.get(0).getName(), "id");
				if ( ancestorParentIds == null || ancestorParentIds.isEmpty() ) {
					ancestor.set(parentRObjects.get(0).getName(), "id", parentRObjects.idToProcess());
				}
			}

            /** TODO
             * - ?????? ??????????????, ??? ? ??????? ???????? ?? ???????????? id ? ancestor
             *   ? ?????? ???? ????, ????????? id ???????????? ? ancestor
             * 
             * 		?????????? ???????? ??? ??????? ??:
             * - ?????? ?????????? ? ancestor id depend ????????, ??????? ???????? ??? ??????????????.
             *   ???? ? ancestor ??? ?????????? ?????-?? id, ?? ????? ?? ???????????.
             *   ???? ??????????? ancestor ?? ????????????? ? ???????? ?????????? ?????? (????? ???? SET ??????????)
             *   ???????: ?????????? ??? ???????????? ??????? GET ?? SET ??????????? (leaf-objcts, changed paths,...)
             */
            setToAncestorDependIds(ancestor, depend);

			dependSort = depend.createSort(getDBHandler().getDBConfig());
			dependSort.add(this.sort);
		}

		Set<String> definedObjects = new HashSet<String>(ancestor.objectNames());
		definedObjects.addAll(sContextCollection.getObjects());
		definedObjects.addAll(dependSort.getAliases());

		LinkPaths links = new LinkPathsImpl(mObject, pathExclude, pathInclude, definedObjects, getLinkCache());


		// ?????? ?? depend ?????? join ???????
		depend.set(links.getObjectNames());
		dependSort = depend.createSort(getDBHandler().getDBConfig());
		dependSort.add(this.sort);

		logger.debug("For '" + object + "' xml-tree depend = " + depend);
		logger.debug("For '" + object + "' RegularLinkPaths = \n" + links.toShortString());

		grubChildInfoInstructionAttributes(mObject);

		SelectOptions options = createSelectOptions(ancestor, sContextCollection, mObject, depend, dependSort, links);
		
		if (paginator!=null) {
			// read count of items in select
			if ( paginator.init( getDBHandler().selectCount(options) ) ) {
				options.setLimit(new Limit(
						paginator.getFirstItemOffset(),
						paginator.getMaxItemToFetch()
				));
			} else {
				paginator = null; // skip paging, cause it's no need
			}
		}		

		getDBHandler().select(options, new RowSetCallback(){

			@Override
			public Object doInRowSet(RowSet rs) throws Exception {
				
				// In RowSet actions
				
				if ( paginator!=null ) {
					paginator.fetchSiblingPagesBeforCurrentPage(rs,object);
				}
				
				addIncludes(rs.getIncludes());
				DependKey dependKey = new DependKey();
				
				boolean hasRows = gotoNext(rs);  
				
				GetInstruction.this.isSomethingFound = hasRows;
				
				if (GetInstruction.this.isFirst && hasRows) { // ???????? ?????? ???????
					while (hasRows) {
						insertObject(rs, GetInstruction.this.parentRObject, rObjects, idCollection, dependKey, sContextCollection);
						hasRows = gotoNext(rs);
					}
				} else if (hasRows) { // ???????? ????????? ??????
					Map<String,Set<RObject>> dependKeys = parentRObjects.getDependKeys(depend);
					// key -> Collection of RObject
					DependKey rsDependKey = depend.createKey(rs);
					while (hasRows) {
						String strKey = rsDependKey.toString();
						if (dependKeys.containsKey(strKey)) {
							dependKey = rsDependKey;
							Set<RObject> depParents = dependKeys.get(strKey);
							int count = 1;
							while (dependKey.equals(rsDependKey) && hasRows) {
								for ( RObject depParent : depParents) {
									if (limit != null && limit.getCount() > 0 && limit.getCount() < count) {
										break;
									}
									// ? ?????? ?????????? ?????? ?????????
									GetInstruction.this.parentRObject = depParent;
									insertObject(rs, depParent, rObjects, idCollection, dependKey, sContextCollection);
									count++;
								}
								hasRows = gotoNext(rs);
								if (hasRows) {
									rsDependKey = depend.createKey(rs);
								}
							}
						} else {
							hasRows = gotoNext(rs);
							if (hasRows) {
								rsDependKey = depend.createKey(rs);
							}
						}
					}	// while for rs
				}

				if ( paginator!=null ) {
					paginator.fetchSiblingPagesAfterCurrentPage(rs,object);
					paginator.setDependKey(dependKey);
					paginator.setRemoveFromQuery(removeFromQuery);
				}

				return null;
			}


		});
		
		if ( paginator!=null && this.parentRObject!=null) {
			paginator.fetchLastAndEndPages(getDBHandler(), options, this.object);
			paginator.insertPageElements(this.parentRObject.getElement(), this.object);
		}

		logHugeRequest();
		
		// ?????????? XML ??????????? ??????????
		insertCalculatedAttrubutes(rObjects);

		// ?????????? xml ??????????? ?????????
		if (this.treeMode) {
			idCollection.addAll(processTree(rObjects, depend, sContextCollection));
		}

		// ????? ??????? ? ????????? context ??? ???????? ???????
		depend.add(object);

		// ???????? ????? ?????????? ancestor ??? ????. ??????
		SingleAncestor newSingleAncestor = context.getAncestor().group().copy();

        if (!idCollection.isEmpty()) {
            // ???? ???????? ?????? id ??????? ??????????????? ?? query,
            // ??? ?????? ???????? ?????????? ????????? ??????? ??????? ????.
            // ??? ?? ? idCollection ????? ?????????? ??? ??????????? ??????????? ???????.
            newSingleAncestor.set(object, "id", idCollection);
        } else {
            // ??????????????? ??????? ?? ???????????, ?????? ???? page ??? limit
            if (this.paginator != null || this.limit != null || !sContextCollection.isEmpty()) {
                // ??????? id ??????????? ???????? ??????? ??????
                newSingleAncestor.set(object, "id", rObjects.idToProcess());
            }
        }

        // set update value to ancestor to pass SaveInstraction see test 58.xml
        if( newSingleAncestor.get(object, "id")!=null ) {
        	Iterator<MValue> i = newSingleAncestor.get(object, "id").iterator();
        	while(i.hasNext()) {
        		MValue mv = i.next();
        		mv.set(mv.getSearchValue());
        	}
        }
        
		Ancestor newAncestor = context.getAncestor().copy();
		newAncestor.set(newSingleAncestor);
		
		rObjects.setTreeMode(this.treeMode);

		Context newContext = new Context(rObjects, depend, newAncestor, context.getSContextCollection(), context.getQuery());
		_contextStack.push(newContext);
		
	}

	private void logHugeRequest() {
		// log big requests
		if ( fetchedRowsCounter > 10000) {
			logger.warning("Select return TOO MANY OF ROWS "+fetchedRowsCounter);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Count of rows "+fetchedRowsCounter);
		}
	}

	private SelectOptions createSelectOptions(SingleAncestor ancestor,
			final SContextCollection sContextCollection, MObject mObject,
			final Depend depend, Sort dependSort, LinkPaths links) {
			
		SelectOptions options = new SelectOptions(createMObject(), this);
		options.setAncestor(ancestor);
		options.setPaths(links);
		options.setUseRemoved(isUseRemoved());
		if (!dependSort.isSetRandom()) {
			dependSort.add(mObject.getName(),"id"); // for SELECT DISTINCT ON (order_string)
		}
		options.setSort(dependSort);
		options.setGetForeignAttrs(true);
		options.setLimit(isFirst ? this.limit : null);
		options.setSelectAttributes(createSelectAttrs(mObject, depend));
		options.setSContextCollection(sContextCollection);
		/*
		 * TODO            
		 * options.setDistinct(true);
		 */
		/*
		 * TODO was this options.setDistinct(this.page != null || this.limit != null);
		 */
		if (!dependSort.isSetRandom()) {
			options.setDistinctByOrder(true);
		}

		// Optimization:
		//  if tree="self" and plain request and exists id in query then select only these ids
		if (!this.treeMode  && tree.isOnlySelf() && this.objectQueryIds!=null ) {
			options.getAncestor().set(object,"id",new MValueCollection(this.objectQueryIds,true));
		}
		return options;
	}
	

	/**
	 * Optimization of the request.
	 * It finds <info attrs="..." /> and adds to select 
	 * @return
	 */
	private void grubChildInfoInstructionAttributes(MObject mObject) {
		// ????????? ???????? ?? <info attr="...">
		// ?????? ???? ??????????????? ??? RObjects
		if ( isProcessChildInfoInstruction() ) {
			childInfoInstructionData = new ChildInfoInstructionData();
			Node[] infoElements = XmlUtils.selectNodeArray(this._node, "./info[@attr]");
			for (Node infoElement : infoElements) {
				InfoInstruction.parseInfoAttrs(
						mObject, 
						(Element)infoElement, 
						childInfoInstructionData.attrNamesToSelect, childInfoInstructionData.attrNamesToCalculate
				);
			}
		}
	}

	private boolean isProcessChildInfoInstruction() {
		return ! idKeyExistsInQuery() && ! this.treeMode;
	}
	
	private Set<String> getTreePresentsAttrNames(MObject object) {
		Set<String> treePresentsAttrNames = new HashSet<String>();
		for (ObjectAttr a : object.getConfigObject().getTreePresentAttributes() ) {
			treePresentsAttrNames.add(a.getName());
		}		
		return treePresentsAttrNames;
	}
	

	private SelectAttributes createSelectAttrs(MObject object, Depend depend) {
		
		final String objectName = object.getName();
		final String objectRealName = object.getRealName();
		Set<String> attrNamesToSelect = getTreePresentsAttrNames(object);
		if (childInfoInstructionData!=null) {
			attrNamesToSelect.addAll( childInfoInstructionData.attrNamesToSelect );
		}
		SelectAttributes attrs = depend.createSelectAttrs(getDBHandler().getDBConfig());
		for (String attrName : attrNamesToSelect) {
			SelectAttributesItem item = attrs.get(objectName);
			if (item == null) {
				item = new SelectAttributesItem(objectRealName, objectName, true);
				attrs.add(item);
			}
			item.addAttribute(attrName);
		}
		return attrs;
	}


    private void setToAncestorDependIds(SingleAncestor ancestor, Depend depend) {
        Collection<String> objNamesInDepend= depend.getObjects();
        for (int i=_contextStack.size()-1;i>=0;i--) {
            Context c = _contextStack.get(i);
            if (c.getParents()!=null && c.getParents().sizeToProcess()>0 && !c.getParents().get(0).isRoot()) {
                String objName = c.getParents().get(0).getName();
                if (objNamesInDepend.contains(objName)) {
                    MValueCollection levelIds = c.getParents().idToProcess();
                    MValueCollection ancestorIds = ancestor.get(objName, "id");
                    if (ancestorIds == null || ancestorIds.isEmpty()) {
                        ancestor.set(objName, "id", levelIds);
                        objNamesInDepend.remove(objName); // exclude double setting into ancestor
                    } else {
                        /*
                         *  TODO ?????????? ??????????? (?? ???????? unittest)
                         *	??????, ??? ????? ???? ????????? ????????? get
                         */ 
                    }
                }
            }
        }
    }

	/**
	 * ??????? ? ????????? ??????? ? ??????, ??? non-tree ?????????
	 */
	private void insertObject(RowSet rs, RObject rObject, RObjectCollection rObjects, MValueCollection idCollection, DependKey dependKey,SContextCollection sContextCollection) throws ErrorCodeException {
		MObject obj = createMObject(rs);
		MValue id = obj.getAttribute("id").getValue();
		Id integerId = obj.getId();
		
		if (paginator!=null) {
			if (paginator.isCurrentPageFirstItem(rs.getRow()) ) {
				paginator.setFirstOnCurrentPageMObject(rs.getMObject(object));
			} else if (paginator.isCurrentPageLastItem(rs.getRow()) ) {
				paginator.setLastOnCurrentPageMObject(rs.getMObject(object));
			}
		}

		// ?????????? ?? RObject ? ??????? ? ??? ?? ????? RObjectCollection
		if (rObject.hasChildById(integerId) && rObjects.containsId(integerId)) {
			return; // ?? ????????? ?????
		}

		if (isNotPushToDOM(integerId)) {// ???? ?? ?????? ????????? ??????
			return;
		}

		boolean isProcessing = isNextProcessing(integerId);

		RObject newRObject = createRObject(obj, isProcessing, rs, sContextCollection);
		rObject.importChild(newRObject); // ?????????? XML
		setQueryAttribute(newRObject, dependKey);
		rObjects.add(newRObject);

		if (idInQuery(integerId) && !tree.isSiblingPlus()) {
			// ???????? id ??? ???????? ? ancestor ?? ?????? ???????
			idCollection.add(new MValue(null, id.get()));
		}

	}

    private MObject createMObject() throws DBConfigException {
    	MObject mObject = getDBHandler().getDBConfig().createMObject(object, getFilterMap());
    	mObject.setInlineQuery( getRequestEnvironment().isInlineMode() );
    	return mObject;
    }
    
	private MObject createMObject(RowSet rs) {
		MObject obj = rs.getMObject( this.object );
		obj.setInlineQuery( getRequestEnvironment().isInlineMode() );
		return obj;
	}

    /**
	 * ??????? RObject ?? ??????????? ?? ? ????
	 */
    private ContextAttrXmlGenerator contextXmlGenerator = null;
	private RObject createRObject(MObject obj, boolean isProcessing, RowSet rs, SContextCollection sContextCollection) throws RowSetException, RequestException {
		
		Id integerId = obj.getId();
		Id treeId = obj.getTreeId();

        if (isMarkFoundContext && sContextCollection !=null && contextXmlGenerator==null) {
            contextXmlGenerator = new ContextAttrXmlGenerator( sContextCollection.getSContext(obj.getName()));
        }
        
		Element objElement = obj.getDOMElement(this._node.getOwnerDocument(), contextXmlGenerator);

		// ????????? ?????????????? ????????
		setAttrCollection.insertAttrsToElement(objElement, obj, isProcessing);

        RObject result = new RObject(object, integerId, treeId, objElement, isProcessing);

        result.addForeignObjects(result, rs);

        getRequestEnvironment().checkRequestSizeHardLimit(result);
        getRequestEnvironment().checkRequestTimeHardLimit();

        return result;
	}

	/**
	 * !!! ???????? ????? ?????????? rObject ? ???????
	 */
	private void setQueryAttribute(RObject rObject, DependKey dependKey) {
		rObject.getElement().setAttribute(
		        "query",
		        dependKey.createQuery(this.object, rObject.getId(), removeFromQuery)
		);
	}


	/**
	 * ???? ?? ?????? ????????? ?????? ? request DOM?
	 */
	private boolean isNotPushToDOM(Id id) {
        if (this.treeMode) {
            return !tree.isSelfPlus() && idKeyExistsInQuery() && !idInQuery(id);
        }
		return tree.isOnlySelf() && !tree.isSelfPlus() && idKeyExistsInQuery() && !idInQuery(id);
	}

	/**
	 * ???? ?? ?????? ???????????? ? ??????????
	 */
	private boolean isNextProcessing(Id id) {
		return !idKeyExistsInQuery() || idInQuery(id) || tree.isSelfPlus() || tree.isSiblingPlus();
	}

	/**
	 * ?????????? ??????? id ? ??????? http query
	 */
	private boolean idInQuery(Id id) {
		return this.idKeyExistsInQuery() && this.objectQueryIds.contains(id);
	}

	/**
	 * ?????????? ??????? ????? object_id ? ??????? http query
	 */
	private boolean idKeyExistsInQuery() {
		return this.objectQueryIds != null;
	}

	/**
	 * ?????????? ???????? ????
	 */
	private void parseAttributes() throws RequestException {
		try {
			// ?????????? ?????????? ????????? ? ????
			object = getAttribute(PARAM_OBJECT, "");
			if (object.length() == 0)
				throw new RequestException(RequestException.REQUEST_EMPTY_OBJECT, "No object attribute in GET instruction or it is empty");
			dependObjects = parseNames(getAttribute(PARAM_DEPEND, ""));
			getDBHandler().getDBConfig().checkObjects(dependObjects, false);
			pathExclude = parseNames(getAttribute(PARAM_PATH_EXCLUDE, getAttribute(PARAM_EXCLUDE_DEPRICATED, "")));
			pathInclude = parseNames(getAttribute(PARAM_PATH_INCLUDE, getAttribute(PARAM_INCLUDE_DEPRECATED, "")));
			removeFromQuery = new HashSet<String>( parseNames(getAttribute(PARAM_REMOVE_FROM_QUERY, "")));
			paginator = parsePage(
			        parseInt(getAttribute(PARAM_PAGE_SIZE, null)),
			        parseInt(getAttribute(PARAM_PAGE, null)),
			        parseInt(getAttribute(PARAM_PAGE_COUNT, null)));
			limit = parseLimit(parseInt(getAttribute(PARAM_LIMIT, null)));
			tree = new Tree(getAttribute(PARAM_TREE, null));
			strTreeMode = getAttribute(PARAM_TREE_MODE, null);
			sort = parseSort(getAttribute(PARAM_SORT, null));
            isMarkFoundContext = StringParser.toBoolean(getAttribute(PARAM_CONTEXT_FOUND,"no"));
		}
		catch (ErrorCodeException e) {
			throw new RequestException(e);
		}
	}


    /**
	 * ???????? ?????????? ????? ?????, ??? ????? ??? ?? query
	 */
	private Integer parseInt(String strInt) throws RequestException {
		Integer i = null;
		if (strInt != null) {
			try {
				i = new Integer(StringParser.toInt(getQueryableString(strInt)));
			}
			catch (BadNumberException e) {
				if (!isQueryableValue(strInt)) {
					throw new RequestException(e);
				}
			}
		}
		return i;
	}
    

	private Sort parseSort(String strSort) throws SortParserException {
		Sort objSort = null;
		if (strSort != null) {
			objSort = new Sort(getDBHandler().getDBConfig(), this.object, strSort);
		}
		else {
            String defaultSort = null;
            try {
                defaultSort = getDBHandler().getDBConfig().getConfigObject(this.object).getDefaultSortString();
                objSort = new Sort(getDBHandler().getDBConfig(), this.object, defaultSort);
            } catch(Throwable e) {
                objSort = new Sort(getDBHandler().getDBConfig());
            }
		}
		return objSort;
	}

	private Paginator parsePage(Integer pageSize, Integer pageNum, Integer siblingsCount) {
		Paginator p = null;
		int pNum = 1;
		if (pageSize != null && pageSize.intValue() > 0) {
			if (pageNum == null) { // try get page num from default query key
				List<QueryValue> values = _contextStack.peek().getQuery().get(PAGE_QUERY_PREFIX + this.object);
				if (values != null && values.size() > 0) {
					try {
						pageNum = new Integer(values.get(0).toString());
					}catch (Exception e) {
					}
				}
			}
			if (pageNum != null && pageNum.intValue() > 0) {
				pNum = pageNum.intValue();
			}
			p = new Paginator(pageSize.intValue(), pNum, siblingsCount);

		}
		return p;
	}

	private Limit parseLimit(Integer limitSize) {
		Limit limitObj = null;
		if (limitSize != null && limitSize.intValue() > 0) {
			limitObj = new Limit(null,limitSize.intValue());
		}
		return limitObj;
	}

	/**
	 * ????????? ? XML ?????????????? ????
	 */
	private void insertCalculatedAttrubutes(RObjectCollection rObjects) throws ErrorCodeException {
		// ?????? ?????????????? ????, isDefaultSelected()
		Set<ObjectAttr> calcAttrs = new HashSet<ObjectAttr>();
		for (ObjectAttr oAttr : getDBHandler().getDBConfig().getConfigObject(object).getCalculatedAttributes()) {
			if ( 
					oAttr.isDefaultSelected() 
					|| ( childInfoInstructionData!=null && childInfoInstructionData.attrNamesToCalculate.contains(oAttr.getName()) )
			){
				calcAttrs.add(oAttr);
			}
		}
		CalculatedAttrProcessor.perform(getDBHandler(), calcAttrs, rObjects, getLinkCache() ,getFilterMap(), this);
	}

	/**
	 * ????????????? ????? ?????????? get
	 * ?? ?????? ???????? ?? ????? ??????????, ??? ??? ?? ?????? ????????? MObject
	 */
	private void setTreeMode(MObject mObject) throws RequestException {
		if (strTreeMode == null) {
			treeMode = mObject.isTree();
			return;
		} else {
			if (!strTreeMode.equals("plain") && !strTreeMode.equals("tree")) {
				throw new RequestException(RequestException.REQUEST_INVALID_TREE_MODE, "attribute tree-mode must contains 'plain' or 'tree' value");
			}
			if (!mObject.isTree() && strTreeMode.equals("tree")) {
				throw new RequestException(RequestException.REQUEST_INVALID_TREE_MODE, "attribute tree-mode must be 'plain' for non-tree object " + object);
			}
			treeMode = mObject.isTree() && !strTreeMode.equals("plain");
		}
	}

	/**
	 * ???????????? ?????????? ??????????? ???????? ??????
	 * @return ????????? id, ??????? ?????????? ???????? ? ???????? ??????? get
	 */
	private MValueCollection processTree(RObjectCollection selfRObjects, Depend depend, SContextCollection sContextCollection) throws ErrorCodeException {

		MValueCollection selfIdCollection = selfRObjects.idToProcess();

		if (selfIdCollection.size() == 0) {
			return new MValueCollection(); // ??????? ?????????? ??????
		}

		// ????????? request:found="yes" ??? selfRObjects
		setFoundAttribute(selfRObjects);

		boolean isAddedToProcess = false;

		// RObjectTree ???????????? selfRObjects ? ??????
		RObjectTree rObjectTree = null;
		try {

			// 1. ?????? ??????? <get>
			// 2. ?????? ??????????? ??????? ??? ?????? self
			//   2.1 ? ancestor
			//   2.2 limit
			//   2.3 pages
			// => ????? ??? ??????? ?? ??????? ? ????????????? ? ?????????? ?????????
			if (isFirstUnlimitedLevel()) {
				// ???????? ??????????, ??????? ??? ??????????? ???
				Map<Id,Integer> order = new HashMap<Id,Integer>();
				int index = 0;
				for (Iterator<RObject> i = selfRObjects.iterator(); i.hasNext();) {
					order.put(i.next().getId(), new Integer(index++));
				}
				rObjectTree = new RObjectTree(selfRObjects, new RObjectComparator(order));
				return new MValueCollection(); // ?????? ????????? ? ancestor
			}

			RObjectComparator comparator = null;

			// ????????? ?????????? sibling ? ?????? XML
			comparator = createTreeComparator(selfIdCollection);

			rObjectTree = new RObjectTree(selfRObjects, comparator);

			if (tree.isSibling()) {
				isAddedToProcess = processTreeMode(Handler.TREE_SIBLING, rObjectTree, selfIdCollection, depend, sContextCollection);
			}
			if (tree.isParent()) {
				isAddedToProcess =
				        processTreeMode(Handler.TREE_PARENT, rObjectTree, selfIdCollection, depend, sContextCollection)
				        || isAddedToProcess;
			}
			if (tree.isAncestor()) {
				isAddedToProcess =
				        processTreeMode(Handler.TREE_ANCESTOR, rObjectTree, selfIdCollection, depend, sContextCollection)
				        || isAddedToProcess;
			}
			if (tree.isChildren()) {
				isAddedToProcess =
				        processTreeMode(Handler.TREE_CHILDREN, rObjectTree, selfIdCollection, depend, sContextCollection)
				        || isAddedToProcess;
			}
			if (tree.isDescendant()) {
				isAddedToProcess =
				        processTreeMode(Handler.TREE_DESCENDANT, rObjectTree, selfIdCollection, depend, sContextCollection)
				        || isAddedToProcess;
			}
		}
		finally {
			if (rObjectTree != null) {
				rObjectTree.destroy();
			}
		}
		// isAddedToProcess - ?? ????????????, ? ancestor ????? ????????? ?????? plain id,
		// ?????? ????????? id ????????? ?? ????????? ????????????, ??? ??? ???
		// ?????????? ?????? ?????????? ??????? ????? ?????????? ????? children ?? children (????????)
		// return selfIdCollection; //(isAddedToProcess)? selfRObjects.idToProcess() : new MValueCollection();
		// ?????? ???????????? ?????? id ???????????? ? Ancestor
		return (isAddedToProcess)? selfRObjects.idToProcess() : new MValueCollection();
	}

	private boolean isFirstUnlimitedLevel() {
        return isFirst
		        && !_contextStack.peek().getAncestor().group().exists(object)
                && !_contextStack.peek().getSContextCollection().getObjects().contains(object)
                && limit == null
		        && paginator == null;
	}

	private boolean processTreeMode( final int treeMode, RObjectTree rObjectTree, MValueCollection selfIdCollection, Depend depend, final SContextCollection sContextCollection) throws ErrorCodeException {

		String treeAlias = "_tree_";
		
		MObject treeOptMObj = createMObject();
		SelectTreeOptions options = new SelectTreeOptions(treeOptMObj, this);
		options.setMode(treeMode);
		options.setTreeAlias(treeAlias);
		options.setPlainIdCollection(selfIdCollection);
		options.setGetForeignAttrs(true);
		options.setUseRemoved(isUseRemoved());
		
		final List<RObject> listRObjects = new LinkedList<RObject>(); // ??? ????????? ? ???????? RObject
		
		boolean wasAddToProcess = (Boolean)getDBHandler()
		.selectTree( options, new RowSetCallback() {

			@Override
			public Object doInRowSet(RowSet rs) throws Exception {
				boolean wasAdded = false;
				while (rs.next()) {
					MObject obj = createMObject(rs);
					Id integerId = obj.getId();
					// ??????? ??? ??????????? ??????????? ????
					boolean isProcessing = idInQuery(integerId) || GetInstruction.this.tree.isPlus(treeMode);
					RObject rObject = createRObject(obj, isProcessing, rs, sContextCollection);
					wasAdded = isProcessing || wasAdded;
					listRObjects.add(rObject);
				}
				return wasAdded;
			}

		});
		
		RObjectCollection insertedRObjects = rObjectTree.insert(treeMode, listRObjects);
		// ??????? ???????? query ??? ???? ??????????? RObject's
		for (Iterator<RObject> i = insertedRObjects.iterator(); i.hasNext();) {
			RObject ro = i.next();
			setQueryAttribute(ro, depend.createKey(ro));
		}
		
		
		return wasAddToProcess;
	}


    /**
	 * ????????? request:found="yes" ??? selfRObjects
	 *
	 */
	private void setFoundAttribute(RObjectCollection selfRObjects) {
		for (Iterator<RObject> i = selfRObjects.iterator(); i.hasNext();) {
			RObject rObject = i.next();
			// ????????? namespace ??? request
			rObject.getElement().setAttribute("xmlns:" + Request.DOM_NAMESPACE, Request.DOM_NAMESPACE_URI);
			rObject.getElement().setAttributeNS(
			        Request.DOM_NAMESPACE_URI,
			        Request.DOM_NAMESPACE + ":found",
			        "yes"
			);

		}
	}

	/**
	 * ??????? comparator ??? ????????? ????????? id
	 *
	 */
	private RObjectComparator createTreeComparator(MValueCollection selfIdCollection) throws ErrorCodeException {
		// ???? ????????? SQL, ??????? ?????? id ?????? ???????
		// ? ?????????? ???????????? <get/>
		// ? ??? id ?????? ???? ????????
		//  - id ?? ????? selfIdCollection
		//  - id ??????????????? ??????? ? tree
		// ????? ???? ?? ?????? ?????????????????? ?????? id ???????? comparator

		final Map<Id,Integer> sortOrder = new HashMap<Id,Integer>();

		SelectTreeOptions options = new SelectTreeOptions(createMObject(), this);
		options.setTreeType(tree);
		options.setPlainIdCollection(selfIdCollection);
		options.setSort(sort);
		
		getDBHandler().selectTree(options, new RowSetCallback(){

			@Override
			public Object doInRowSet(RowSet rs) throws Exception {
				int order = 1;
				while (rs.next()) {
					MObject obj = rs.getMObject(object);
					sortOrder.put(obj.getId(), new Integer(order++));
				}
				return null;
			}
			
		});

		return new RObjectComparator(sortOrder);

	}

	class ChildInfoInstructionData {
		Set<String> attrNamesToSelect = new HashSet<String>();
		Set<String> attrNamesToCalculate = new HashSet<String>();
	}

}

