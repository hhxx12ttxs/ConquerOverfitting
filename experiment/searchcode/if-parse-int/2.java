/*
 * BEGIN_HEADER - DO NOT EDIT
 *
 * The contents of this file are subject to the terms
 * of the Common Development and Distribution License
 * (the "License").  You may not use this file except
 * in compliance with the License.
 *
 * You can obtain a copy of the license at
 * https://open-jbi-components.dev.java.net/public/CDDLv1.0.html.
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL
 * HEADER in each file and include the License file at
 * https://open-jbi-components.dev.java.net/public/CDDLv1.0.html.
 * If applicable add the following below this CDDL HEADER,
 * with the fields enclosed by brackets "[]" replaced with
 * your own identifying information: Portions Copyright
 * [year] [name of copyright owner]
 */

/*
 * @(#)Parse.java
 *
 * Copyright 2004-2007 Sun Microsystems, Inc. All Rights Reserved.
 *
 * END_HEADER - DO NOT EDIT
 */

package com.sun.encoder.custom.runtime.provider;

import java.io.File;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.namespace.QName;

import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;

import com.sun.encoder.runtime.CoderFactory;
import com.sun.encoder.runtime.OtdInputStream;
import com.sun.encoder.runtime.OtdLocation;
import com.sun.encoder.runtime.OtdMeta;
import com.sun.encoder.runtime.StringCoder;
import com.sun.encoder.runtime.UnmarshalException;
import com.sun.encoder.runtime.provider.SimpleContentHandler;
import com.sun.encoder.runtime.provider.StringOtdInputStreamImpl;
import com.sun.encoder.runtime.provider.WrapOtdInputStream;
import com.sun.encoder.custom.runtime.provider.Delim.Slot;
import com.sun.encoder.custom.runtime.provider.Nodes.Node;
import com.sun.encoder.custom.runtime.provider.Nodes.Node.Align;
import com.sun.encoder.custom.runtime.provider.Nodes.Node.Type;
import com.sun.encoder.custom.runtime.provider.Nodes.Node.UndefDataPolicy;
import com.sun.encoder.custom.runtime.provider.OtdDelim.DelimLevel;
import com.sun.encoder.custom.runtime.provider.OtdDelim.DelimStack;
import com.sun.encoder.runtime.provider.Misc;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.util.logging.FileHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

/**
 * Class to parse input data according to BUD node descriptors.
 *
 * The node descriptors are generated by the BUD code generator;
 * all other parser logic is in this run-time class only.  The parser
 * partitions the input stream into a mapping array (see match()),
 * and then builds and populates the run-time Java OTD storage tree
 * from this mapping (see apply()) using the BudNode interface implemented
 * by the classes generated for the non-leaf nodes.  Note that we do not
 * depend on the generic interface (OtdNode, OtdRoot, OtdMeta) or on the
 * bean-like (getX(), setX() etc.), but only on the BudNode interface;
 * the low-level tester (BudTest) uses this to simulate building and
 * running a BUD OTD without ever generating a line of code. The BudNode
 * interface is close to the generic OtdNode interface, minus access
 * controls, and at the raw byte level for data.
 *
 * One potentially time-consuming task during parsing is manipulating
 * the lexer state, which is a product of the path of ancestor nodes and
 * their associated delimiters and length limits. Only some potential states
 * will actually be used, so precomputing all possible states would be
 * wasteful (and potentially huge), but recomputing them during parsing
 * is too slow, so we compromise and compute them once at run-time, and
 * then cache them in the OTD class or (for embedded delimiters) instance.
 * Other than that, it's a simple recursive descent, first-fit parser with
 * backtracking, and with a highly context sensitive lexer.
 *
 * @author Michael Libourel
 * @author Jun Xu
 */
public final class Parse implements OtdDelim.MatchReply {

    private final OtdDelim.OtdDelimInst mOtdDelimInst;

    private final Nodes mNodes;

    /** the current match map. */
    private Match mMatch = new Match();

    /** The whole input data bytes. NYI: should be OtdInputStream. */
    private byte[] mData = null;

    /** current parse position in the data bytes. */
    private int mPos = 0;

    private int mEnd = 0;

    /** true if parent terminators have been encountered. */
    private boolean mDone = false;

    /** in order to pass last delim found back to its parent. */
    private Delim mLastDelim = null;

    /** for a local terminator present at the last sibling or last repetition,
     * and its terminator mode of NEVER/AVOID. For open-esb Issue 1522
     */
    private Delim mAvoidedTerminator = null;

    /** the root node's metadata, if known. */
    private OtdMeta mMeta = null;

    private Logger mLog = Logger.getLogger(getClass().getName());

    static final String LN = System.getProperty("line.separator");

    private OtdDelim.Pos mLookaheadPos = new OtdDelim.Pos();

    /**
     * Constructs parse environment on a given OTD instance.
     *
     * @param inst the OTD instance for delimiters
     * @param nodes Nodes.
     */
    public Parse(final OtdDelim.OtdDelimInst inst, final Nodes nodes) {
        mOtdDelimInst = inst;
        mNodes = nodes;
        mMatch.setMetadataLocation(mNodes.getMetadataLocation());
        mMatch.setMetadataNamespace(mNodes.getMetadataNamespace());
    }

    /**
     * The postion where a match occurred.
     */
    private int mMatchPos = 0;

    /** the position at which data was found. */
    private int mDataStartPos = 0;

    /** the matched data length. */
    private int mDataLength = 0;

    /** the flag that indicates a begin delimiter is matched. */
    private boolean mIsBeginDelimMatched = false;

    private String mReason = null;

    /**
     * Sets the position at which a match occurred.
     * Required by the MatchReply interface, callback from DelimStack.
     *
     * @param matchPosition  the position in the buffer.
     */
    public void setMatchPos(final int matchPosition) {
        mMatchPos = matchPosition;
    }

    public int getMatchPos() {
        return mMatchPos;
    }

    /**
     * Sets the position at which data was found
     * Required by the MatchReply interface, callback from DelimStack.
     *
     * @param pos  the position in the buffer
     */
    public void setDataStartPos(int pos) {
        mDataStartPos = pos;
    }

    /**
     * Sets the matched data length.
     * Required by the MatchReply interface, callback from DelimStack.
     *
     * @param length the data length
     */
    public void setDataLength(int length) {
        mDataLength = length;
    }

    /**
     * Sets the flag that indicates a begin delimiter is matched.
     *
     * @param begin <code>true</code> is a begin delimiter is matched,
     *              otherwise <code>false</code>.
     */
    public void setBeginDelimMatched(boolean begin) {
        mIsBeginDelimMatched = begin;
    }

    /**
     * Sets the OtdMeta object.
     * @param meta the OtdMeta object.
     */
    public void setMeta(final OtdMeta meta) {
        mMeta = meta;
    }

    @Override
    public String toString() {
        StringBuffer buf = new StringBuffer();
        buf.append("Parse@").append(Integer.toHexString(hashCode()));
        buf.append(" matchPosition=").append(mMatchPos);
        buf.append(" dataStartPos=").append(mDataStartPos);
        buf.append(" dataLength=").append(mDataLength);
        buf.append(" isBeginDelimMatched=").append(mIsBeginDelimMatched);
        if (mReason != null) {
            buf.append(" reason=").append(mReason);
        }
        return buf.toString();
    }

    /**
     * Log parse starting information.
     * @param tag input source tag where parse is about to perform on.
     * @param top the mNodes[] index of the top rule to use.
     */
    private void logParseStartingInfo(String tag, int top) {
        if (mLog.isLoggable(Level.FINE)) {
            StringBuffer buf = new StringBuffer();
            buf.append("Parse from ").append(tag).append(". Top index=");
            buf.append(top).append(LN).append("Delimiters: ");
            Delim[] delims = mOtdDelimInst.getOtdDelim().mDelims;
            for (int i = 0; i < delims.length; i++) {
                Delim delim = delims[i];
                buf.append(LN).append(" Delimiter#").append(i).append("=[");
                buf.append(delim == null ? "null" : delim.dump()).append("]");
            }
            if (mLog.isLoggable(Level.FINEST)) {
                buf.append(LN).append("OtdDelimInst: ").append(mOtdDelimInst);
                buf.append(LN).append("Nodes: ");
                for (int i = 0; i < mNodes.mNodes.length; i++) {
                    Node node = mNodes.mNodes[i];
                    buf.append(LN).append(" Node#").append(i);
                    if (node != null) {
                        buf.append("=[name=").append(node.mName);
                        buf.append(" type=").append(node.type()).append("]");
                    } else {
                        buf.append("=null");
                    }
                }
            }
            if (mLog.isLoggable(Level.FINEST)) {
                mLog.finest(buf.toString());
            } else {
                mLog.fine(buf.toString());
            }
        }
    }

    /**
     * Scans the set of embedded delimiters from the input data.
     * Assumes the input is at data start, will rewind after it scans anything.
     *
     * @param slots  the list of slots
     * @param in  the input stream
     * @return the list of embedded delimiter byte sequences
     * @throws UnmarshalException if the message lacks the embedded data
     * @throws IOException on input problems
     */
    public byte[][] getEmbeddedDelimiters (Slot[] slots, OtdInputStream in)
        throws IOException, UnmarshalException {
        if (slots == null) {
            return null;
        }
        byte[][] data = new byte[slots.length][];
        long offset = 0, skip;
        for (int i = 0; i < slots.length; i++) {
            data[i] = new byte[slots[i].mLength];
            if ((skip = slots[i].mOffset - offset) < 0) {
                // Overlapping or unordered slot.
                in.rewind();
                skip += offset;
                offset = 0;
            }
            if (skip > 0) {
                in.skip(skip);
                offset += skip;
            }
            /*-
            for (long kludge = 0; kludge < skip; kludge++)
                in.read();
            -*/
            if (in.read(data[i]) < data[i].length) {
                throw new UnmarshalException(new Ud1Location(offset),
                    "Embedded delimiter (offset="
                    + slots[i].mOffset + ", length="
                    + slots[i].mLength + ") extends beyond end of data.");
            }
            offset += slots[i].mLength;
            if (mLog.isLoggable(Level.FINE)) {
                mLog.fine("Got embed #" + i + "="
                    + Misc.printable(data[i]));
            }
        }
        if (offset > 0) {
            in.rewind();
        }
        return data;
    }

    /**
     * Retrieves the node descriptor set.
     *
     * @return the set
     */
    public Nodes getNodes() {
        return mNodes;
    }

    /**
     * The maximum number of bytes of context  given by fragment().
     * NYI: Maybe this should be a variable, or a user specific property.
     */
    private static final int FRAG_SIZE = 10;

    /**
     * Constructs dump fragment of input data.
     * Gives at most FRAG_SIZE bytes of data preceding and following the
     * current input position.  The data itself is quoted printable; bracketed
     * SOD, EOD and POS denote the , end of data and current input
     * position respectively.
     *
     * @param position position to dump.
     * @return the dump.
     */
    private String getDataFragment(int position) {
        int len = mData.length;
        int ante = position - FRAG_SIZE;
        int post = position + FRAG_SIZE;
        if (ante < 3) {
            ante = 0;
        }
        if (post > len - 3) {
            post = len;
        }
        StringBuffer sb = new StringBuffer();
        // SOD = Start Of Data
        sb.append(ante == 0 ? "<SOD>" : "...");
        for (int i = ante; i < post; i++) {
            if (i == position) {
                // POS = current input POSition
                sb.append("<POS>");
            }
            sb.append(Misc.printable(mData[i]));
        }
        // EOD = End Of Data
        sb.append(post == len ? "<EOD>" : "...");
        if (position == len) {
            sb.append("<POS>");
        }
        return sb.toString();
    }

    public static final String NO_PATH = "<no path>";

    /**
     * Converts the last matched element to a symbolic path.
     * If the metadata is not passed in, this returns a numeric path instead.
     *
     * @param meta  the root of the run-time OTD metadata, or null.
     * @param match the Match object.
     * @return the path, or NO_PATH if none known
     */
    public static String getLastMatchedElementPath(OtdMeta meta, Match match) {
        Integer[] at = match.getLastNodePath();
        if (at == null || at.length == 0) {
            return NO_PATH;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < at.length; i += 2) {
            sb.append('.');
            // at[i] is child index
            if (meta == null || meta.isLeaf() || at[i] > meta.getChildCount()) {
                // output as numeric representation.
                sb.append(at[i]);
                meta = null;
            } else {
                // output as symbolic representation.
                meta = meta.getChild(at[i]);
                sb.append(meta.getName());
            }
            if (at[i + 1] >= 0) {
                // at[i + 1] is repetition index
                sb.append("[" + at[i + 1] + "]");
            }
        }
        // get rid of the first character '.'
        return sb.toString().substring(1);
    }

    /**
     * Reports an input data match failure.
     *
     * @param node
     * @param msg  the error message
     * NYI: should be localized, and use the Notifier interface
     * NYI: should include node descriptor
     * NYI: should print name of path to failure
     * NYI: should record longest match maybe
     */
    public void fail(Nodes.Node node, String msg) {
        mMatch.log(mLog, mData);
        String str = "Parse failed with data=" + getDataFragment(mPos) + (node != null && node.mName != null ? " for node name='" + new QName(node.mNamespace, node.mName) + "'" : "") + " after last matched path=" + getLastMatchedElementPath(mMeta, mMatch) + ": " + msg;
        if (mLog.isLoggable(Level.SEVERE)) {
            mLog.severe(str);
        }
        throw new UnmarshalException(new Ud1Location(mPos), str);
    }

    /**
     * Checks for a specific byte sequence.
     *
     * @param align  the alignment, from Align
     * @param data  the byte sequence to match
     * @param pattern the regex pattern if any, otherwise <code>null</code>
     * @param from  offset in input
     * @param to  offset past end of input to match
     * @param isNoMatch flag indicates if the match condition should be reverted
     * @return error message text if comparison fails, else null
     */
    private String checkByteSeq(Align align, byte[] data, Pattern pattern,
            int from, int to, boolean isNoMatch) {
        // Need to match specific byte sequence.
        if (mLog.isLoggable(Level.FINER)) {
            mLog.finer("checkByteSeq(), align=" + align + " data=[" + Misc.showFragment(data) + "] from=" + from + ", to=" + to + ", noMatch=" + isNoMatch + ".");
        }
        int len = to - from;
        int rest = len - data.length;
        String reason;
switchLoop:
        switch (align) {
            case BLIND:
                // Blind match: always okay.
                reason = null;
                break;
            case BEGIN:
                // Look for match at start of data.
                if (rest < 0) {
                    reason = "Failed begin-match length";
                    break;
                }
                // Length okay, check contents.
                for (int i = 0; i < data.length; i++) {
                    if (mData[from + i] != data[i]) {
                        reason = "Failed begin-match sequence"; //- + i;
                        break switchLoop;
                    }
                }
                // Match okay.
                reason = null;
                break;
            case EXACT:
                // Look for complete match.
                if (rest != 0) {
                    reason = "Failed exact-match length";
                    break;
                }
                // Length okay, check contents.
                for (int i = 0; i < data.length; i++) {
                    if (mData[from + i] != data[i]) {
                        reason = "Failed exact-match sequence"; //- + i;
                        break switchLoop;
                    }
                }
                // Match okay.
                reason = null;
                break;
            case FINAL:
                // Look for match at end of data.
                if (rest < 0) {
                    reason = "Failed final-match length";
                    break;
                }
                // Length okay, check contents.
                from += rest;
                for (int i = 0; i < data.length; i++) {
                    if (mData[from + i] != data[i]) {
                        reason = "Failed final-match sequence"; //- + i;
                        break;
                    }
                }
                // Match okay.
                reason = null;
                break;
            case INTER:
                // Look for match anywhere in the data.
                if (rest < 0) {
                    reason = "Failed inter-match length";
                    break;
                }
                // Length okay, check contents.
outer:
                for (; rest-- >= 0; from++) {
                    for (int i = 0; i < data.length; i++) {
                        if (mData[from + i] != data[i]) {
                            continue outer;
                        }
                    }
                    // Match okay.
                    reason = null;
                    break switchLoop;
                }
                reason = "Failed inter-match sequence"; //- + i;
                break;
            case ONEOF:
                /** Look for match with one of given sub-sequences;
                 * each sub-sequence is initiated by first byte of match
                 * sequence. Example: if match sequence is "+one+two",
                 * input data must be "one" or "two".
                 */
                if (data.length < 1) {
                    reason = "Failed oneof-match length";
                    break;
                }
                byte init = data[0];
                int next;
                // Length okay, check contents.
outer:
                for (int pos = 0; pos < data.length; pos = next) {
                    next = ++pos;
                    while (next < data.length && data[next] != init) {
                        next++;
                    }
                    if ((next - pos) == len) {
                        for (int i = 0; i < len; i++) {
                            if (mData[from + i] != data[pos + i]) {
                                continue outer;
                            }
                        }
                        // Match okay.
                        reason = null;
                        break switchLoop;
                    }
                }
                reason = "Failed oneof-match sequence"; //- + i;
                break;
            case SUPER:
                // Look for substring match by full data.
                if (rest > 0) {
                    reason = "Failed super-match length";
                    break;
                }
                // Length okay, check contents.
outer:
                for (int sub = 0; rest++ <= 0; sub++) {
                    for (int i = 0; i < len; i++) {
                        if (mData[from + i] != data[sub + i]) {
                            continue outer;
                        }
                    }
                    // Match okay.
                    reason = null;
                    break switchLoop;
                }
                reason = "Failed super-match sequence"; //- + i;
                break;
            case REGEX:
                Matcher m = pattern.matcher(
                    new Latin1CharSequence(mData, from, to));
                if (!m.matches()) {
                    reason = "Failed regex match";
                    break;
                }
                reason = null;
                break;
            default:
                // Huh?
                throw new RuntimeException("Unsupported alignment=" + align);
        }

        if (!isNoMatch) {
            return reason;
        }
        if (reason == null) {
            return "No match but matched";
        } else {
            return null;
        }
    }

    /**
     * Retrieves the OtdDelimInst object.
     *
     * @return OtdDelimInst object.
     */
    public OtdDelim.OtdDelimInst getOtdDelimInst() {
        return mOtdDelimInst;
    }

    /**
     * Checks if the bytes only contains scavenger bytes.
     *
     * @param start the starting position
     * @param end the end position
     * @param mScavengerIndex the indexed bytes scavengerBytes to to be checked.
     * @return <code>true</code> if the bytes are skippable (only contains
     *          scavenger bytes), otherwise <code>false</code>.
     */
    private  boolean isSkippable(int start, int end, byte[] mScavengerIndex) {
        if (mScavengerIndex == null) {
            return false;
        }
        while (start < end && mScavengerIndex[mData[start]] == Nodes.ON) {
            start++;
        }
        return start >= end;
    }

    /**
     * Performs regex match on <code>mBytes</code> and matches as much as
     * possible.  Returns the match result in an instance of
     * <code>OtdDelim.MatchReply</code>.
     *
     * @param pattern the regular expression pattern
     * @param pos the start position in <code>mBytes</code>
     * @param end the end position in <code>mBytes</code> (just pass the last
     *            byte of the data chunk that needs to be matched)
     * @param reply the instance used to return match result
     */
    private void matchRegex(Pattern pattern, int pos, int end,
            OtdDelim.MatchReply reply) {
        Matcher m = pattern.matcher(new Latin1CharSequence(mData, pos, end));
        if (m.find()) {
            reply.setDataStartPos(pos);
            reply.setMatchPos(pos + m.end());
            reply.setDataLength(m.end());
        } else {
            reply.setDataStartPos(pos);
            reply.setMatchPos(pos);
            reply.setDataLength(0);
        }
    }

    /**
     * Search byte sequence match in the data from the current position.
     *
     * @param bytes the byte sequence to be searched.
     * @param anchored whether the byte sequence should appear at the beginning.
     * @param end end index.
     * @return the position of the byte sequence being found or -1 if not found.
     */
    private int indexOf(byte[] bytes, boolean anchored, int end) {
        int rest = end - mPos - bytes.length;
        if (rest < 0) {
            return -1;
        }
        if (anchored) {
            for (int i = 0, pos = mPos; i < bytes.length; i++, pos++) {
                if (bytes[i] != mData[pos]) {
                    return -1;
                }
            }
            return mPos;
        }
outerLoop:
        for (int startpos = mPos; rest-- >= 0; startpos++) {
            if (mData[startpos] == bytes[0]) {
                for (int i = 1, pos = startpos + 1;
                    i < bytes.length; i++, pos++) {
                    if (bytes[i] != mData[pos]) {
                        continue outerLoop;
                    }
                }
                return startpos;
            }
        }
        return -1;
    }

    /**
     * Checks if a delimiter has same begin bytes and end bytes
     *
     * @param delim the delimiter
     * @return <code>true</code> if has same begin and end bytes.
     */
    private boolean hasSameBeginEndBytes(Delim delim) {
        if (delim.mBeginDelim != null && delim.mBytes != null
                && delim.mBeginDelim.length == delim.mBytes.length) {
            if (delim.mBeginDelim.length == 0) {
                return delim.mBeginDelim[0] == delim.mBytes[0];
            }
            for (int i = 0; i < delim.mBeginDelim.length; i++) {
                if (delim.mBeginDelim[i] != delim.mBytes[i]) {
                    return false;
                }
            }
            return true;
        } else if (delim.mBeginSlotIndex >= 0 && delim.mSlotIndex >= 0) {
            if (delim.mBeginSlotIndex == delim.mSlotIndex) {
                return true;
            }
            final int len = mOtdDelimInst.getOtdDelim().mSlots[delim.mBeginSlotIndex].mLength;
            if (len != mOtdDelimInst.getOtdDelim().mSlots[delim.mSlotIndex].mLength) {
                return false;
            }
            final int p1 = (int) mOtdDelimInst.getOtdDelim().mSlots[delim.mBeginSlotIndex].mOffset;
            final int p2 = (int) mOtdDelimInst.getOtdDelim().mSlots[delim.mSlotIndex].mOffset;
            for (int i = 0; i < len; i++) {
                if (mData[i + p1] != mData[i + p2]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Applies match to given input byte array.
     *
     * @param top  the mNodes[] index of the top rule to use
     * @param handler the SAX content handler that receives the parsing result
     * @param decoder the character decoder used to decode byte[] into string
     * @param data  the input data to match
     * @return
     * @throws IOException for input streaming problems
     * @throws UnmarshalException on input match failure
     * @throws SAXException SAX exception when fires SAX events
     */
    public boolean parseFromBytes(int top, ContentHandler handler,
        StringCoder decoder, byte[] data)
        throws IOException, UnmarshalException, SAXException {
        Node root = mNodes.get(top);
        // ensure top is not a leaf field
        if (root.isLeaf()) {
            throw new IllegalArgumentException("Leaf field can't be top rule"); //I18N
        }
        logParseStartingInfo("input byte array", top);

        OtdInputStream in = new StringOtdInputStreamImpl(data);
        mOtdDelimInst.setSlotData(getEmbeddedDelimiters(mOtdDelimInst.getOtdDelim().mSlots, in));
        mData = data;
        return parseRoot(top, handler, decoder, in);
    }

    /**
     * Applies match to given input.
     *
     * @param top  the mNodes[] index of the top rule to use
     * @param handler the SAX content handler that receives the parsing result
     * @param decoder a StringCoder.
     * @param in the input data stream.
     * @return true if parse is done successfully, or false otherwise.
     * @throws IOException for input streaming problems
     * @throws UnmarshalException on input match failure
     * @throws SAXException SAX exception when fires SAX events
     */
    public boolean parseFromInputStream(int top, ContentHandler handler,
        StringCoder decoder, OtdInputStream in)
        throws IOException, UnmarshalException, SAXException {
        Node root = mNodes.get(top);
        // ensure top is not a leaf field
        if (root.isLeaf()) {
            throw new IllegalArgumentException("Leaf field can't be top rule."); //I18N
        }
        logParseStartingInfo("input stream", top);

        // This fakes working with an input stream...
        // NYI: make this hack obsolete!
        mOtdDelimInst.setSlotData(getEmbeddedDelimiters(mOtdDelimInst.getOtdDelim().mSlots, in));
        mData = WrapOtdInputStream.getBytes(in);
        return parseRoot(top, handler, decoder, in);
    }

    private boolean parseRoot(int top, ContentHandler handler,
        StringCoder decoder, OtdInputStream in)
        throws IOException, SAXException {

        mPos = 0;
        mDone = false;
        mLastDelim = null;
        mEnd = mData.length;

        if (mLog.isLoggable(Level.FINE)) {
            mLog.fine("Clear match list.");
        }
        mMatch.clear();

        Node root = mNodes.get(top);
        DelimStack delimStack_ = mOtdDelimInst.getOtdDelim().mEmptyStack;
        int matchedCount = handleNode(root, true, null, delimStack_, 0, true, 0, true);
        // (node, required, delimLevel, delimStack, count, ordered, startOfOffset, lastChild)

        if (matchedCount != 1) {
            // Should not happen; fail() should have thrown exception.
            throw new RuntimeException("Mandatory match of top failed."); //I18N
        }
        if (mPos < mEnd) {
            // check on undefined data policy configuration
            switch (mNodes.getUndefDataPolicy()) {
                case PROHIBIT:
                    fail(null, "At end of data leftover bytes number=" + (mEnd - mPos));
                    break;
                case MAP:
                    int itmIdx = mMatch.getLastLeaveIndex();
                    if (itmIdx != -1) {
                        mMatch.insertField(itmIdx, -1, -1, mPos, (mEnd - mPos));
                            // (itemIdx, childIndex, repIndex, offset, length)
                    }
                    break;
                case SKIP:
                    break;
                default:
                    throw new IllegalArgumentException("Bad UndefDataPolicy="
                        + mNodes.getUndefDataPolicy());
            }
        }

        // Check for proper termination
        if (mLastDelim != null) {
            if (mLastDelim.mTermMode == Delim.Mode.NEVER) {
                if (!mDone) {
                    fail(null, "Expecting more data, most likely caused by a delimiter at the end of data.");
                }
            }
        }

        mMatch.log(mLog, mData);

        if (mLog.isLoggable(Level.FINE)) {
            mLog.fine("Applying matched item list to generate XML output.");
        }
        mMatch.apply(mNodes, handler, decoder, in);
        return true;
    }

    /**
     * Parses a non-repeated delimited simple field (i.e. leaf node).
     *
     * 1. If we are in end-of-parent state, fail the match.
     *
     * 2. Update the delimiter state.
     *    a. Replace/override the global delimiter list by the one defined
     *       locally on the node, if any.
     *    b. Update the global delimiter list index to consume a single entry
     *       for the current node.  This may skip array delimiter entries and
     *       push escape sequences.
     *    c. Push the selected delimiter for this field.
     *
     * 3. Scan for delimiter.
     *    NYI: We now assume non-match means no delim found; DelimStack
     *    also supports case where we need more input data past partial buffer
     *    end to decide; needed for streaming.
     *
     * 4. Register the field.
     *    a. Create a mapping item with the offset and length of the matched
     *       region preceding the delimiter.
     *    b. Increment the input offset past the field.
     *
     * 5. Handle the delimiter.
     *    a. If no delim found, or delim is not field's own delim (so it was
     *       pushed by an ancestor), then enter end-of-parent state, and
     *       pass back the delimiter that terminated the field.
     *    b. Else consume the delimiter: increment input offset with delimiter
     *       length.
     *
     * 6. Restore the delimiter state.
     *
     * On match, advance mPos past the field data and the following local
     * delimiter (if it belongs to the node itself), and update the match map.
     * On return, set mDone=true if we found end-of-data or a parent delimiter.
     * For optional fields, a non-match due to input data also qualifies
     * as a match.
     *
     * @param node  the node descriptor
     * @param required  if true, match failure is an error
     * @param delimLevel  current level in delimiter list
     * @param stack  the current delimiter stack state
     * @param count  number of occurrences seen so far
     * @return -1 on match failure, else number of matched occurrences
     */
    private int parseDelimitedLeaf(Node node, boolean required,
        DelimLevel delimLevel, DelimStack delimStack, int count) {
        if (mLog.isLoggable(Level.FINE)) {
            String msg = "Parse delimited leaf field '" + node.mName + "', required=" + required + ", count=" + count;
            if (mLog.isLoggable(Level.FINER)) {
                mLog.finer(msg + "," + LN + " node=[" + node + "]," + LN + " delimLevel=[" + delimLevel + "]," + LN + " delimStack=[" + delimStack + "].");
            } else {
                mLog.fine(msg + ".");
            }
        }
        if (node.mDelimLevel != null) {
            if (mLog.isLoggable(Level.FINE)) {
                String msg = "Leaf node '" + node.mName + "' has its own local delimiter taking precedence";
                if (mLog.isLoggable(Level.FINEST)) {
                    mLog.finest(msg + "," + LN + " local delimLevel=[" + node.mDelimLevel + "]" + LN + " overrides inherited delimLevel=[" + delimLevel + "].");
                } else {
                    mLog.fine(msg + ".");
                }
            }
            delimLevel = node.mDelimLevel;
        }
        if (mDone) {
            if (mLog.isLoggable(Level.FINE)) {
                mLog.fine("Parent delimiter already reached.");
            }
            if (node.mIsOptional && !delimLevel.isExplicit()) {
                return 0;
            }
            if (required) {
                fail(node, "End of parent.");
            }
            return -1;
        }
        if (delimLevel == null) {
            /* No delimiter at this level, so we can't parse delimited node.
             * This always fails the match, even for an optional node.
             */
            if (mLog.isLoggable(Level.FINE)) {
                mLog.fine("No delimiter defined.");
            }
            if (required) {
                fail(node, "No delimiter defined.");
            }
            return -1;
        }
        if (delimStack == null) {
            throw new NullPointerException("No delimiter stack.");
        }
        delimStack = mOtdDelimInst.push(delimStack, delimLevel, node.mIsRepeatable);
        /*-
        System.out.println("[ - match stack: ].");
        stack.print(System.out);
        -*/
        String reason = null;
        Delim delim = null;
        int oldCount = count;
        int pos = -1;
occurLoop:
        do {
            // Handle one repetition occurrence.
            if (count == node.mMaxOccurs) {
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("Reached maximum occurrences.");
                }
                if (node.mType != Type.ARRAY) {
                    break occurLoop;
                }
                // skip all array fields
                while ((delim = delimStack.scan(mData, mPos, mEnd, this)) != null
                        && delimLevel.contains(delim)
                        && delim.mType == Delim.Type.REPEAT) {
                    mPos = mMatchPos;
                    if (mIsBeginDelimMatched) {
                        mPos += (delim.isBeginDelimEmbedded()
                            ? mOtdDelimInst.getOtdDelim().mSlots[delim.mBeginSlotIndex].mLength
                            : mLastDelim.mBeginDelim.length);
                    } else {
                        mPos += (delim.isEmbedded()
                            ? mOtdDelimInst.getOtdDelim().mSlots[delim.mSlotIndex].mLength
                            : mLastDelim.mBytes.length);
                    }
                }
                mLastDelim = delim;
                if (mLastDelim != null) {
                    mPos = mMatchPos;
                    if (!mIsBeginDelimMatched) {
                        mPos += (mLastDelim.isEmbedded()
                            ? mOtdDelimInst.getOtdDelim().mSlots[mLastDelim.mSlotIndex].mLength
                            : mLastDelim.mBytes.length);
                    }
                    mDone = !delimLevel.contains(mLastDelim);
                } else {
                    mPos = mEnd;
                    mDone = true;
                }
                break occurLoop;
            } // end-- if (count == node.mMaxOccurs)

            pos = mPos;
            boolean isDelimLocal = true;
            delim = delimStack.scan(mData, mPos, mEnd, this);

            if (delim == null) {
                // i.e. No delimiter found.
                if (delimLevel.mMustBegin && mPos != mEnd) {
                    //reason = "Missing begin delimiter"; break;
                    fail(node, "Missing begin delimiter. No Delimiter found.");
                }
                // NYI: For streaming, fetch more data here; now, assume EOF.
                if (delimLevel.isTerminal()) {
                    if (count >= node.mMinOccurs && mMatchPos == mEnd) {
                        // IN=114677 Open-ESB-Issue-700
                        // i.e. repeating node already got min matched count and
                        // has searched all the way to data end but not found
                        // the required terminator -- this is ok.
                        break occurLoop;
                    } else {
                        //break;
                        //Fail the parse, make terminator rule more strict
                        fail(node, "Missing terminator. No Delimiter found.");
                    }
                } //end-- if (delimLevel.isTerminal())
                // now check on match with alignment.
                if (node.mMatch != null && node.mAlign != Align.BLIND) {
                    reason = checkByteSeq(node.mAlign, node.mMatch,
                        node.mPattern, mPos, mEnd, node.mIsNoMatch);
                    if (reason != null) {
                        // i.e. failed match pattern.
                        break occurLoop;
                    }
                }
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("No delimiter, so match to EOD.");
                }
                mDone = true;
                // register this field
                int rpIdx = (node.mIsRepeatable ? count : -1);
                mMatch.field(node.mChildIndex, rpIdx, mDataStartPos, mDataLength);
                //mMatch.field(node.mChildIndex, rpIdx, mPos, (mEnd - mPos));
                         // (childIndex, repIndex, offset, length)
                mPos = mEnd;
                mLastDelim = null;
                count++;
                break occurLoop;
            } // end-- if (delim == null)

            // if reach here, means a delimiter is found, assign to mLastDelim
            mLastDelim = delim;
            isDelimLocal = delimLevel.contains(mLastDelim);
            if (mLog.isLoggable(Level.FINEST)) {
                mLog.finest("isDelimLocal=" + isDelimLocal + " because delimLevel=[" + delimLevel + "]" + LN + " contains delim=[" + mLastDelim + "].");
            }
            if (delimLevel.mustBegin() && !mIsBeginDelimMatched && isDelimLocal) {
                // open-esb issue 1315
                reason = "Missing begin delimiter";
                break;
                // fail(node, "Missing begin delimiter. Wrong delimiter.");
            }
            if (mIsBeginDelimMatched && isDelimLocal) {
                if (delim.mIsBeginDelimAnchored && mPos != mMatchPos) {
                    if (mLog.isLoggable(Level.FINE)) {
                        mLog.fine("Begin delimiter not anchored.  currPos=" + mPos + ", matchPos=" + mMatchPos);
                    }
                    if (node.mScavengerBytes == null ||
                        !isSkippable(mPos, mMatchPos, node.mScavengerIndex)) {
                        //reason = "Begin delimiter not anchored"; break;
                        fail(node, "Begin delimiter not anchored.");
                    }
                }
                // consume the begin delimiter
                mPos = mDataStartPos;
                //save the position
                int posSave = mPos;
                // Find the matching end delimiter in following for loop
                for (;;) {
                    delim = delimStack.scan(mData, mPos, mEnd, this);
                    if (delim == null) {
                        // NYI: For streaming, fetch more data here; now, assume EOF.
                        if (mLastDelim.isForceTerm()) {
                            //break;
                            //Fail the parse, make terminator rule more strict
                            fail(node, "Missing terminator. No delimiter found.");
                        }
                        // now check on match with alignment.
                        if (node.mMatch != null && node.mAlign != Align.BLIND) {
                            reason = checkByteSeq(node.mAlign, node.mMatch,
                                node.mPattern, mPos, mEnd, node.mIsNoMatch);
                            if (reason != null) {
                                // i.e. Failed match pattern.
                                break occurLoop;
                            }
                        }
                        if (mLog.isLoggable(Level.FINE)) {
                            mLog.fine("No delimiter, so match to EOD.");
                        }
                        mDone = true;
                        int rpIdx = (node.mIsRepeatable ? count : -1);
                        mMatch.field(node.mChildIndex, rpIdx, mPos, (mEnd - mPos));
                                 // (childIndex, repIndex, offset, length)
                        mPos = mEnd;
                        mLastDelim = null;
                        count++;
                        break occurLoop;
                    }
                    isDelimLocal = delimLevel.contains(delim);
                    if ((mLastDelim == delim
                            && (!mIsBeginDelimMatched || hasSameBeginEndBytes(delim)))
                        || (!mLastDelim.isForceTerm() && !isDelimLocal)) {
                        //not local or it is the end delimiter that matches
                        //the current open begin delimiter
                        mPos = posSave;
                        mDataStartPos = mPos;
                        if (mLastDelim == delim) {
                            mIsBeginDelimMatched = false;
                            mDataLength = mMatchPos - mPos;
                        }
                        mLastDelim = delim;
                        break;
                    }
                    if (!mIsBeginDelimMatched) {
                        mPos += (delim.isEmbedded()
                            ? mOtdDelimInst.getOtdDelim().mSlots[delim.mSlotIndex].mLength
                            : delim.mBytes.length);
                    } else {
                        mPos += (delim.isEmbedded()
                            ? mOtdDelimInst.getOtdDelim().mSlots[delim.mBeginSlotIndex].mLength
                            : delim.mBeginDelim.length);
                    }
                } // end for (;;)
            } // end if (mIsBeginDelimMatched && isDelimLocal)

            if ((!isDelimLocal || mIsBeginDelimMatched) && delimLevel.isTerminal()) {
                //break;
                //Fail the parse, make terminator rule more strict
                fail(node, "Missing local terminator. Hit parent delimiter.");
            }
            if (mLog.isLoggable(Level.FINE)) {
                mLog.fine("Parse delimited leaf node found delimiter=" + Misc.printable(mLastDelim.mBytes));
            }
            if (mIsBeginDelimMatched) {
                //The end delimiter is missing but it is allowed to be missing.
                mDataStartPos = mPos;
                mDataLength = mMatchPos - mPos;
            }
            if (node.mIsOptional && mDataLength == 0 &&
                (delimLevel.mPlainDelim != null
                    ? delimLevel.mPlainDelim.mOptMode != Delim.Mode.NEVER
                    : delim.mOptMode != Delim.Mode.NEVER)) {
                // The field contains no data, but a delimiter is permitted or
                // required here for an optional field, so treat as absent.
                if (isDelimLocal && !mIsBeginDelimMatched) {
                    // Delimiter belongs to this level, consume it.
                    mPos = mMatchPos + (mLastDelim.isEmbedded()
                        ? mOtdDelimInst.getOtdDelim().mSlots[mLastDelim.mSlotIndex].mLength
                        : mLastDelim.mBytes.length);
                }
                // Set done if this delimiter is not local
                mDone = !isDelimLocal;
                break occurLoop;
            }
            // now check on match with alignment.
            if (node.mMatch != null && node.mAlign != Align.BLIND) {
                reason = checkByteSeq(node.mAlign, node.mMatch, node.mPattern,
                    mDataStartPos, mDataStartPos + mDataLength, node.mIsNoMatch);
                if (reason != null) {
                    // i.e. Failed match pattern.
                    mLastDelim = null;
                    mPos = pos;
                    break occurLoop;
                }
            }
            // register this field
            int rpIdx = (node.mIsRepeatable ? count : -1);
            mMatch.field(node.mChildIndex, rpIdx, mDataStartPos, mDataLength);
                     // (childIndex, repIndex, offset, length)
            count++;
            if (mLog.isLoggable(Level.FINE)) {
                mLog.fine("Matched data from " + mPos + " to " + mMatchPos + "=\"" + Misc.showFragment(mData, mPos, mMatchPos, false) + "\".");
            }
            mPos = mMatchPos;

            if (!isDelimLocal) {
                // Delimiter belongs to ancestor, leave it.
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("Keep non-local delimiter=" + Misc.printable(mLastDelim.mBytes) + " and set done=true");
                }
                mDone = true;
                break; // break loop- while(node.mIsRepeatable && !mDone)
            }
            // Delimiter belongs to node itself, not belong to parent; skip it.
            if (mLog.isLoggable(Level.FINE)) {
                mLog.fine("Consume local delimiter=" + Misc.printable(mLastDelim.mBytes));
            }
            mPos += (mLastDelim.isEmbedded()
                ? mOtdDelimInst.getOtdDelim().mSlots[mLastDelim.mSlotIndex].mLength
                : mLastDelim.mBytes.length);
            if (node.mType == Node.Type.ARRAY
                && mLastDelim.mType == Delim.Type.NORMAL) {
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("Non-array normal delimiter ends array node.");
                }
                break;
            }
        } while (node.mIsRepeatable && !mDone);

        mReason = reason;
        return (count - oldCount);
    }

    /**
     * Parses a fixed length field.
     *
     * 1. If we are in end-of-parent state, fail the match.
     *
     * 2. If length is known and less available, fail the match.
     *
     * 3. Update the delimiter state.
     *    a. Replace the global delimiter list by the one defined locally
     *       on the node, if any.
     *    b. Hide all delimiters on the stack with precedence below
     *       FIXED_FIELD_PRECEDENCE.
     *    c. If length is known, adjust end of data limit.
     * NYI: push escape delims for fixed fields as well?
     *
     * 3. Scan for delimiter.
     *    If found, then we have insufficient data, so fail the match.
     *
     * 4. Register the field.
     *    a. Create a mapping item with the offset and length of the matched
     *       region.
     *    b. Increment the input offset past the field.
     *
     * 6. Restore the delimiter state.
     *
     * On match, advance mPos past the field data, and update the match map.
     * On return, set mDone=true if we found end-of-data.
     *
     * @param node  the node descriptor
     * @param required  if true, match failure is an error
     * @param delimLevel  current level in delimiter list
     * @param delimStack  the current delimiter stack state
     * @param count  number of occurrences seen so far
     * @param startOfOffset starting position for applying offset. Basically
     *                      it is the start position of the parent node.
     * @return -1 on match failure, else number of matched occurrences
     */
    private int parseFixed(Node node, boolean required,
        DelimLevel delimLevel, DelimStack delimStack, int count,
        int startOfOffset) {
        if (node == null) {
            throw new NullPointerException("No fixed node to parse.");
        }
        if (mLog.isLoggable(Level.FINE)) {
            String msg = "Parse fixed node '" + node.mName + "', required=" + required + ", count=" + count + ",  startOfOffset=" + startOfOffset;
            if (mLog.isLoggable(Level.FINER)) {
                mLog.finer(msg + "," + LN + " node=[" + node + "]," + LN + " delimLevel=[" + delimLevel + "]," + LN + " delimStack=[" + delimStack + "].");
            } else {
                mLog.fine(msg + ".");
            }
        }
        String reason = null;
        int oldCount = count;
        //boolean might = (required && !node.mIsOptional /*&& !node.mIsRepeatable*/);
occurLoop:
        do {
            // Handle one repetition occurrence.
            if (count == node.mMaxOccurs) {
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("Reached max occurs.");
                }
                break occurLoop;
            }
            if (mDone) {
                // Parent delimiter already reached.
                reason = "Parent delimiter already reached.";
                break;
            }
            int restorepos = mPos;
            int len = node.mLength;
            if (node.mPosition >= 0) {
                // i.e. encoded length
                StringCoder coder = mNodes.getDecoder();
                int from = mPos + node.mPosition;
                String s = coder.decode(mData, from, node.mLength);
                try {
                    len = Integer.parseInt(s);
                } catch (NumberFormatException e) {
                    fail(node, "Unable to parse encoded length.");
                }
            }
            if (node.mOffset >= 0) {
                mPos = startOfOffset + node.mOffset;
            }
            if (node.mDelimForFixedLen != null) {
                byte[] bytes = node.mDelimForFixedLen.mBeginBytes;
                int matchpos = indexOf(bytes,
                        node.mDelimForFixedLen.mIsBeginBytesAnchored, mEnd);
                if (matchpos >= 0) {
                    mPos = matchpos + bytes.length;
                } else if (required && count < node.mMinOccurs){
                    fail(node, "Begin delimiter not found");
                } else {
                    mPos = restorepos;
                    break occurLoop;
                }
            }
            int newEnd;
            if (len > 0) {
                newEnd = mPos + len;
                if (newEnd > mEnd) {
                    // Not enough data for this node.
                    reason = "Insufficient data for fixed field";
                    break;
                }
            } else if (len < 0) {
                //Count from the end of the data
                newEnd = mData.length + len;
                if (mEnd < newEnd) {
                    // Not enough data for this node.
                    reason = "Insufficient data for fixed field";
                    break;
                }
            } else {
                newEnd = mEnd;
            }
            int pos = mPos;
            delimStack = mOtdDelimInst.hide(delimStack,
                OtdDelim.FIXED_FIELD_PRECEDENCE);
            if (!node.isLeaf()) {
                // Parent node.
                int oldEnd = mEnd;
                mEnd = newEnd;
                int rpIdx = (node.mIsRepeatable ? count : -1);
                int enterItemIndex = mMatch.enter(node.mChildIndex, rpIdx, mPos);
                                              // (childIndex, repIndex, pos)
                int numFoundOccu = 0;
                for (int i = 0; i < node.mSubnodes.length; i++) {
                    // Parse each child.  They return info in mDone, mLastDelim.
                    Node subNode = mNodes.get(node.mSubnodes[i]);
                    boolean rqrd = required && (count < node.mMinOccurs || numFoundOccu != 0);
                    boolean lastChild = (node.mSubnodes.length > 1)
                        && (i == node.mSubnodes.length - 1);
                    int matchedSubCnt = handleNode(subNode, rqrd, delimLevel,
                        delimStack, 0, true, pos, lastChild);
                    // (node, required, delimLevel, delimStack, count, ordered, startOfOffset, lastChild)

                    if (matchedSubCnt < 0) {
                        // Wipe the map.
                        if (mLog.isLoggable(Level.FINE)) {
                            mLog.fine("Failed child node=" + i + ": reset enterItemIndex=" + enterItemIndex + ", currPos=" + pos + ".");
                        }
                        mMatch.reset(enterItemIndex);
                        mPos = restorepos;
                        mDone = false;
                        mEnd = oldEnd;
                        break occurLoop;
                    }
                    if (matchedSubCnt != 0) {
                        numFoundOccu++;
                    }
                }
                mEnd = oldEnd;
                if (node.mIsRepeatable && pos == mPos) {
                    // Repetition terminates on empty (0-byte) match.
                    reason = "Empty repetition occurrence";
                    mMatch.reset(enterItemIndex);
                    mDone = false;
                    break occurLoop;
                }
                if (len != 0 && mPos != newEnd) {
                    // Data left over after last child.
                    /* NYI: should maybe scan for ancestor delimiter; if found
                     * at mPos and mLength=0 then set mDone=true, and match okay. */
                    if (mNodes.getUndefDataPolicy() == UndefDataPolicy.PROHIBIT) {
                        reason = "Trailing junk in fixed/parent";
                        mMatch.reset(enterItemIndex);
                        mPos = restorepos;
                        mDone = false;
                        break occurLoop;
                    }
                    mMatch.field(-1, -1, mPos, (newEnd - mPos));
                             // (childIndex, repIndex, offset, length)
                    mPos = newEnd;
                }
                // Occurrence okay.
                mMatch.leave(enterItemIndex);
                //Check the children occurrences before counting the match.
                if (node.mMinNOfChildren >= 0
                    && numFoundOccu < node.mMinNOfChildren) {
                    fail(node, "At least minNOfN=" + node.mMinNOfChildren
                        + " children should present");
                }
                if (node.mMaxNOfChildren >= 0
                    && numFoundOccu > node.mMaxNOfChildren) {
                    fail(node, "At most maxNOfN=" + node.mMinNOfChildren
                        + " children can present");
                }
                count++;

                // Set done to true if we are at EOD
                mDone = (mPos == mEnd);
            } else {
                // Should be a leaf node now.
                Delim delim = delimStack.scan(mData, mPos, newEnd, this);
                if (delim == null) {
                    // No delimiter found. Good (because of fixed-len field).
                    if (node.mMatch != null && node.mAlign != Align.BLIND) {
                        if (len == 0 && node.mAlign == Align.REGEX) {
                            matchRegex(node.mPattern, mPos, newEnd, this);
                            newEnd = mMatchPos;
                        } else {
                            reason = checkByteSeq(node.mAlign, node.mMatch,
                                node.mPattern, mPos, newEnd, node.mIsNoMatch);
                            if (reason != null) {
                                mPos = restorepos;
                                break occurLoop;
                            }
                        }
                    }
                    mDone = (newEnd == mEnd);
                    mLastDelim = null;
                } else { // i.e. delim != null
                    // Delimiter found.  Bad if length was known.
                    if (len != 0) {
                        reason = "Fixed field cut off by ancestor delimiter";
                        break;
                    }
                    // i.e. length == 0, means undefined
                    newEnd = mMatchPos;
                    if (node.mAlign == Align.REGEX) {
                        matchRegex(node.mPattern, mPos, mMatchPos, this);
                        mDone = (newEnd == mMatchPos);
                        newEnd = mMatchPos;
                        mLastDelim = mDone ? delim : null;
                    } else {
                        mDone = true;
                        mLastDelim = delim;
                        reason = checkByteSeq(node.mAlign, node.mMatch,
                            node.mPattern, mPos, newEnd, node.mIsNoMatch);
                        if (reason != null) {
                            mPos = restorepos;
                            break occurLoop;
                        }
                    }
                }
                // Leaf match okay.
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("Matched data from " + mPos + " to " + newEnd + "=\"" + Misc.showFragment(mData, mPos, newEnd, false) + "\".");
                }
                int rpIdx = node.mIsRepeatable ? count : -1;
                mMatch.field(node.mChildIndex, rpIdx, mPos, (newEnd - mPos));
                         // (childIndex, repIndex, offset, length)
                count++;
                mPos = newEnd;
            }
        } while (node.mIsRepeatable && !mDone);

        mReason = reason;
        return count - oldCount;
    }

    /**
     * Parses a delimited group field.
     *
     * 1. If we are in end-of-parent state, fail the match.
     *
     * 2. Update the delimiter state.
     *    a. Replace the global delimiter list by the one defined locally
     *       on the node, if any.
     *    b. Update the global delimiter list index to consume a single entry
     *       for the current node.  This may skip array delimiter entries and
     *       push escape sequences.
     *    c. Push the selected delimiter for this field.
     *
     * 3. Register the entry into the field; remember the enter item index.
     *
     * 4. Parse all of the children.
     *    a. If any child fails, fail the match.
     *    b. If the state is not end-of-parent after the last child, fail match.
     *
     * 4. Register leaving the field, using the enter item index.
     *
     * 5. Handle the delimiter.
     *    a. If no delim found, or delim is not field's own delim (so it was
     *       pushed by an ancestor), then enter end-of-parent state, and
     *       pass back the delimiter that terminated the field.
     *    b. Else consume the delimiter: increment input offset with delimiter
     *       length.
     *
     * 6. Restore the delimiter state.
     *
     * On match, advance mPos past the field data and the following local
     * delimiter (if it belongs to the node itself), and update the match map.
     * On return, set mDone=true if we found end-of-data or a parent delimiter.
     *
     * @param node  the node descriptor
     * @param required  if true, match failure is an error
     * @param delimLevel  current level in delimiter list
     * @param stack  the current delimiter stack state
     * @param count  number of occurrences seen so far
     * @return -1 on match failure, else number of matched occurrences
     */
    private int parseDelimitedGroup(Node node, boolean required,
        DelimLevel delimLevel, DelimStack delimStack, int count, boolean lastChild) {
        if (mLog.isLoggable(Level.FINE)) {
            String msg = "Parse delimited group node '" + node.mName + "', required=" + required + ", count=" + count;
            if (mLog.isLoggable(Level.FINER)) {
                mLog.finer(msg + "," + LN + " node=[" + node + "]," + LN + " delimLevel=[" + delimLevel + "]," + LN + " delimStack=[" + delimStack + "].");
            } else {
                mLog.fine(msg + ".");
            }
        }
        if (node.isLeaf()) {
            throw new IllegalArgumentException("Found leaf not group node.");
        }
        if (mDone) {
            // Parent delimiter already reached.
            if (mLog.isLoggable(Level.FINE)) {
                mLog.fine("End of parent. Parent delimiter already reached.");
            }
            if (node.mIsOptional /*|| node.mIsRepeatable*/) {
                return 0;
            }
            if (required) {
                fail(node, "End of parent. Parent delimiter already reached.");
            }
            return -1;
        }
        if (node.mDelimLevel != null) {
            if (mLog.isLoggable(Level.FINE)) {
                String msg = "Group node '" + node.mName + "' has its own local delimiter taking precedence";
                if (mLog.isLoggable(Level.FINEST)) {
                    mLog.finest(msg + "," + LN + " local delimLevel=[" + node.mDelimLevel + "]" + LN + " overrides inherited delimLevel=[" + delimLevel + "].");
                } else {
                    mLog.fine(msg + ".");
                }
            }
            delimLevel = node.mDelimLevel;
        }
        if (delimLevel == null) {
            // No delimiter at this level, so can't do delimited node.
            if (mLog.isLoggable(Level.FINE)) {
                mLog.fine("No delimiter defined.");
            }
            if (required) {
                fail(node, "No delimiter defined.");
            }
            return -1;
        }
        /*-
        System.out.println("[ - match stack: ].");
        stack.print(System.out);
        -*/
        if (node.mSubnodes.length == 0) {
            throw new RuntimeException("Group node but childless.");
        }
        delimStack = mOtdDelimInst.push(delimStack, delimLevel,
            node.mIsRepeatable);
        Delim delim;
        String reason = null;
        int oldCount = count;
        //boolean might = (required && !node.mIsOptional /*&& !node.mIsRepeatable*/);
occurLoop:
        do {
            // Handle one repetition occurrence.
            if (count == node.mMaxOccurs) {
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("Already reached maximum occurs=" + count);
                }
                if (node.mType != Node.Type.ARRAY) {
                    break occurLoop;
                }
                // skip all array fields
                while ((delim = delimStack.scan(mData, mPos, mEnd, this)) != null
                    && delimLevel.contains(delim)
                    && delim.mType == Delim.Type.REPEAT) {
                    mPos = mMatchPos;
                    if (mIsBeginDelimMatched) {
                        mPos += (delim.isBeginDelimEmbedded()
                            ? mOtdDelimInst.getOtdDelim().mSlots[delim.mBeginSlotIndex].mLength
                            : mLastDelim.mBeginDelim.length);
                    } else {
                        mPos += (delim.isEmbedded()
                            ? mOtdDelimInst.getOtdDelim().mSlots[delim.mSlotIndex].mLength
                            : mLastDelim.mBytes.length);
                    }
                }
                mLastDelim = delim;
                if (mLastDelim != null) {
                    mPos = mMatchPos;
                    if (!mIsBeginDelimMatched) {
                        mPos += (mLastDelim.isEmbedded()
                            ? mOtdDelimInst.getOtdDelim().mSlots[mLastDelim.mSlotIndex].mLength
                            : mLastDelim.mBytes.length);
                    }
                    mDone = !delimLevel.contains(mLastDelim);
                } else {
                    mPos = mEnd;
                    mDone = true;
                }
                break occurLoop;
            }
            // register enter item
            int pos = mPos;
            int rpIdx = (node.mIsRepeatable ? count : -1);
            int enterItemIndex = mMatch.enter(node.mChildIndex, rpIdx, pos);
                                          // (childIndex, repIndex, pos)
            if (delimLevel.hasBegin()) {
                delim = delimStack.scan(mData, mPos, mEnd, mLookaheadPos);
                if (delim != null && mLookaheadPos.mIsBeginDelimMatched) {
                    //Consume the begin delimiter
                    if (delim.mIsBeginDelimAnchored && mPos != mLookaheadPos.mMatchPos) {
                        if (mLog.isLoggable(Level.FINE)) {
                            mLog.fine("Begin delimiter not anchored. currPos=" + mPos + ", matchPos=" + mLookaheadPos.mMatchPos);
                        }
                        if (node.mScavengerBytes == null || !isSkippable(mPos,
                            mLookaheadPos.mMatchPos, node.mScavengerIndex)) {
                            //reason = "Begin delimiter not anchored";
                            //break;
                            fail(node, "Begin delimiter not anchored.");
                        }
                    }
                    mPos = mLookaheadPos.mDataStartPos;
                }
            //If the matched delimiter is an end delimiter, don't do anything,
            //so successive child matching will still start at current mPos.
            }
            boolean hasDelimChild = false;
            int foundSubCount = 0;
            for (int i = 0; i < node.mSubnodes.length; i++) {
                // Parse each delimited child. They return info in mDone, mLastDelim.
                Node childNode = mNodes.get(node.mSubnodes[i]);
                hasDelimChild |= (childNode.isArray() || childNode.isDelim());
                // IN=114577 Open-ESB-Issue-697
                if (foundSubCount > 0 && mDone && mPos == mEnd && i > 0
                    && (!childNode.mIsOptional || childNode.mMinOccurs > 0)
                    && !childNode.isTrans()) {
                    mMatch.reset(enterItemIndex);
                    mPos = pos;
                    mDone = false;
                    break occurLoop;
                }
                // prepare to invoke handleNode() on this child node
                boolean rqrd =  required
                    /** Open-ESB-Issue-717
                     && (count < node.mMinOccurs || foundSubCount > 0); */
                    && (count < node.mMinOccurs)
                    && node.mMinOccurs > 0
                    && !childNode.mIsOptional;
                boolean lastChild_ = (node.mSubnodes.length > 1)
                    && (i == node.mSubnodes.length - 1);
                int matchedSubCount = handleNode(childNode, rqrd,
                    delimLevel.mNextDelimLevel, delimStack, 0, true, pos, lastChild_);
                // (node, required, delimLevel, delimStack, count, ordered, startOfOffset, lastChild)

                if (matchedSubCount > 0) {
                    foundSubCount++;
                } else if (matchedSubCount < 0) {
                    // No match found, so wipe the map.
                    if (mLog.isLoggable(Level.FINE)) {
                        mLog.fine("Failed to match child #" + i + ". Reset map from enter item with index=" + enterItemIndex + ", pos=" + pos + ".");
                    }
                    mMatch.reset(enterItemIndex);
                    mPos = pos;
                    mDone = false;
                    // Check for en-lieu delimiter for absent node.
                    // NYI: should we move this down to if-hasDelimChild?
                    if (node.mIsOptional && !node.mIsRepeatable) {
                        // i.e. single optional group node
                        delim = delimStack.scan(mData, mPos, mEnd, this);
                        if (delim != null && mDataLength == 0
                            && delimLevel.contains(delim)
                            && delim.mOptMode != Delim.Mode.NEVER) {
                            // Consume delimiter.
                            if (mLog.isLoggable(Level.FINE)) {
                                mLog.fine("Consume absent-option delimiter.");
                            }
                            if (delim.isEmbedded()) {
                                mPos = mMatchPos + mOtdDelimInst.getOtdDelim()
                                    .mSlots[delim.mSlotIndex].mLength;
                            } else {
                                mPos = mMatchPos + delim.mBytes.length;
                            }
                            mLastDelim = null;
                        }
                    }
                    break occurLoop;
                } // end-- else if (subCount < 0)
            }
            if (!mDone) {
                /* i.e. Did not find end of input or parent delimiter.
                 * This can validly be the case if all children were fixed
                 * length nodes, so they did not scan for delimiters; Or matched
                 * child was found
                 */
                if (pos == mPos) {
                    // if mPos didn't move at all, it must be that there is no
                    // matched child at all.
                    mMatch.reset(enterItemIndex);
                    break occurLoop;
                }
                if (hasDelimChild && mLastDelim != null
                    && mLastDelim.mTermMode.compareTo(Delim.Mode.NEVER) <= 0
                    && mNodes.getUndefDataPolicy() == UndefDataPolicy.PROHIBIT) {
                    if (mLog.isLoggable(Level.FINE)) {
                        mLog.fine("No EOD or parent delim, stop.");
                    }
                    mMatch.reset(enterItemIndex);
                    mPos = pos;
                    reason = "Trailing data after last child";
                    break occurLoop;
                }
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("Retry parent delimiter.");
                }
                delim = null;
                if (mPos != mEnd
                    && ((delim = delimStack.scan(mData, mPos, mEnd, this)) == null
                        || (mDataLength > 0 && delim.mEndDelimAnchored
                            && (node.mScavengerBytes == null
                                || !isSkippable(mPos, mMatchPos, node.mScavengerIndex))))) {
                    // i.e. No delimiter at all, or shoot too far (delimiter is
                    // not anchored at the current position if the delimiter is
                    // required to be anchored, and the skipped data is not
                    // skippable)
                    switch (mNodes.getUndefDataPolicy()) {
                        case PROHIBIT:
                            mMatch.reset(enterItemIndex);
                            mPos = pos;
                            if (mLog.isLoggable(Level.FINE)) {
                                StringBuffer buf = new StringBuffer();
                                buf.append("Retry parent delimiter failed: ");
                                if (delim != null) {
                                    buf.append("overshoot, del=" + mMatchPos);
                                } else {
                                    buf.append("no delimiter");
                                }
                                buf.append(", currPos=").append(mPos);
                                mLog.fine(buf.toString());
                            }
                            reason = "Trailing junk after last child";
                            break occurLoop;
                        case MAP:
                            int len = (delim != null) ? (mMatchPos - mPos) : (mEnd - mPos);
                            mMatch.field(-1, -1, mPos, len);
                                     // (childIndex, repIndex, offset, length)
                            break;
                        case SKIP:
                            break;
                        default:
                            throw new IllegalArgumentException(
                                "Unknown policy: " + mNodes.getUndefDataPolicy());
                    }
                }
                mLastDelim = delim;
            }
            boolean isDelimLocal = (mLastDelim != null
                && delimLevel.contains(mLastDelim));
            if (delimLevel.isTerminal() && !isDelimLocal) {
                // Node requires its own local delimiter as terminator, but it's
                // absent now, then reset the match.
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("No delim, missing terminator.");
                }
                mMatch.reset(enterItemIndex);
                reason = "Missing terminator";
                mDone = true;
                break occurLoop;
            }

            // if this delimited group node is optional with no data found,
            // and delimiter's optionality is not NEVER, then reset the match.
            if ((node.mIsOptional /*|| node.mIsRepeatable*/) &&
                (mLastDelim != null) &&
                (mLastDelim.mOptMode.compareTo(Delim.Mode.NEVER) > 0) &&
                (pos == mPos)) {
                mMatch.reset(enterItemIndex);
            /* } else if ((mLastDelim != null) &&
                (mLastDelim.mOptMode.compareTo(Delim.Mode.NEVER) == 0) &&
                lastChild) {
                fail(node, "Terminator=" + Misc.printable(mLastDelim.mBytes)
                    + " can not be present at last element."); */
            } else {
                mMatch.leave(enterItemIndex);
                // Check the children occurrences before counting the match.
                if (node.mMinNOfChildren >= 0
                    && foundSubCount < node.mMinNOfChildren) {
                    fail(node, "At least " + node.mMinNOfChildren
                        + " children should present, but found: " + foundSubCount);
                }
                if (node.mMaxNOfChildren >= 0
                    && foundSubCount > node.mMaxNOfChildren) {
                    fail(node, "At most " + node.mMinNOfChildren
                        + " children can present, but found: " + foundSubCount);
                }
                count++;
            }

            /* check if a local terminator (which should not occur since its
               terminator mode is NEVER) is present as last child, open-esb Issue 1522 */
            if (mLastDelim != null && isDelimLocal && lastChild
                && !node.mIsRepeatable
                && (mLastDelim.mTermMode == Delim.Mode.NEVER)
                && mNodes.getUndefDataPolicy() != UndefDataPolicy.MAP
                && mNodes.getUndefDataPolicy() != UndefDataPolicy.SKIP) {
                mAvoidedTerminator = mLastDelim;
            } else if (mAvoidedTerminator != null) {
                // clean it for next round of parsing on a delimited group
                mAvoidedTerminator = null;
            }
            if (mLastDelim != null) {
                // Delimiter found.
                // NYI for bug #8195: handle mLastDelim.mOptMode>NEVER...
                if (!isDelimLocal) {
                    // Delimiter belongs to ancestor, so leave it untouched.
                    mDone = true;
                    break occurLoop;
                } else {
                    // Delimiter belongs to node itself, not to parent; skip it.
                    if (mLog.isLoggable(Level.FINE)) {
                        mLog.fine("Consume last delimiter="
                            + Misc.printable(mLastDelim.mBytes));
                    }
                    //mPos += mLastDelim.mBytes.length;
                    if (mLastDelim.isEmbedded()) {
                        mPos = mMatchPos + mOtdDelimInst.getOtdDelim()
                            .mSlots[mLastDelim.mSlotIndex].mLength;
                    } else {
                        mPos = mMatchPos + mLastDelim.mBytes.length;
                    }
                    mDone = (mPos == mEnd);
                    Delim last = mLastDelim;
                    mLastDelim = null;
                    if (node.isArray() && last.mType == Delim.Type.NORMAL) {
                        break occurLoop;
                    }
                }
            /*-
            } else if (mPos == pos) {
                // Repetition is empty, terminate loop.
                if (logger.isLoggable(Level.FINE)) {
                    logger.log(Level.FINE, "Empty repetition, stop now.");
                }
                mDone = true;
                break occurLoop;
            -*/
            } else {
                // Must be at EOD.
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("End of data. Stop now");
                }
                mPos = mEnd;
                mDone = true;
                break occurLoop;
            }
        } while (node.mIsRepeatable);
        mReason = reason;
        return count - oldCount;
    }

    /**
     * Parses a group field.
     *
     * 1. If we are in end-of-parent state, fail the match.
     *
     * 2. Update the delimiter state.
     *    a. Replace the global delimiter list by the one defined locally
     *       on the node, if any.
     *
     * 3. Register the entry into the field; remember the enter item index.
     *
     * 4. Parse all of the children.
     *    a. If any child fails, fail the match.
     *    b. If the state is not end-of-parent after the last child, fail match.
     *
     * 4. Register leaving the field, using the enter item index.
     *
     * 5. Restore the delimiter state.
     *
     * On match, advance mPos past the field data, and update the match map.
     * On return, set mDone=true if we found end-of-data or a parent delimiter.
     *
     * @param node  the node descriptor
     * @param required  if true, match failure is an error
     * @param delimLevel  current level in delimiter list
     * @param delimStack  the current delimiter stack state
     * @param count  number of occurrences seen so far
     * @return -1 on match failure, else number of matched occurrences
     */
    private int parseGroup(Node node, boolean required,
        DelimLevel delimLevel, DelimStack delimStack, int count) {
        if (mLog.isLoggable(Level.FINE)) {
            String msg = "Parse group node '" + node.mName + "', required=" + required + ", count=" + count;
            if (mLog.isLoggable(Level.FINER)) {
                mLog.finer(msg + "," + LN + " node=[" + node + "]," + LN + " delimLevel=[" + delimLevel + "]," + LN + " delimStack=[" + delimStack + "].");
            } else {
                mLog.fine(msg + ".");
            }
        }
        if (node.isLeaf()) { // ensure that node is not a leaf field
            throw new IllegalArgumentException("Unexpected leaf node."); //I18N
        }
        if (mDone) {
            // Parent delimiter already reached.
            if (node.mIsOptional /*|| node.mIsRepeatable*/) {
                return 0;
            }
            if (required) {
                fail(node, "End of parent.");
            }
            return 0;
        }
        if (node.mDelimLevel != null) {
            // this Node's DelimLevel takes precedence
            delimLevel = node.mDelimLevel;
        }
        if (node.isLeaf() || node.mSubnodes.length == 0) {
            // a group without any child encountered. NYI...
            throw new RuntimeException("Childless group not supported yet."); //I18N
        }
        boolean ordered = (node.mOrder == Node.Order.SEQ);
        int previousCount = count;
        //boolean might = (required && !node.mIsOptional /*&& !node.mIsRepeatable*/);
occurLoop:
        do {
            // Handle one repetition occurrence.
            if (count == node.mMaxOccurs) {
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("Reached node's max occurs.");
                }
                break occurLoop;
            }
            int pos = mPos;
            int repIndex_ = (node.mIsRepeatable ? count : -1);
            int enterItemIdx = mMatch.enter(node.mChildIndex, repIndex_, pos);
                                        // (childIndex, repIndex, pos)
            int foundKidsTypeCnt = 0;
            /* check on order:
             * if ordered, then order="sequence":
             *    Child nodes must appear in the sequence given in the metadata.
             * if not ordered, then order="any" or "mixed":
             *    "any": Child nodes must remain grouped, but the groups can appear in any order.
             *    "mixed": Child nodes can appear in any order. */
            if (ordered) {
                int matchedSubCount = -1;
                for (int i = 0; i < node.mSubnodes.length; i++) {
                    // Parse each child. They return info in mDone, mLastDelim.
                    Node subNode = mNodes.get(node.mSubnodes[i]);
                    boolean rqrd = required
                        && (count < node.mMinOccurs || foundKidsTypeCnt != 0);
                    boolean lastChild = (node.mSubnodes.length > 1)
                        && (i == node.mSubnodes.length - 1);
                    matchedSubCount = handleNode(subNode, rqrd, delimLevel,
                        delimStack, 0, ordered, pos, lastChild);
                    // (node, required, delimLevel, delimStack, count, ordered, startOfOffset, lastChild)

                    if (matchedSubCount < 0) {
                        // Wipe the map.
                        mMatch.reset(enterItemIdx);
                        mPos = pos;
                        mDone = false;
                        break occurLoop;
                    }
                    if (matchedSubCount != 0) {
                        foundKidsTypeCnt++;
                    }
                }
            } else {
                /* Parse all children, which may be out of order. We keep
                 * track of the complete children in the completed[] flag array.
                 * In occurs[] we remember how many occurrences of a repeated
                 * child we already have, to check against maxOcc.
                 * We try to parse each child in turn, unless already complete;
                 * if a full cycle did not match anything, we stop. */
                // incomplete children count
                int kids = node.mSubnodes.length;
                // last incomplete non-repeating mandatory child
                int badChildIdx = -1;
                boolean[] completed = new boolean[kids];
                int[] occurs = new int[kids];
                boolean go = true;
                for (; go;) {
                    go = false;
                    badChildIdx = -1;
                    for (int i = 0; i < node.mSubnodes.length; i++) {
                        if (!completed[i]) {
                            Node subNode = mNodes.get(node.mSubnodes[i]);
                            // Try to parse each child. They return info in mDone, mLastDelim.
                            boolean lastChild = (node.mSubnodes.length > 1)
                                && (i == node.mSubnodes.length - 1);
                            int matchedSubCount = handleNode(subNode, false,
                                delimLevel, delimStack, occurs[i], ordered, pos, lastChild);
                            // (node, required, delimLevel, delimStack, count, ordered, startOfOffset, lastChild)

                            if (matchedSubCount > 0) {
                                if (occurs[i] == 0) {
                                    foundKidsTypeCnt++;
                                }
                                occurs[i] += matchedSubCount;
                                go = true;
                                if (!subNode.mIsRepeatable ||
                                    occurs[i] == subNode.mMaxOccurs) {
                                    completed[i] = true;
                                }
                            } else if (occurs[i] < subNode.mMinOccurs /*&& !subNode.mIsRepeatable */) {
                                badChildIdx = i;
                                if (mLog.isLoggable(Level.FINER)) {
                                    mLog.finer("Incomplete child index=" + badChildIdx);
                                }
                            }
                        }
                    }
                }
                if (mLog.isLoggable(Level.FINE)) {
                    StringBuilder sb = new StringBuilder("Finished cycles, found kids type total=");
                    sb.append(foundKidsTypeCnt).append(", last incomplete child index=");
                    sb.append(badChildIdx).append(". Details: ");
                    for (int i = 0; i < node.mSubnodes.length; i++) {
                        sb.append("Child[").append(i).append("]: count=");
                        sb.append(occurs[i]).append(", completed=");
                        sb.append(completed[i]).append("; ");
                    }
                    mLog.fine(sb.toString());
                }
                if (badChildIdx >= 0) {
                    // Missing mandatory child, re-parse it in order to get
                    // detailed parse error message.
                    if (mLog.isLoggable(Level.FINE)) {
                        mLog.fine("Last incomplete child index=" + badChildIdx);
                    }
                    Node node_ = mNodes.get(node.mSubnodes[badChildIdx]);
                    boolean lastChild = false; //???
                    int matchedCount = handleNode(node_, true, delimLevel,
                        delimStack, occurs[badChildIdx], true, pos, lastChild);
                    /* node, required, delimLevel, delimStack, count, ordered, startOfOffset, lastChild */

                    if (matchedCount >= 0) {
                        // Re-parse should fail; if not, bummer.
                        throw new RuntimeException("Bug: re-parse okay!?");
                    }
                    // Wipe the map.
                    mMatch.reset(enterItemIdx);
                    mPos = pos;
                    mDone = false;
                    break occurLoop;
                }
            }

            if (node.mIsRepeatable && pos == mPos) {
                // Repetition terminates on empty (0-byte) match.
                mMatch.reset(enterItemIdx);
                mDone = false;
                break occurLoop;
            }

            mMatch.leave(enterItemIdx);
            // Check the children occurrences before counting the match.
            if (node.mMinNOfChildren >= 0
                && foundKidsTypeCnt < node.mMinNOfChildren) {
                fail(node, "At least minNOfN=" + node.mMinNOfChildren
                    + " children should present");
            }
            if (node.mMaxNOfChildren >= 0
                && foundKidsTypeCnt > node.mMaxNOfChildren) {
                fail(node, "At most maxNOfN=" + node.mMinNOfChildren
                    + " children can present");
            }
            count++;
        } while (node.mIsRepeatable && (mPos < mEnd));
        /* } while (node.mIsRepeatable); IN=114435 Open-ESB-Issue-727 */
        //- mReason = reason;

        // check if forbidden trailing terminator found, open-esb Issue 1522
        if (mAvoidedTerminator != null) {
            fail(node, "Terminator=" + Misc.printable(mAvoidedTerminator.mBytes)
                + " can not be present at end of last element.");
        }
        return (count - previousCount);
    }

    /**
     * Parses a choice node.  This will match only one child.
     *
     * 1. If we are in end-of-parent state, fail the match.
     *
     * 2. Update the delimiter state.
     *    a. Replace the global delimiter list by the one defined locally
     *       on the node, if any.
     *
     * 3. Register the entry into the field; remember the enter item index.
     *
     * 4. Parse all of the children.
     *    a. If a child fails, continue.
     *    b. If a child matches, create match entry and stop.
     *    c. If state is not end-of-parent after the matched child, fail match.
     *
     * 4. Register leaving the field, using the enter item index.
     *
     * 5. Restore the delimiter state.
     *
     * On match, advance mPos past the field data, and update the match map.
     * On return, set mDone=true if we found end-of-data or a parent delimiter.
     *
     * @param node  the node descriptor
     * @param required  if true, match failure is an error
     * @param delimLevel  current level in delimiter list
     * @param delimStack  the current delimiter stack state
     * @param count  number of occurrences seen so far
     * @return -1 on match failure, else number of matched occurrences
     */
    private int parseChoice (Node node, boolean required,
        DelimLevel delimLevel, DelimStack delimStack, int count) {
        if (mLog.isLoggable(Level.FINE)) {
            String msg = "Parse choice node '" + node.mName + "', required=" + required + ", count=" + count;
            if (mLog.isLoggable(Level.FINER)) {
                mLog.finer(msg + "," + LN + " node=[" + node + "]," + LN + " delimLevel=[" + delimLevel + "]," + LN + " delimStack=[" + delimStack + "].");
            } else {
                mLog.fine(msg + ".");
            }
        }
        if (node.isLeaf()) {
            throw new IllegalArgumentException(
                "Expecting choice node, but found simple node."); //I18N
        }
        // 1. If we are in end-of-parent state, fail the match.
        if (mDone) {
            // Parent delimiter already reached.
            if (node.mIsOptional /*|| node.mIsRepeatable*/) {
                return 0;
            }
            if (required && !node.mIsOptional) {
                fail(node, "End of parent found.");
            }
            return -1;
        }
        // 2. Replace the global delimiter list by the one defined locally
        // on the node, if any
        if (node.mDelimLevel != null) {
            // locally defined delimiters take precedence.
            delimLevel = node.mDelimLevel;
        }
        if (node.mSubnodes.length == 0) {
            //NYI...
            throw new RuntimeException("Encountered a childless choice node.");
        }
        //boolean might = (required && !node.mIsOptional /*&& !node.mIsRepeatable*/);
        String reason = null;
        int oldCount = count;
occurLoop:
        do {
            // Handle one repetition occurrence.
            if (count == node.mMaxOccurs) {
                if (mLog.isLoggable(Level.FINE)) {
                    mLog.fine("Reached max occurrences=" + count);
                }
                break occurLoop;
            }
            // Register the entry into the field; remember the enter item index.
            int rpIdx = (node.mIsRepeatable ? count : -1);
            int enterItemIndex = mMatch.enter(node.mChildIndex, rpIdx, mPos);
                                          // (childIndex, repIndex, pos)
            // Parse all of the children.
            // a. If a child fails to get matched, continue to next child.
            // b. If a child matches, create match entry and stop.
            // c. If state is not end-of-parent after the matched child, fail match.
            int pos = mPos;
            int matchedCnt = -1;
            for (int i = 0; matchedCnt < 0 && i < node.mSubnodes.length; i++) {
                Node subNode = mNodes.get(node.mSubnodes[i]);
                boolean required_ = (required && count < node.mMaxOccurs
                    && i == node.mSubnodes.length - 1);
                boolean lastChild = (node.mSubnodes.length > 1)
                    && (i == node.mSubnodes.length - 1);
                matchedCnt = handleNode(subNode, required_,  delimLevel,
                    delimStack, 0, true, pos, lastChild);
                // (node, required, delimLevel, delimStack, count, ordered, startOfOffset, lastChild)
            }

            if (matchedCnt < 0) {
                mMatch.reset(enterItemIndex);
                reason = "No alternative matched";
                break occurLoop;
            }
            mMatch.leave(enterItemIndex);
            count++;
        } while (node.mIsRepeatable);

        mReason = reason;
        return (count - oldCount);
    }

    /**
     * Parses a node with the given descriptor.
     * This just switches out to the various specialized methods.
     * We could refactor those methods into fewer, more generic code cases.
     *
     * On match, advance mPos past the field data and the following local
     * delimiter (if it belongs to the node itself), and update the match map.
     * On return, set mDone=true if we found end-of-data or a parent delimiter.
     *
     * @param node  the node descriptor
     * @param required  if true, match failure is an error
     * @param delimLevel  current level in delimiter list
     * @param delimStack  the current delimiter stack state
     * @param count  number of occurrences seen so far
     * @param ordered if the node belongs to an ordered group
     * @param startOfOffset starting position for applying offset. Basically
     *                      it is the start position of the parent node.
     * @param lastChild whether or not this node is the last child at this level
     * @return the number of matched occurrences, or -1 for parse failure
     */
    public int handleNode(Node node, boolean required,
        DelimLevel delimLevel, DelimStack delimStack, int count,
        boolean ordered, int startOfOffset, boolean lastChild) {
        if (delimStack == null) {
            throw new NullPointerException("Null delim stack encountered.");
        }
        if (mLog.isLoggable(Level.FINER)) {
            String msg = "Parse node '" + node.mName + "', required=" + required + ", count=" + count + ", ordered=" + ordered + ", startOfOffset=" + startOfOffset;
            if (mLog.isLoggable(Level.FINEST)) {
                mLog.finest(msg + "," + LN + " node=[" + node + "]," + LN + " curPos=" + mPos + ", delimLevel=[" + delimLevel + "]," + LN + " delimStack=[" + delimStack + "].");
            } else {
                mLog.finer(msg + ".");
            }
        }
        int matchedCount = 0;
        switch (node.mType) {
            case ALTER:
                matchedCount = parseChoice(node, required, delimLevel, delimStack, count);
                break;
            case ARRAY:
            case DELIM:
                if (node.isLeaf()) {
                    matchedCount = parseDelimitedLeaf(node, required, delimLevel, delimStack, count);
                } else {
                    matchedCount = parseDelimitedGroup(node, required, delimLevel, delimStack, count, lastChild);
                }
                break;
            case FIXED:
                matchedCount = parseFixed(node, required, delimLevel, delimStack, count, startOfOffset);
                break;
            case GROUP:
                 matchedCount = parseGroup(node, required, delimLevel, delimStack, count);
                break;
            case TRANS:
                // Transient nodes have no serialized form.
                if (node.mIsOptional) {
                    matchedCount = 1;
                } else if (node.mMinOccurs - count < 0) {
                    matchedCount = 0;
                } else {
                    matchedCount = node.mMinOccurs - count;
                }
                break;
            default:
                throw new RuntimeException("Unknown node type encountered: " + node.mType);
        }
        // check if got minimum mandatory occurrence.
        if ((matchedCount + count < node.mMinOccurs) && ordered /*&& !node.mIsRepeatable*/) {
            if (required) {
                fail(node, "Failed node parse, reason="
                    + (mReason != null ? mReason : "Require minimum occurrence=" + node.mMinOccurs));
            }
            return -1;
        }
        if (mLog.isLoggable(Level.FINE)) {
            mLog.fine("Parsed node '" + node.mName + "', done=" + mDone + ", currPos=" + mPos + ", end=" + mEnd + ", lastDelim=" + (mLastDelim == null ? "EOD" : Misc.printable(mLastDelim.mBytes)) + ", matchCount=" + matchedCount);
        }
        return matchedCount;
    }


    /**
     * Private implementation of location info to wrap byte offset.
     */
    private static class Ud1Location implements OtdLocation {
        long mOffset = -1;

        /**
         * Constructs from byte offset into input data.
         *
         * @param offset  byte location, starting at 0
         */
        public Ud1Location(final long offset) {
            mOffset = offset;
        }

        /*------------------*\
        |  REQUIRED METHODS  |
        \*------------------*/

        /**
         * Converts the information to a printable string, suitable for
         * inclusion in a basic textual error message.
         *
         * @return a text string
         */
        public String text() {
            if (mOffset < 0) {
                return "unknown offset";
            } else {
                return "byte offset: " + mOffset;
            }
        }

        /**
         * Gives the enclosing location context, if any.
         * For embedded parsing, this should return the information on the
         * node containg the embedded section.
         * NYI: dummy for now...
         *
         * @return the location, or null if none
         */
        public OtdLocation from() {
            return null;
        }

        /**
         * Gets a property by name.
         * This is a generic extension mechanism.
         *
         * @param name  the property name
         * @return the value, or null if not known
         */
        public Object getProperty (final String name) {
            if ("offset".equals(name) && mOffset >= 0) {
                return new Long(mOffset);
            }
            return null;
        }
    }

    /**
     * An implementation of the CharSequence interface, which is backed by
     * a byte array and the encoding used to convert byte array to
     * character sequence is ISO-8859-1 (Latin1).  This is a workaround to
     * apply Java regex functionality to byte array data.
     */
    public static class Latin1CharSequence implements CharSequence {

        private final byte[] mBytes;
        private final int mLen;
        private final int mStart;
        private final int mEnd;

        public Latin1CharSequence(byte[] bytes, int start, int end) {
            if (start < 0 || end < 0 || end < start) {
                throw new ArrayIndexOutOfBoundsException(
                        "start=" + start + ", end=" + end);
            }
            mBytes = bytes;
            mStart = start;
            mEnd = end;
            mLen = end - start;
        }

        public char charAt(int index) {
            if (index < 0 || index + mStart >= mEnd) {
                throw new ArrayIndexOutOfBoundsException(index);
            }
            return (char) mBytes[mStart + index];
        }

        public int length() {
            return mLen;
        }

        public CharSequence subSequence(int start, int end) {
            return new Latin1CharSequence(mBytes, mStart + start, mStart + end);
        }
    }

    /**
     * Tests the parser with a simple case.
     * @param args arguments.
     */
    public static void main(String[] args) {
        if (args.length < 5) {
            System.out.println("Usage: java com.sun.encoder.custom.runtime.provider.Parse <xsdFilename> <namespace> <rootElementName> <inputFilename> <logFilename>");
        }
        try {
            System.out.println("-BEGIN-");
            String xsdFilename = "C:/OpenSourceProjects/open-jbi-components/ojc-core/encodersl/encoder-custom/test/data/test03.xsd";
            if (args.length >= 1) {
                xsdFilename = args[0];
            }
            System.out.println("xsdFilename=" + xsdFilename);
            String namespace = "http://xml.netbeans.org/schema/newXMLSchema";
            if (args.length >= 2) {
                namespace = args[1];
            }
            System.out.println("namespace=" + namespace);
            String rootElementName = "root";
            if (args.length >= 3) {
                rootElementName = args[2];
            }
            System.out.println("rootElementName=" + rootElementName);
            String inputFilename = "C:/OpenSourceProjects/open-jbi-components/ojc-core/encodersl/encoder-custom/test/data/test03_decode_input.txt";
            if (args.length >= 4) {
                inputFilename = args[3];
            }
            System.out.println("inputFilename=" + inputFilename);
            FileInputStream inStream = new FileInputStream(inputFilename);
            byte[] data = new byte[inStream.available()];
            BufferedInputStream in = new BufferedInputStream(inStream);
            in.read(data);
            inStream.close();
            in.close();
            String logFilename = "c:/Parse_main.log";
            if (args.length >= 5) {
                logFilename = args[4];
            }
            System.out.println("Log file name=" + logFilename);
            File xsdFile = new File(xsdFilename);
            QName rootElementQName = new QName(namespace, rootElementName);
            Nodes nodes = NodesFactory.loadFromXSD(xsdFile, rootElementQName);
            OtdDelim.OtdDelimInst inst = nodes.getDelim().new OtdDelimInst();
            Parse parse = new Parse(inst, nodes);
            Logger logger = Logger.getLogger("com.sun.encoder.custom");
            logger.setLevel(Level.FINEST);
            Handler logHandler = new FileHandler(logFilename, false);
            logHandler.setFormatter(new SimpleFormatter());
            logger.addHandler(logHandler);
            ContentHandler handler = new SimpleContentHandler(true);
            StringCoder decoder = CoderFactory.getCoder(Nodes.DEFAULT_ENCODING);
            parse.parseFromBytes(0, handler, decoder, data);
            System.out.println("-FINISH-");
        } catch (Exception ex) {
            ex.printStackTrace();
            System.exit(1);
        }
    }
}

