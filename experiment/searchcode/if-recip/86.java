

import java.text.*;
import java.util.*;
import javax.swing.*;
import javax.swing.event.*;

/**
 * This class is part of the SILKin program's GUI. It is modeled after the
 * KAES KinshipEditor by Michael D. Fischer of the Centre for Social
 * Anthropology and Computing, University of Kent.
 * Those portions taken from his code are copyrighted by him; all rights
 * reserved. See his complete copyright statement and terms of re-use in
 * e.g. KinshipEditor.java in this package.
 *
 * DATA POSTING STRATEGY - As soon as any field in this panel loses focus, we
 * post the latest data to the Individual/Person being displayed ("infoPerson").
 * When a new person is chosen for display, we validate all data and if any
 * invalid fields are found, we do not allow the change in infoPerson until
 * valid data is entered. Then the person's record is updated and we proceed to
 * let user choose a new infoPerson to display/edit.
 *
 * @author Gary Morris, Northern Virginia Community College
 */
public class PersonPanel extends javax.swing.JPanel {

    /** Creates new form PersonPanel */
    public PersonPanel() {
        initComponents();
        parent = SIL_Edit.editWindow;
        alterID.setColumns(3);
        alterRefTerm.setEditable(false);
        recipRefTerm.setEditable(false);
        egoChoiceModel = (DefaultComboBoxModel)egoChoiceBox.getModel();
        egoChoiceModel.removeAllElements();  //  ready for first person
        personComments.getDocument().addDocumentListener(new CommentListener());
//        buildFocusFields();
    }

    SIL_Edit parent = null;  //  The container holding this JPanel.
    String kinterm = null,
           reciprocalKinTerm = null;
    DefaultComboBoxModel egoChoiceModel;

    boolean dirty = false;  //  This 'dirty bit' applies only to the current
                            //  infoPerson.
    boolean storing = false;  // true when storing info on Person
    boolean birthDateNormallyCaptured = false,
            surnameNormallyCaptured = true;

    static String alterKinTermRefImg, alterKinTermAdrImg, recipKinTermRefImg, recipKinTermAdrImg;
    JTextField[] focusFields;

    void buildFocusFields() {
        int size = 3, ndx = 0;
        if (surnameNormallyCaptured) size++;
        if (birthDateNormallyCaptured) size++;
        if (parent.chart.distinctAdrTerms) size += 2;
        focusFields = new JTextField[size];
        focusFields[ndx++] = alterFirstNames;
        if (surnameNormallyCaptured) {
            focusFields[ndx++] = alterLastName;
        }
        if (birthDateNormallyCaptured) {
            focusFields[ndx++] = personBirthYr;
        }
        focusFields[ndx++] = alterRefTerm;
        focusFields[ndx++] = recipRefTerm;
        if (parent.chart.distinctAdrTerms) {
            focusFields[ndx++] = alterAdrTerm;
            focusFields[ndx++] = recipAdrTerm;
        }
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        alterFirstNames = new javax.swing.JTextField();
        alterLastName = new javax.swing.JTextField();
        egoPanel = new javax.swing.JPanel();
        egoChoiceBox = new javax.swing.JComboBox();
        jLabel5 = new javax.swing.JLabel();
        alterID = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        personBirthMM = new javax.swing.JTextField();
        personBirthYr = new javax.swing.JTextField();
        jLabel12 = new javax.swing.JLabel();
        personDeathYear = new javax.swing.JTextField();
        personDeathMon = new javax.swing.JTextField();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        alterRefTerm = new javax.swing.JTextField();
        jLabel11 = new javax.swing.JLabel();
        recipRefTerm = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        alterAdrTerm = new javax.swing.JTextField();
        recipAdrTerm = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        personComments = new javax.swing.JTextPane();
        bornYrLabel = new javax.swing.JLabel();
        personBirthDD = new javax.swing.JTextField();
        personDeathDD = new javax.swing.JTextField();
        dataChgDateLabel = new javax.swing.JLabel();
        dataChgDate = new javax.swing.JTextField();

        setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Current Alter", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Grande", 0, 13), new java.awt.Color(0, 0, 204))); // NOI18N
        setMaximumSize(new java.awt.Dimension(907, 309));
        setMinimumSize(new java.awt.Dimension(907, 309));

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel1.setText("Name");
        jLabel1.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);

        alterFirstNames.setEditable(false);
        alterFirstNames.setText("first names");
        alterFirstNames.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                alterFirstNamesFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                alterFirstNamesFocusLost(evt);
            }
        });

        alterLastName.setEditable(false);
        alterLastName.setText("last name");
        alterLastName.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                alterLastNameFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                alterLastNameFocusLost(evt);
            }
        });

        egoPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Current Ego", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Grande", 1, 10), new java.awt.Color(255, 0, 51))); // NOI18N

        egoChoiceBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        egoChoiceBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                egoChoiceBoxActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout egoPanelLayout = new org.jdesktop.layout.GroupLayout(egoPanel);
        egoPanel.setLayout(egoPanelLayout);
        egoPanelLayout.setHorizontalGroup(
            egoPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(egoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(egoChoiceBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 321, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        egoPanelLayout.setVerticalGroup(
            egoPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(egoChoiceBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
        );

        jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel5.setText("ID#");

        alterID.setEditable(false);
        alterID.setText("nnn");
        alterID.setMinimumSize(new java.awt.Dimension(100, 28));

        jLabel8.setText("Born:");

        personBirthMM.setColumns(2);
        personBirthMM.setEditable(false);
        personBirthMM.setText("MM");
        personBirthMM.setMaximumSize(new java.awt.Dimension(64, 28));
        personBirthMM.setMinimumSize(new java.awt.Dimension(64, 28));
        personBirthMM.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                personBirthMMActionPerformed(evt);
            }
        });

        personBirthYr.setColumns(4);
        personBirthYr.setEditable(false);
        personBirthYr.setText("YYYY");
        personBirthYr.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                personBirthYrFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                personBirthYrFocusLost(evt);
            }
        });

        jLabel12.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel12.setText("Notes on Alter");

        personDeathYear.setColumns(4);
        personDeathYear.setEditable(false);
        personDeathYear.setText("YYYY");
        personDeathYear.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                personDeathYearFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                personDeathYearFocusLost(evt);
            }
        });

        personDeathMon.setColumns(2);
        personDeathMon.setEditable(false);
        personDeathMon.setText("MM");
        personDeathMon.setMaximumSize(new java.awt.Dimension(73, 28));
        personDeathMon.setMinimumSize(new java.awt.Dimension(64, 28));

        jLabel9.setText("Died:");

        jLabel10.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel10.setText("Ego refers to Alter:");

        alterRefTerm.setEditable(false);
        alterRefTerm.setText("kin term");
        alterRefTerm.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                alterRefTermFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                alterRefTermFocusLost(evt);
            }
        });

        jLabel11.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabel11.setText("Alter refers to Ego:");

        recipRefTerm.setEditable(false);
        recipRefTerm.setText("reciprocal kin term");
        recipRefTerm.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                recipRefTermFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                recipRefTermFocusLost(evt);
            }
        });

        jLabel2.setText("Ego addresses Alter:");

        jLabel3.setText("Alter addresses Ego:");

        alterAdrTerm.setEditable(false);
        alterAdrTerm.setText("kin term of address");
        alterAdrTerm.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                alterAdrTermFocusGained(evt);
            }
        });

        recipAdrTerm.setEditable(false);
        recipAdrTerm.setText("reciprocal term of address");
        recipAdrTerm.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                recipAdrTermFocusGained(evt);
            }
        });

        jScrollPane1.setViewportView(personComments);

        bornYrLabel.setText("Yr");

        personBirthDD.setColumns(2);
        personBirthDD.setText("DD");
        personBirthDD.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                personBirthDDActionPerformed(evt);
            }
        });
        personBirthDD.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                personBirthDDFocusGained(evt);
            }
        });

        personDeathDD.setColumns(2);
        personDeathDD.setText("DD");
        personDeathDD.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                personDeathDDFocusGained(evt);
            }
        });

        dataChgDateLabel.setText("Last Data Change: ");

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                        .add(15, 15, 15)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 38, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel5))
                        .add(2, 2, 2)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(layout.createSequentialGroup()
                                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                    .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                                        .add(alterID, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                        .add(19, 19, 19)
                                        .add(jLabel8))
                                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel9))
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(bornYrLabel)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                                    .add(personDeathYear)
                                    .add(personBirthYr))
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                                    .add(personDeathMon, 0, 0, Short.MAX_VALUE)
                                    .add(personBirthMM, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 40, Short.MAX_VALUE))
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                    .add(personDeathDD, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .add(personBirthDD, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                            .add(layout.createSequentialGroup()
                                .add(alterFirstNames, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 159, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                .add(2, 2, 2)
                                .add(alterLastName, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 119, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 160, Short.MAX_VALUE))
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel10)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel11)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel2)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jLabel3))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(alterRefTerm, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 264, Short.MAX_VALUE)
                            .add(recipRefTerm, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 264, Short.MAX_VALUE)
                            .add(alterAdrTerm, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 264, Short.MAX_VALUE)
                            .add(recipAdrTerm, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 264, Short.MAX_VALUE))
                        .add(93, 93, 93)))
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(13, 13, 13)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(layout.createSequentialGroup()
                                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 347, Short.MAX_VALUE)
                                .add(20, 20, 20))
                            .add(egoPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(layout.createSequentialGroup()
                                .add(dataChgDateLabel)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(dataChgDate, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 174, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                .addContainerGap())))
                    .add(layout.createSequentialGroup()
                        .add(127, 127, 127)
                        .add(jLabel12)
                        .addContainerGap())))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(11, 11, 11)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                                .add(org.jdesktop.layout.GroupLayout.LEADING, alterFirstNames)
                                .add(org.jdesktop.layout.GroupLayout.LEADING, alterLastName))
                            .add(jLabel1))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel5)
                            .add(alterID, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(jLabel8)
                            .add(bornYrLabel)
                            .add(personBirthYr, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(personBirthMM, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(personBirthDD, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel9)
                            .add(personDeathYear, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(personDeathMon, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(personDeathDD, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                    .add(layout.createSequentialGroup()
                        .add(egoPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(27, 27, 27)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(dataChgDateLabel)
                            .add(dataChgDate, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel10)
                    .add(alterRefTerm, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jLabel12))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                    .add(layout.createSequentialGroup()
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel11)
                            .add(recipRefTerm, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel2)
                            .add(alterAdrTerm, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel3)
                            .add(recipAdrTerm, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                    .add(jScrollPane1))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

//  DATA CAPTURE STRATEGY
//  This panel's 'dirty bit' records whether any data has been entered on the
//  panel but not yet stored on the Family/Marriage object.
//  The KinEditPanel2's dirty bit, by contrast, records whether any objects
//  have been updated but not yet saved to disk.
//  The panel dirty bit is turned on whenever an editable field gains the
//  focus. If that field later loses the focus, a data store is triggered.
//  But if the user takes some other action that does NOT fire a Focus_Lost
//  event, the dirty bit will prevent loss of data.

    private void alterFirstNamesFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterFirstNamesFocusLost
        String s = alterFirstNames.getText();
        if (parent.infoPerson != null) {
            if (parent.infoPerson.firstNames == null || ! parent.infoPerson.firstNames.equals(s)) {
                parent.infoPerson.firstNames = s;
                parent.infoPerson.updateNames();
                dirty = true;
            }
        }
    }//GEN-LAST:event_alterFirstNamesFocusLost

    private void alterLastNameFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterLastNameFocusLost
        String s = alterLastName.getText();
        if (parent.infoPerson != null) {
            if (parent.infoPerson.surname == null || ! parent.infoPerson.surname.equals(s)) {
                parent.infoPerson.surname = s;
                parent.infoPerson.updateNames();
                dirty = true;
            }
        }
    }//GEN-LAST:event_alterLastNameFocusLost

    private void personBirthYrFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personBirthYrFocusLost
        //  Entries are not validated until a new Person/Family is clicked.
        String s =  personBirthYr.getText();
        if (parent.infoPerson != null) {
            if (parent.infoPerson.birthYr == null || ! parent.infoPerson.birthYr.equals(s)) {
                parent.infoPerson.birthYr = s;
                dirty = true;
            }
        }
    }//GEN-LAST:event_personBirthYrFocusLost

    private void personDeathYearFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personDeathYearFocusLost
        //  Entries are not validated until a new Person/Family is clicked.
        String s =  personDeathYear.getText();
        if (parent.infoPerson != null) {
            if (parent.infoPerson.deathYr == null || ! parent.infoPerson.deathYr.equals(s)) {
                parent.infoPerson.deathYr = s;
                dirty = true;
            }
        }
    }//GEN-LAST:event_personDeathYearFocusLost

    private void alterRefTermFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterRefTermFocusLost
        // TODO add your handling code here:
    }//GEN-LAST:event_alterRefTermFocusLost

    private void recipRefTermFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_recipRefTermFocusLost
        // TODO add your handling code here:
    }//GEN-LAST:event_recipRefTermFocusLost

    private void alterFirstNamesFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterFirstNamesFocusGained
        dirty = true;
    }//GEN-LAST:event_alterFirstNamesFocusGained

    private void alterLastNameFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterLastNameFocusGained
        dirty = true;
    }//GEN-LAST:event_alterLastNameFocusGained

    private void personBirthYrFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personBirthYrFocusGained
        dirty = true;
    }//GEN-LAST:event_personBirthYrFocusGained

    private void personDeathYearFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personDeathYearFocusGained
        dirty = true;
    }//GEN-LAST:event_personDeathYearFocusGained

    private void alterRefTermFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterRefTermFocusGained
        dirty = true;
    }//GEN-LAST:event_alterRefTermFocusGained

    private void recipRefTermFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_recipRefTermFocusGained
        dirty = true;
    }//GEN-LAST:event_recipRefTermFocusGained

    private void egoChoiceBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_egoChoiceBoxActionPerformed
        if (! storing) {
            parent.changeEgo(egoChoiceBox.getSelectedIndex());
        }
    }//GEN-LAST:event_egoChoiceBoxActionPerformed

    private void alterAdrTermFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_alterAdrTermFocusGained
        dirty = true;
    }//GEN-LAST:event_alterAdrTermFocusGained

    private void recipAdrTermFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_recipAdrTermFocusGained
        dirty = true;
    }//GEN-LAST:event_recipAdrTermFocusGained

    private void personBirthMMActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_personBirthMMActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_personBirthMMActionPerformed

    private void personBirthDDActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_personBirthDDActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_personBirthDDActionPerformed

    private void personDeathDDFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personDeathDDFocusGained
        dirty = true;
    }//GEN-LAST:event_personDeathDDFocusGained

    private void personBirthDDFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_personBirthDDFocusGained
        dirty = true;
    }//GEN-LAST:event_personBirthDDFocusGained

    
    void clearInfo() {
        storing = true;
        alterFirstNames.setText("");
        alterLastName.setText("");
        alterID.setText("");
        personBirthDD.setText("");
        personDeathDD.setText("");
        personBirthMM.setText("");
        personDeathMon.setText("");
        personBirthYr.setText("");
        personDeathYear.setText("");
        dataChgDate.setText("");
        personComments.setText("");
        alterRefTerm.setText("");
        recipRefTerm.setText("");
        alterAdrTerm.setText("");
        recipAdrTerm.setText("");
        alterRefTerm.setEditable(false);
        recipRefTerm.setEditable(false);
        alterAdrTerm.setEditable(false);
        recipAdrTerm.setEditable(false);
        alterFirstNames.setEditable(false);
        alterLastName.setEditable(false);
        personBirthMM.setEditable(false);
        personDeathMon.setEditable(false);
        personBirthYr.setEditable(false);
        personDeathYear.setEditable(false);
        personComments.setEditable(false);
        storing = false;
    }

    public void displayClues() {
        storing = true;
        alterFirstNames.setText("first names");
        alterLastName.setText("last name");
        alterID.setText("nnn");
        personBirthDD.setText("DD");
        personDeathDD.setText("DD");
        personBirthMM.setText("MM");
        personDeathMon.setText("MM");
        personBirthYr.setText("YYYY");
        personDeathYear.setText("YYYY");
        dataChgDate.setText("entry date");
        personComments.setText("");
        alterRefTerm.setText("kin_term");
        recipRefTerm.setText("reciprocal_kin_term");
        alterAdrTerm.setText("kin_term_of_address");
        recipAdrTerm.setText("reciprocal_kin_term_of_address");
        storing = false;
    }

    void showInfo(Individual ind) {
        storing = true;
        if (focusFields == null) buildFocusFields();
        alterFirstNames.setText(ind.firstNames);
        alterLastName.setText(ind.surname);
        alterID.setText(String.valueOf(ind.serialNmbr));
        personBirthDD.setText(ind.getBirthDD());
        personDeathDD.setText(ind.getDeathDD());
        personBirthMM.setText(ind.getBirthMM());
        personDeathMon.setText(ind.getDeathMM());
        personBirthYr.setText(ind.getBirthYr());
        personDeathYear.setText(ind.getDeathYr());
        dataChgDate.setText(ind.dataChangeDate);
        personComments.setText(restoreLineBreaks(ind.comment));
        alterFirstNames.setEditable(true);
        alterLastName.setEditable(true);
        personBirthMM.setEditable(true);
        personDeathMon.setEditable(true);
        personBirthYr.setEditable(true);
        personDeathYear.setEditable(true);
        personComments.setEditable(true);
        if (ind.serialNmbr == parent.getCurrentEgo()) {
            alterRefTerm.setText("Ego");
            recipRefTerm.setText("Ego");
            alterAdrTerm.setText("Ego");
            recipAdrTerm.setText("Ego");
            alterRefTerm.setEditable(false);
            recipRefTerm.setEditable(false);
            alterAdrTerm.setEditable(false);
            recipAdrTerm.setEditable(false);
        } else if (ind.node != null) {
        // There may be kin terms already recorded
            Individual ego = Context.current.individualCensus.get(parent.getCurrentEgo());
            checkForAutoDefs(ind.node, ego);
            fillTextField(ind.node, alterRefTerm, false);
            fillTextField(ind.node, alterAdrTerm, parent.chart.distinctAdrTerms);
            TreeMap tmap = parent.ktm.getRow(ind.serialNmbr);
            Node altNode = (Node) tmap.get(parent.getCurrentEgo());
            if (altNode != null) {
                checkForAutoDefs(altNode, ind);
                fillTextField(altNode, recipRefTerm, false);
                fillTextField(altNode, recipAdrTerm, parent.chart.distinctAdrTerms);
            }else {
                recipRefTerm.setText("");
                recipAdrTerm.setText("");
            }
            alterRefTerm.setEditable(true);
            recipRefTerm.setEditable(true);
            alterAdrTerm.setEditable(parent.chart.distinctAdrTerms);
            recipAdrTerm.setEditable(parent.chart.distinctAdrTerms);

        } else {
        //  No node means not yet connected
            alterRefTerm.setText("Not linked to Ego");
            recipRefTerm.setText("Not linked to Ego");
            alterAdrTerm.setText("Not linked to Ego");
            recipAdrTerm.setText("Not linked to Ego");
            alterRefTerm.setEditable(false);
            recipRefTerm.setEditable(false);
            alterAdrTerm.setEditable(false);
            recipAdrTerm.setEditable(false);
        } // store images of 4 boxes before any User edits
        alterKinTermRefImg = alterRefTerm.getText();
        alterKinTermAdrImg = alterAdrTerm.getText();
        recipKinTermRefImg = recipRefTerm.getText();
        recipKinTermAdrImg = recipAdrTerm.getText();
        for (JTextField fld : focusFields) {
            if (fld.getText().equals("")) {
                fld.grabFocus();
                break;
            }
        }
        storing = false;
    }
    
    static String restoreLineBreaks(String in) {        
        return in.replace("$$br$$", "\n");
    }
    
    void checkForAutoDefs(Node nod, Individual ego) {
        TreeMap<String, ArrayList<Context.CB_Ptr>> map = Context.current.autoDefRef;
        ArrayList<Context.CB_Ptr> list = map.get(nod.pcString);
        DomainTheory dt = null;
        try {
            dt = Context.current.domTheoryRef();
        } catch (Exception ex) {  }  //  nothing can go wrong, go wrong, go wrong...
        applyAutoDef(nod, list, dt, ego);
        if (Context.current.domTheoryAdrExists() && parent.chart.distinctAdrTerms
                && Context.current.autoDefAdr != null) {
            map = Context.current.autoDefAdr;
            list = map.get(nod.pcString);
            try {
                dt = Context.current.domTheoryAdr();
            } catch (Exception ex) {  }  
            applyAutoDef(nod, list, dt, ego);
        }
    }
    
    private void applyAutoDef(Node nod, ArrayList<Context.CB_Ptr> list, 
            DomainTheory dt, Individual ego) {
        if (list == null) {
            return;
        }
        Context ctxt = Context.current;
        Dyad dad = new Dyad(ego);
        dad.alter = nod.indiv;
        dad.pcString = nod.pcString;
        for (Context.CB_Ptr ptr : list) {
            if (nod.hasKinTerm(ptr.kinTerm)) {
                continue;  //  no need for auto-def if term is already here
            }
            try {
                KinTermDef ktd = (KinTermDef) dt.theory.get(ptr.kinTerm);
                ClauseBody cb = (ClauseBody) ktd.expandedDefs.get(ptr.clauseNmbr);
                if (dt.fit(cb, dad)) {
                    String clas = (dt.addressTerms ? "address" : "reference");
                    nod.addTerm(ptr.kinTerm, "primary", clas);
                    dad.kinTerm = ptr.kinTerm;
                    dad.level = cb.level;
                    dad.kinTermType = 0;  // 0 = primary
                    if (dt.addressTerms) dad.addrOrRef = 1;  //  0 is default
                    dad.pcStringStructural = ClauseBody.structStr(dad.pcString);
                    dad.makePath(nod.miniPreds, dad.alter);
                    dt.dyadsDefined.dyAdd(dad);
                    TreeMap<String, ArrayList<Context.HistoryItem>> history = 
                            (dt.addressTerms ? ctxt.learningHistoryAdr : ctxt.learningHistoryRef);
                    postToLrngHist(history, dad);
                }
            } catch (Exception ex) {
                String msg = "FYI: Exception while trial-fitting an accepted def.\n" + ex;
                MainPane.displayError(msg, "Internal Error", JOptionPane.INFORMATION_MESSAGE);
            }
        }
    }
    
    private void postToLrngHist(TreeMap<String, ArrayList<Context.HistoryItem>> history, Dyad dad) {
        ArrayList<Context.HistoryItem> items = history.get(dad.kinTerm);
        Context.AcceptedDefPtr adp = null;
        if (items != null) {
            for (Context.HistoryItem item : items) {
                if (item instanceof Context.AcceptedDefPtr && ! item.rescinded) {
                    adp = (Context.AcceptedDefPtr)item;
                }
            }
            if (adp != null) {
                Integer[] pair = new Integer[2];
                pair[0] = dad.ego.serialNmbr;
                pair[1] = dad.alter.serialNmbr;
                adp.autoDefPairs.add(pair);
            }
        }
    }
    

    void fillTextField(Node nod, String fieldType, boolean addr) {
        JTextField field = null;
        if (fieldType.equals("primary")) {
            field = (addr ? alterAdrTerm : alterRefTerm);
        }else if (fieldType.equals("reciprocal")) {
            field = (addr ? recipAdrTerm : recipRefTerm);
        }
        fillTextField(nod, field, addr);
    }

    void fillTextField(Node nod, JTextField field, boolean addr) {
        ArrayList<String> terms = nod.getKinTerms(addr);
        if (terms.isEmpty()) {
            field.setText("");
        } else {
            String newText = "";
            int soFar = 0;
            for (String s : terms) {
                newText += (soFar++ == 0 ? "" : ", ") + s;
            }
            field.setText(newText);
        }
    }
    
    public String sanitizeName(String nam) {
        return nam.replace("\"", "'").replace('<', '[').replace('>', ']').trim();
    }
    
    public String sanitizeKinTerms(String k, String typ) throws KSParsingErrorException {
        String sanitized = k.replace('-', '_').replace("\"", "'")
                .replace('<', '[').replace('>', ']').trim();
        ArrayList<String> badChars = new ArrayList<String>(), 
                goodChars = new ArrayList<String>();
        if (k.indexOf("-") > -1) {
            badChars.add("-");
            goodChars.add("_");
        }
        if (k.indexOf("\"") > -1) {
            badChars.add("dbl-quote");
            goodChars.add("single-quote");
        }
        if (k.indexOf("<") > -1) {
            badChars.add("<");
            goodChars.add("[");
        }
        if (k.indexOf(">") > -1) {
            badChars.add(">");
            goodChars.add("]");
        }
        String msg, pl;
        if (!badChars.isEmpty()) {
            pl = (badChars.size() > 1 ? "s" : "");
            msg = "Illegal character" + pl + " detected:";
            for (int i=0; i < badChars.size(); i++) {
                msg += "\n'" + badChars.get(i) + "' replaced by '" + goodChars.get(i) + "'";
            }
            msg += "\n in '" + typ + "'";
            JOptionPane.showMessageDialog(parent, msg, 
                    "Restrictions on Kin Term Characters", 
                    JOptionPane.INFORMATION_MESSAGE);
        }
        if (!allBlanksPrecededByCommas(sanitized)) {
            msg = "In '" + typ + "'\n";
            msg += "Kin terms may not contain embedded blanks. If you intended\n";
            msg += "to separate multiple terms, use a comma to separate. If a single\n";
            msg += "term has multiple components, join them with an underscore.";
            JOptionPane.showMessageDialog(parent, msg, 
                    "Restrictions on Kin Term Characters", 
                    JOptionPane.ERROR_MESSAGE);
            throw new KSParsingErrorException("Must remove blanks from kin term");
        }
        char[] letters = sanitized.toCharArray();
        ArrayList<Character> baddies = new ArrayList<Character>();
        for (char ch : letters) {
            if (!Character.isJavaIdentifierPart(ch) && ch != ',' && ch != ' ') {
                baddies.add(ch);
            }
        }
        if (!baddies.isEmpty()) {
            pl = (baddies.size() > 1 ? "s" : "");
            msg = "Illegal character" + pl + " detected: " + baddies;
            msg += "\n in '" + typ + "'";
            JOptionPane.showMessageDialog(parent, msg, 
                    "Restrictions on Kin Term Characters", 
                    JOptionPane.ERROR_MESSAGE);
            throw new KSParsingErrorException("Must replace illegal characters");
        }        
        return sanitized;
    }
    
    boolean allBlanksPrecededByCommas(String s) {
        s = s.trim();
        int bl = s.indexOf(" "), start;
        if (bl == -1) return true;
        while(bl > -1) {
            if (s.charAt(bl -1) != ',' && s.charAt(bl -1) != ' ') {
                return false;
            }
            start = bl +1;
            bl = s.indexOf(" ", start);
        }
        return true;
    }
    

    void storeInfo(Individual infoPerson) 
            throws KSParsingErrorException, JavaSystemException,
		   KSBadHornClauseException, KSInternalErrorException,
                   KSConstraintInconsistency, KSDateParseException {
//	if (! dirty) return;  //  No changes have been made
        storing = true;
        String a, b, c;
        int currEgoNum = parent.getCurrentEgo();
        Individual currEgo =
                    Context.current.individualCensus.get(currEgoNum);
        a = sanitizeName(alterFirstNames.getText());
        b = sanitizeName(alterLastName.getText());
        if (! infoPerson.name.equals(a + " " + b)) {
            infoPerson.name = a + " " + b;
            infoPerson.surname = b;
            infoPerson.firstNames = a;
            parent.chart.dirty = true;            
        }
        if (! infoPerson.deleted) updateEgoNames(infoPerson);
        boolean ok = true;
        a = personBirthMM.getText().trim();
        if (a.length() == 1) a = "0"+ a;  // canonical form
        b = personBirthYr.getText().trim();
        c = personBirthDD.getText().trim();
        if (c.length() == 1) c = "0"+ c;
        if (! infoPerson.getDateOfBirth().equals(UDate.formatAsXSD(b, a, c))) {
            ok = UDate.valiDate(b, a, c, infoPerson, false);
            if (! ok) {
                c = "Invalid date of birth: '" + b + "-" + a + "-" + c;
                throw new KSDateParseException(c);
            }
        }
        a = personDeathMon.getText().trim();
        if (a.length() == 1) a = "0"+ a;
        b = personDeathYear.getText().trim();
        c = personDeathDD.getText().trim();
        if (c.length() == 1) c = "0"+ c;
        if (! infoPerson.getDateOfDeath().equals(UDate.formatAsXSD(b, a, c))) {
            ok = UDate.valiDate(b, a, c, infoPerson, true);
            if (! ok) {
                c = "Invalid date of death: '" + b + "-" + a + "-" + c;
                throw new KSDateParseException(c);
            }
        }
        //  The comments field is handled by a DocumentListner
        ArrayList<String> oldTerms, newTerms;
        if (infoPerson.node != null && infoPerson.serialNmbr != currEgoNum) {
            a = sanitizeKinTerms(alterRefTerm.getText(), "Ego Refers to Alter");
            if (!a.equals(alterKinTermRefImg.trim())) { // alterKinTermRefImg = before User editing
                oldTerms = getKinTerms(alterKinTermRefImg);
                newTerms = getKinTerms(a);
                updateKinTerms(currEgo, infoPerson, infoPerson.node, oldTerms, newTerms, "Ref");
            } // end of User must have edited alterKinTermsRef
            if (parent.chart.distinctAdrTerms) {
                // Must pick up the term of address, if any
                a = sanitizeKinTerms(alterAdrTerm.getText(), "Ego Addresses Alter");
                if (!a.equals(alterKinTermAdrImg.trim())) {
                    oldTerms = getKinTerms(alterKinTermAdrImg);
                    newTerms = getKinTerms(a);
                    updateKinTerms(currEgo, infoPerson, infoPerson.node, oldTerms, newTerms, "Adr");
                }
            }  // end of there-were-distinct-address-terms
            a = sanitizeKinTerms(recipRefTerm.getText(), "Alter Refers to Ego");
            TreeMap tmap = parent.ktm.getRow(infoPerson.serialNmbr);
            Node recipNode = (Node) tmap.get(currEgoNum);
            if (!a.equals(recipKinTermRefImg.trim())) {
                oldTerms = getKinTerms(recipKinTermRefImg);
                newTerms = getKinTerms(a);
                if (recipNode != null) {
                    updateKinTerms(infoPerson, currEgo, recipNode, oldTerms, newTerms, "Ref");
                } else {  //  Must create the reciprocal node
                    recipNode = new Node();
                    recipNode.indiv = currEgo;
                    recipNode.setLevel(-1 * infoPerson.node.getLevel());
                    recipNode.addTerms(newTerms, "primary", "reference");
                    infoPerson.node.invertMiniPredsAndPCStringFor(recipNode);
                    parent.ktm.addNode(infoPerson.serialNmbr, currEgoNum, recipNode);
                    updateKinTerms(infoPerson, currEgo, recipNode, oldTerms, newTerms, "Ref");
                }
            } //  end of recip-ref-terms-were-edited
            if (parent.chart.distinctAdrTerms) {
                // Must pick up the reciprocal term of address, if any
                a = sanitizeKinTerms(recipAdrTerm.getText(), "Alter Addresses Ego");
                if (!a.equals(recipKinTermAdrImg.trim())) {
                    oldTerms = getKinTerms(recipKinTermAdrImg);
                    newTerms = getKinTerms(a);
                    updateKinTerms(infoPerson, currEgo, recipNode, oldTerms, newTerms, "Adr");
                }  //  end of recip-address-terms-were-edited
            }  //  end of distinct-address-terms           
        }  //  end of non-ego-has-a-node
        while (Library.currDataAuthor == null || Library.currDataAuthor.length() == 0) {
            Library.currDataAuthor = parent.chart.getCurrentUser();
        }
        infoPerson.dataAuthor = Library.currDataAuthor;
        infoPerson.dataChangeDate = UDate.today();
        Context.current.dateOfLastDataChange = infoPerson.dataChangeDate;
        parent.chart.dirty = true;
        dirty = false;
        storing = false;
        debugDyads();
    }
    
    
    static ArrayList<String> getKinTerms(String s) {
        ArrayList<String> list1 = new ArrayList<String>(),
                          list2 = new ArrayList<String>();
        s = s.trim();
        int comma = s.indexOf(","), start = 0, stop;
        while(comma > 0) {
            stop = (comma > 0 ? comma : s.length());
            list1.add(s.substring(start, stop));
            start = stop +2;
            comma = s.indexOf(",", start);
        }
        if ((s.length() - start) > 0) {
            list1.add(s.substring(start, s.length()));
        }  
        //  Now check for duplicates
        for (String str : list1) {
            if (!list2.contains(str)) {
                list2.add(str);
            }
        }
        if (list1.size() != list2.size()) {
            String msg = "Removed duplicates from your entry\n'" + s + "'.";
            JOptionPane.showMessageDialog(SIL_Edit.editWindow, msg, 
                    "Restrictions on Kin Term Characters", 
                    JOptionPane.ERROR_MESSAGE);
        }
        return list2;
    }

    
    static void updateKinTerms(Individual currEgo, Individual infoPerson, Node nod,
            ArrayList<String> oldTerms, ArrayList<String> newTerms, String typ) {

        ArrayList<String> deletedTerms = new ArrayList<String>(),
                          addedTerms = new ArrayList<String>();
        for (String newbie : newTerms) {
            if (!oldTerms.contains(newbie)) {
                addedTerms.add(newbie);
            }
        }
        for (String oldie : oldTerms) {
            if (!newTerms.contains(oldie)) {
                deletedTerms.add(oldie);
            } // NOTE: In both the node and dyad, we assume (for now) that
        }     //       only primary terms are being captured. To be Reviewed.
        nod.replaceTerms(newTerms, "primary", (typ.equals("Ref") ? "reference" : "address"));
        try {
            DomainTheory dt = (typ.equals("Ref") ? Context.current.domTheoryRef()
                    : Context.current.domTheoryAdr());            
            for (String term : deletedTerms) {
                if (dt.dyadsDefined.containsKey(term)) {
                    dt.dyadsDefined.removeDyad(term, nod.pcString, currEgo, infoPerson, dt);
                } else {
                    dt.dyadsUndefined.removeDyad(term, nod.pcString, currEgo, infoPerson, dt);
                }
            }
            for (String term : addedTerms) {
                Dyad newDyad = makeDyad(currEgo, infoPerson, term, nod);
                if (dt.dyadsDefined.containsKey(term)) {
                    dt.dyadsDefined.dyAddOrUpdate(newDyad);
                } else {
                    dt.dyadsUndefined.dyAddOrUpdate(newDyad);
                }
            }
        } catch (Exception exc) {
            System.err.println("Error while retrieving Domain Theory from disk:\n" + exc);
        }
    }

    public static Dyad makeDyad(Individual currEgo, Individual infoPerson, String kinTerm, Node alterNode) {
        Dyad d = new Dyad(currEgo);
        d.alter = infoPerson;
        d.level = alterNode.getLevel();
        d.kinTerm = kinTerm;
        d.kinTermType = Dyad.PRIMARY;
        d.addrOrRef = (DomainTheory.addrTerms ? Dyad.ADDR : Dyad.REF);
        d.pcString = alterNode.pcString;
        try {
            d.pcStringStructural = ClauseBody.structStr(d.pcString);
        } catch (KSInternalErrorException ie) {
            String msg = "Problem making structural PCString in PPanel.storeInfo:\n" + ie;
            MainPane.displayError(msg, "Internal Problem", JOptionPane.WARNING_MESSAGE);
        }
        d.makePath(alterNode.miniPreds, infoPerson);
        if (d.path.size() != (symbolCount(d.pcString) -1)) {
            String msg = "\nERROR: Path size incorrect.\nPath = " + d.path;
            msg += "\nPC String = " + d.pcString;
            msg += "\nEgo = #" + currEgo.serialNmbr;
            msg += "\nAlter = #" + infoPerson.serialNmbr;
            System.out.println(msg);     
            Context.breakpoint();
        }
        return d;
    }

    /** Count the number of capital letters and double-asterisks in the
     * PC String. Each is the start of a symbol like 'Fa' or 'Hbro' or '**'
     * which represents one of the standard macro relationships.
     *
     * @param pcString  the kin type, like 'FaBroWiMo'
     * @return  the count
     */
    public static int symbolCount(String pcString) {
        int cnt = 0;
        char ch;
        for (int i=0; i < pcString.length(); i++) {
            ch = pcString.charAt(i);
            if (Character.isJavaIdentifierStart(ch) &&
		Character.isUpperCase(ch)) { // Capital Ltr
                cnt++;
            }else if (ch == '*') { // double-asterisk
                ch = pcString.charAt(++i);
                if (ch != '*') {
                    String msg = "\nERROR: Single '*' found in a PC String.\n";
                    msg += "String = " + pcString;
                    System.out.println(msg);
                    Context.breakpoint();
                }else cnt++;
            }
        }
        return cnt;
    }

    public static String getSymbolNumber(int number, String pcString) {
        String symbol = null;
        int start = 0;
        for (int n=0; n <= number; n++) {
            symbol = firstSymbolOf(pcString.substring(start));
            start += symbol.length();
        }
        return symbol;
    }

    public static String firstSymbolOf(String pcString) {
        if (pcString.substring(0,2).equals("**")) {
            return "**";
        }
        char ch;
        for (int i=1; i < pcString.length(); i++) {
            ch = pcString.charAt(i);
            if ((Character.isJavaIdentifierStart(ch) && Character.isUpperCase(ch))
                    || ch == '*') {
                return pcString.substring(0, i);
            }
        } // If we get here,must have ben a single symbol
        return pcString;
    }

    public static void debugDyads() {
        if (SIL_Edit.editWindow.chart.recomputingDyads) {
            return;
        }
        if (ktMatrixInBalance(false)) {
            return;
        }
        fillMatrixFromDyads();
        if (ktMatrixInBalance(false)) {
            System.err.println("Unbalanced data fixed by filling from Dyads.");
            return;
        }
        fillDyadsFromMatrix();
        if (ktMatrixInBalance(true)) {
            System.err.println("Unbalanced data fixed by cross-filling from Dyads and Matrix.");
        }
    }
    
    static boolean ktMatrixInBalance(boolean giveUp) {
        int ktmSz = 0, ktmCells = 0, mult = 0, popSz = 0, refSz = 0, adrSz = 0;
        try {
            ktmSz = Context.current.ktm.numberOfKinTerms();
            ktmCells = Context.current.ktm.numberOfCells();
            mult = (Context.current.domTheoryAdrExists() ? 2 : 1);
            popSz = Context.current.indSerNumGen;
            refSz = DomainTheory.countLeaves(Context.current.domTheoryRef().dyadsUndefined)
                    + DomainTheory.countLeaves(Context.current.domTheoryRef().dyadsDefined);
            adrSz = (!Context.current.domTheoryAdrExists() ? 0
                    : DomainTheory.countLeaves(Context.current.domTheoryAdr().dyadsUndefined)
                    + DomainTheory.countLeaves(Context.current.domTheoryAdr().dyadsDefined));
        } catch (Exception exc) {
        }
        boolean ktminBalance = (refSz + adrSz) == (ktmSz - (mult * popSz));
        if (!ktminBalance && giveUp) {
            String msg = "Ref dyads: " + refSz + "\tAdr dyads: " + adrSz + "\tktmTerms: "
                    + ktmSz + " - " + (mult * popSz) + " = " + (ktmSz - (mult * popSz)) + "\tktmCells: " + ktmCells;
            MainPane.displayError(msg, "Data Loss Monitoring", JOptionPane.WARNING_MESSAGE);
            System.out.println(msg);
            Context.breakpoint();
            return false;
        }else {
            return ktminBalance;
        }
    }
    
    static ArrayList<DyadTMap> gatherDTMs() {
        ArrayList<DyadTMap> dyadTMs = new ArrayList<DyadTMap>();
        Context ctxt = Context.current;
        try {
            if (ctxt.domTheoryRefExists()) {
                if (ctxt.domTheoryRef().dyadsUndefined != null) {
                    dyadTMs.add(ctxt.domTheoryRef().dyadsUndefined);
                }
                if (ctxt.domTheoryRef().dyadsDefined != null) {
                    dyadTMs.add(ctxt.domTheoryRef().dyadsDefined);
                }
            }
            if (ctxt.domTheoryAdrExists()) {
                if (ctxt.domTheoryAdr().dyadsUndefined != null) {
                    dyadTMs.add(ctxt.domTheoryAdr().dyadsUndefined);
                }
                if (ctxt.domTheoryAdr().dyadsDefined != null) {
                    dyadTMs.add(ctxt.domTheoryAdr().dyadsDefined);
                }
            }
        } catch (Exception exc) {
        }
        return dyadTMs;
    }
    
    static void fillMatrixFromDyads() {
        ArrayList<DyadTMap> dyadTMs = gatherDTMs();
        KinTermMatrix ktm = Context.current.ktm;
        for (DyadTMap tm : dyadTMs) {
            Iterator tmIter = tm.entrySet().iterator();
            while (tmIter.hasNext()) {
                Map.Entry entry1 = (Map.Entry) tmIter.next();
                String kinTerm = (String) entry1.getKey();
                TreeMap typMap = (TreeMap) entry1.getValue();
                Iterator typIter = typMap.values().iterator();
                while (typIter.hasNext()) {
                    ArrayList<Object> dyads = (ArrayList<Object>) typIter.next();
                    for (int i = 0; i < dyads.size(); i++) {
                        Dyad dy = (Dyad) dyads.get(i);
                        Node nod = ktm.getCell(dy.ego, dy.alter);
                        if (nod != null) {
                            String clas = (dy.addrOrRef == 0 ? "reference" : "address");
                            nod.addTerm(kinTerm, "primary", clas);  // addTerm cks for duplicates
                        } else {
                            try {
                                nod = new Node(dy, Context.current);
                                int egoInt = dy.ego.serialNmbr,
                                    altInt = dy.alter.serialNmbr;
                                ktm.addNode(egoInt, altInt, nod);
                            }catch(KSInternalErrorException exc) {                                
                            }                            
                        }
                    }
                }
            }
        }
    }
    
    static void fillDyadsFromMatrix() {
        DyadTMap duR = null, ddR = null, duA = null, ddA = null;
        Context ctxt = Context.current;
        try {
            if (ctxt.domTheoryRefExists()) {
                duR = ctxt.domTheoryRef().dyadsUndefined;
                ddR = ctxt.domTheoryRef().dyadsDefined;
            }
            if (ctxt.domTheoryAdrExists()) {
                duA = ctxt.domTheoryAdr().dyadsUndefined;
                ddA = ctxt.domTheoryAdr().dyadsDefined;
            }
        } catch (Exception e) {
        }
        Iterator egoIter = ctxt.ktm.matrix.entrySet().iterator();
        while (egoIter.hasNext()) {
            Map.Entry entry1 = (Map.Entry) egoIter.next();
            Integer egoInt = (Integer) entry1.getKey();
            TreeMap row = (TreeMap) entry1.getValue();
            Iterator rowIter = row.entrySet().iterator();
            while (rowIter.hasNext()) {
                Map.Entry entry2 = (Map.Entry) rowIter.next();
                Integer altInt = (Integer) entry2.getKey();
                Node n = (Node) entry2.getValue();
                if (!egoInt.equals(altInt)) {  //  don't include self-nodes
                    Individual ego = ctxt.individualCensus.get(egoInt);
                    for (Dyad dy : Dyad.makeDyads(n, ego)) {
                        try {
                            if (dy.addrOrRef == 0) {  // Ref DyadTMaps are always
                                if (ctxt.domTheoryRef().theory.containsKey(dy.kinTerm)) {
                                    ddR.dyAdd(dy);
                                } else {
                                    duR.dyAdd(dy);
                                }
                            } else {
                                if (ctxt.domTheoryAdr().theory.containsKey(dy.kinTerm)) {
                                    ddA.dyAdd(dy);
                                } else {
                                    duA.dyAdd(dy);
                                }
                            }
                        } catch (Exception exc) {
                            MainPane.displayError(exc.toString(),
                                    "While reloading dyads from KinTerm Matrix",
                                    JOptionPane.ERROR_MESSAGE);
                        }
                    }
                }
            }
        }
    }
    

    void clearEgoBox() {
        egoChoiceBox.removeAllItems();
    }

    void rebuildEgoBox() {
        storing = true;
        egoChoiceBox.removeAllItems();
        String newName;
        for (Individual ind : Context.current.individualCensus) {
            newName = (ind.deleted ? "deleted" : ind.name+" <"+ind.serialNmbr+">");
            egoChoiceModel.addElement(newName);
        }
        egoChoiceBox.setSelectedIndex(parent.getCurrentEgo());
        storing = false;
    }

    void addToEgoChoices(Individual ind) {
        String newName = (ind.deleted ? "deleted" : ind.name+" <"+ind.serialNmbr+">");
        egoChoiceModel.addElement(newName);
        if (egoChoiceModel.getSize() == 1) {
            egoChoiceBox.setSelectedIndex(0);
            parent.changeEgo(0);
        }
    }

    void resetEgoBox(int egoNum) {
        egoChoiceBox.setSelectedIndex(egoNum);
    }

    void updateEgoNames(Individual ind) {
        int ndx = ind.serialNmbr;
        String newName = (ind.deleted ? "deleted" : ind.name+" <"+ind.serialNmbr+">");
        if (ndx < egoChoiceModel.getSize()) {
            egoChoiceModel.removeElementAt(ndx);
        }
        egoChoiceModel.insertElementAt(newName, ndx);
        egoChoiceBox.setSelectedIndex(parent.getCurrentEgo());
    }

    void setDistinctAdrTerms(boolean val) {
        parent.chart.distinctAdrTerms = val;
        alterAdrTerm.setEditable(val);
        recipAdrTerm.setEditable(val);
        parent.kinTmAdrBtn.setEnabled(val);
        parent.ltrAdrBtn.setEnabled(val);
        parent.setDistinctAdrMenuItemSelected(val);
        Library.setStubAdrFileExists(Context.current.languageName, val);
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField alterAdrTerm;
    private javax.swing.JTextField alterFirstNames;
    private javax.swing.JTextField alterID;
    private javax.swing.JTextField alterLastName;
    private javax.swing.JTextField alterRefTerm;
    private javax.swing.JLabel bornYrLabel;
    private javax.swing.JTextField dataChgDate;
    private javax.swing.JLabel dataChgDateLabel;
    private javax.swing.JComboBox egoChoiceBox;
    private javax.swing.JPanel egoPanel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField personBirthDD;
    private javax.swing.JTextField personBirthMM;
    private javax.swing.JTextField personBirthYr;
    private javax.swing.JTextPane personComments;
    private javax.swing.JTextField personDeathDD;
    private javax.swing.JTextField personDeathMon;
    private javax.swing.JTextField personDeathYear;
    private javax.swing.JTextField recipAdrTerm;
    private javax.swing.JTextField recipRefTerm;
    // End of variables declaration//GEN-END:variables

    class CommentListener implements DocumentListener {

        public void insertUpdate(DocumentEvent e) {
            if (!storing) {
                if (parent.infoPerson != null) {
                    String txt = FamilyPanel.convertBannedCharacters(personComments.getText());
                    parent.infoPerson.comment = txt;
                    parent.chart.dirty = true;
                }
            }
        }

        public void removeUpdate(DocumentEvent e) {
            if (!storing) {
                if (parent.infoPerson != null) {
                    String txt = FamilyPanel.convertBannedCharacters(personComments.getText());
                    parent.infoPerson.comment = txt;
                    parent.chart.dirty = true;
                }
            }
        }

        public void changedUpdate(DocumentEvent e) {
            //Plain text components do not fire these events
        }
    }  // end of inner class CommentListener

}

