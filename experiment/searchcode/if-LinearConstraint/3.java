/*******************************************************************************
 * Copyright (c) 2009-2013 CWI
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
*******************************************************************************/
package org.rascalmpl.library.analysis.linearprogramming;

//This code was generated by Rascal API gen
import java.util.ArrayList;

import org.apache.commons.math.optimization.GoalType;
import org.apache.commons.math.optimization.RealPointValuePair;
import org.apache.commons.math.optimization.linear.LinearConstraint;
import org.apache.commons.math.optimization.linear.LinearObjectiveFunction;
import org.apache.commons.math.optimization.linear.Relationship;
import org.apache.commons.math.optimization.linear.SimplexSolver;
import org.eclipse.imp.pdb.facts.IBool;
import org.eclipse.imp.pdb.facts.IConstructor;
import org.eclipse.imp.pdb.facts.IInteger;
import org.eclipse.imp.pdb.facts.IList;
import org.eclipse.imp.pdb.facts.IListWriter;
import org.eclipse.imp.pdb.facts.INumber;
import org.eclipse.imp.pdb.facts.IReal;
import org.eclipse.imp.pdb.facts.ISet;
import org.eclipse.imp.pdb.facts.IValue;
import org.eclipse.imp.pdb.facts.IValueFactory;
import org.eclipse.imp.pdb.facts.type.Type;
import org.eclipse.imp.pdb.facts.type.TypeFactory;
import org.eclipse.imp.pdb.facts.type.TypeStore;
import org.rascalmpl.library.util.Maybe;

public class LinearProgramming {
	
	private final IValueFactory values;

	public LinearProgramming(IValueFactory values) {
		super();
		this.values = values;
	}

	public static final TypeStore typestore = new TypeStore(
			org.rascalmpl.values.errors.Factory.getStore(),
			org.rascalmpl.values.locations.Factory.getStore());

	private static final TypeFactory tf = TypeFactory.getInstance();

	public static final Type LLVariableVals = tf.listType(tf.numberType());

	public static final Type LLSolution = tf.abstractDataType(typestore,
			"LLSolution");

	public static final Type LLSolution_llSolution = tf.constructor(typestore,
			LLSolution, "llSolution", LLVariableVals, "varVals",
			tf.numberType(), "funVal");

	public static final Type ConstraintType = tf.abstractDataType(typestore,
			"ConstraintType");

	public static final Type ConstraintType_leq = tf.constructor(typestore,
			ConstraintType, "leq");
	public static final Type ConstraintType_eq = tf.constructor(typestore,
			ConstraintType, "eq");
	public static final Type ConstraintType_geq = tf.constructor(typestore,
			ConstraintType, "geq");

	public static final Type LLCoefficients = LLVariableVals;

	public static final Type LLConstraint = tf.abstractDataType(typestore,
			"LLConstraint");

	public static final Type LLConstraint_llConstraint = tf.constructor(
			typestore, LLConstraint, "llConstraint", LLCoefficients,
			"coefficients", ConstraintType, "ctype", tf.numberType(), "const");

	public static final Type LLLinearExpr = tf.abstractDataType(typestore,
			"LLLinearExpr");

	public static final Type LLLinearExpr_llLinearExp = tf.constructor(
			typestore, LLLinearExpr, "llLinearExp", LLCoefficients,
			"coefficients", tf.numberType(), "const");

	public static IValue LLSolution_llSolution_varVals(IConstructor c) {
		return (IValue) c.get(0);
	}

	public static double LLSolution_llSolution_funVal(IConstructor c) {
		return c.get(1) instanceof IInteger ? (double) ((IInteger) c.get(1))
				.intValue() : ((IReal) c.get(1)).doubleValue();
	}

	public static IList LLConstraint_llConstraint_coefficients(IConstructor c) {
		return (IList) c.get(0);
	}

	public static IConstructor LLConstraint_llConstraint_ctype(IConstructor c) {
		return (IConstructor) c.get(1);
	}

	public static double LLConstraint_llConstraint_const(IConstructor c) {
		return c.get(2) instanceof IInteger ? (double) ((IInteger) c.get(2))
				.intValue() : ((IReal) c.get(2)).doubleValue();
	}

	public static IList LLObjectiveFun_llObjFun_coefficients(IConstructor c) {
		return (IList) c.get(0);
	}

	public static double LLObjectiveFun_llObjFun_const(IConstructor c) {
		return c.get(1) instanceof IInteger ? (double) ((IInteger) c.get(1))
				.intValue() : ((IReal) c.get(1)).doubleValue();
	}

	// begin handwritten code

	private static double[] convertRealList(IList l) {
		double[] elems = new double[l.length()];
		for (int i = 0; i < l.length(); i++) {
			elems[i] = ((INumber) l.get(i)).toReal().doubleValue();
		}
		return elems;
	}

	private static IList convertToRealList(double[] l, IValueFactory vf) {
		TypeFactory tf = TypeFactory.getInstance();
		IListWriter writer = vf.listWriter(tf.realType());
		for (int i = 0; i < l.length; i++) {
			writer.append(vf.real(l[i]));
		}
		return writer.done();
	}

	private static LinearObjectiveFunction 
		convertLinObjFun(IConstructor c) {
		double[] coefficients =  convertRealList(LLObjectiveFun_llObjFun_coefficients(c));
		double constant =  LLObjectiveFun_llObjFun_const(c);
		return new LinearObjectiveFunction(coefficients, constant);
	}

	private static Relationship convertConstraintType(IConstructor c){
		if(c.getConstructorType() == ConstraintType_leq){
			return Relationship.LEQ;
		} else if(c.getConstructorType() == ConstraintType_eq){
			return Relationship.EQ;
		} else {
			return Relationship.GEQ;
		}
	}

	private static LinearConstraint convertConstraint(IConstructor c) {
		double[] coeffients = convertRealList(LLConstraint_llConstraint_coefficients(c));
		double constant = LLConstraint_llConstraint_const(c);
		Relationship r = convertConstraintType(LLConstraint_llConstraint_ctype(c));
		return new LinearConstraint(coeffients, r, constant);
	}

	public IValue llOptimize(IBool minimize, IBool nonNegative, ISet constraints, IConstructor f) {
		SimplexSolver solver = new SimplexSolver();
		ArrayList<LinearConstraint> constraintsJ =
				new ArrayList<LinearConstraint>(constraints.size());
		for(IValue v : constraints ){
			constraintsJ.add(convertConstraint((IConstructor)v));
		}
		LinearObjectiveFunction fJ = convertLinObjFun(f);
		GoalType goal = minimize.getValue() ? 
						GoalType.MINIMIZE : GoalType.MAXIMIZE;
		IValueFactory vf = values;
		boolean nonNegativeJ =  nonNegative.getValue();
		try {
			RealPointValuePair res = 
					solver.optimize(fJ, constraintsJ, goal,nonNegativeJ);
			return vf.constructor(Maybe.Maybe_just, 
					vf.constructor(
							LLSolution_llSolution, convertToRealList(res.getPoint(), vf), 
							vf.real(res.getValue()) )
					);
		} catch (Exception e) {
			return  vf.constructor(Maybe.Maybe_nothing); 
		}

	}
}
