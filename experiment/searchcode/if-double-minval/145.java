package schemamatchings.meta.algorithms;

import java.util.Iterator;
import java.util.Vector;

import schemamatchings.meta.agr.AbstractGlobalAggregator;
import schemamatchings.meta.agr.AbstractLocalAggregator;
import schemamatchings.meta.match.AbstractMapping;
import schemamatchings.meta.statistics.TAStatistics;

public class SMThersholdAlgorithm extends AbstractMetaAlgorithm implements ThresholdAlgorithm,NonUniformMetaAlgorithm{

  protected SMThersholdAlgorithm() {
      super(true);
      setAlgorithmName("Schema Mapping Threshold Algorithm");
  }//parallel algorithm

   protected SMThersholdAlgorithm(int k,AbstractGlobalAggregator globalArg,AbstractLocalAggregator localArg){
     this();
     this.k = k;
     this.globalArg = globalArg;
     this.localArg = localArg;

   }

  public void runAlgorithm()throws MetaAlgorithmRunningException{
   try{
     if (isUsingStatistics())
       initStatistics();
     super.runAlgorithm();//run algorithms A1,...Am than start parallel algorithm
   }catch(Throwable e){
     e.printStackTrace();
     abnormalTermination();
     throw new MetaAlgorithmRunningException(e.getMessage());
   }
  }


  protected boolean canHalt(){
    //debug
    //System.out.println("checking if can halt..");
    //***
    double[] localMappingScores = new double[numOfMatchingAlgorithms];
    for (int i=0;i<numOfMatchingAlgorithms;i++)
         localMappingScores[i] = localArg.clacArgValue(lastMappings[i],matrixs[i]);
    double thresholdTA = globalArg.clacArgValue(localMappingScores);
    boolean canHalt = isExistKMappingWiteScore(thresholdTA);
    if (isUsingStatistics())
         ((TAStatistics)statistics).setCurrentTopKMappings(currentGeneratedTopK());
    return (thresholdTA == 0 || canHalt || stopReached() || checkInfiniteTermination());//old version -> canHalt
  }


  public int progressWith() {
    int with = 0;
    double minVal = Double.MAX_VALUE;
    for (int i = 0; i < numOfMatchingAlgorithms; i++) {
      if (heuristicValues[i] < minVal) {
        with = i;
        minVal = heuristicValues[i];
      }
    }
    //debugString.append(
    if (debugMode)
    System.out.println("Progress with:"+with+" Heuristic value:"+heuristicValues[with]+"\n");
    return with;
  }




  public synchronized void notifyNewMapping(int tid,AbstractMapping mapping){

    //perform local and global aggerators calculation
    //first check if not seen yet this mappings in one of the sorted lists
    newMapping(tid,mapping);
    ///***
    //remeber the last mapping generated by TKM in tid
    lastMappings[tid] = mapping;
    //System.out.println("calling "+tid+" to wait");
    maThreads[tid].waitForNextStep();
    synchronizer++;
  if (synchronizer == numOfMatchingAlgorithms){
    synchronizer = 0;
    if (isUsingStatistics())
      statistics.increaseIterationsCount();
    currentStep++;
    //(b) check halt condition
    if (canHalt()){
      for (int i=0;i<numOfMatchingAlgorithms;i++){
        maThreads[i].die();
      }
      //run halt
      finished();
    }
    else{
      for (int i=0;i<numOfMatchingAlgorithms;i++){
        //System.out.println("calling "+i+" to continue");
        maThreads[i].continueNextStep();
      }
    }
  }
  }

  public synchronized void notifyNewHeuristicMappings(int tid,AbstractMapping alpha, Vector betas) {
    double[] localMappingScores = new double[numOfMatchingAlgorithms];
    if (lastTidProgressedWith == tid){
      double alphaVal, maxBetaVal = Double.MIN_VALUE, localVal;
      alphaVal = localArg.clacArgValue(alpha, matrixs[tid]);
      Iterator it = betas.iterator();
      while (it.hasNext()) {
        localVal = localArg.clacArgValue((AbstractMapping) it.next(),
            matrixs[tid]);
        maxBetaVal = maxBetaVal > localVal ? maxBetaVal : localVal;
      }
      //System.out.println("tid:"+tid+" beta val:"+maxBetaVal);

      lastTidHeuristicXi[tid] = Math.max(maxBetaVal, alphaVal); //save heoristic valuation - epsilon

    }

    for (int i = 0; i < numOfMatchingAlgorithms; i++)
      localMappingScores[i] = (i == tid) ? lastTidHeuristicXi[tid] :localArg.clacArgValue(lastMappings[i], matrixs[i]);
    //added 8/2/04
    lastLocalXiScores = localMappingScores;
    //end added
    heuristicValues[tid] = globalArg.clacArgValue(lastLocalXiScores);

    //debug  debugString.append(
    //if (lastTidProgressedWith != -1)
    if (debugMode){
      System.out.print("tid:"+tid+" delta:"+(lastTidHeuristicXi[tid] - localArg.clacArgValue(lastMappings[tid],matrixs[tid]))+"\n");
      System.out.println("tid:"+tid+" TA value:"+heuristicValues[tid]);
    }

    maThreads[tid].waitForNextStep();
    synchronizer++;
    if (synchronizer == numOfMatchingAlgorithms) {
      synchronizer = 0;
      if (isUsingStatistics())
        statistics.increaseIterationsCount();
      currentStep++;
      //progress non uniformly with one tkm
      int progressWith = progressWith();
      lastTidProgressedWith = progressWith;
      try {
        //debug
        //System.out.println("continue with:"+progressWith);
        //****
        lastMappings[progressWith] = maThreads[progressWith].continueInOneStep();
      }
      catch (Throwable e) {
        e.printStackTrace();
      }
      //(a)
      newMapping(tid,lastMappings[progressWith]);
      //(b) check halt condition
      if (canHalt()) {
        for (int i = 0; i < numOfMatchingAlgorithms; i++) {
          maThreads[i].die();
        }
        //run halt
        finished();
      }
      else {
        for (int i = 0; i < numOfMatchingAlgorithms; i++) {
          //System.out.println("calling "+i+" to continue");
          maThreads[i].continueNextStep();
        }
      }
    }
  }


  protected void initStatistics(){
    super.initStatistics();
    ((TAStatistics)statistics).setThreadsCount(numOfMatchingAlgorithms);
  }


  public  void useStatistics(){
     statistics = new TAStatistics(this,s1.getName(),s2.getName());
  }

  public void reset(){

  }
}

