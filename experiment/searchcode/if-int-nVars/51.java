/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *  
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *  
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Expression.java
 * Created: March 13, 2000
 * By: Luke Evans
 */
package org.openquark.cal.compiler;

import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

import org.openquark.cal.compiler.ExpressionAnalyzer.Visitor;
import org.openquark.cal.internal.serialization.ModuleSerializationTags;
import org.openquark.cal.internal.serialization.RecordInputStream;
import org.openquark.cal.internal.serialization.RecordOutputStream;
import org.openquark.cal.internal.serialization.RecordInputStream.RecordHeaderInfo;
import org.openquark.cal.module.Cal.Core.CAL_Prelude;



/**
 * Warning- this class should only be used by the CAL compiler implementation. It is not part of the
 * external API of the CAL platform.
 * <p>
 * Expressions are generated by the compiler after static analysis, typechecking, lambda lifting,
 * overload resolution etc. They are an intermediate form used by machines to generate actual
 * executable code.
 * 
 * @author LWE
 */
public abstract class Expression {    

    /**
     * The array of possible record tags used in calls to {@link RecordInputStream#findRecord(short[])} by
     * the {@link #load} method.
     */
    private static final short[] EXPRESSION_RECORD_TAGS = new short[] {
        ModuleSerializationTags.EXPRESSION_APPL,
        ModuleSerializationTags.EXPRESSION_CAST,
        ModuleSerializationTags.EXPRESSION_DATACONS_SELECTION,
        ModuleSerializationTags.EXPRESSION_ERROR_INFO,
        ModuleSerializationTags.EXPRESSION_LET_REC,
        ModuleSerializationTags.EXPRESSION_LET_NONREC,
        ModuleSerializationTags.EXPRESSION_LITERAL,
        ModuleSerializationTags.EXPRESSION_PACKCONS,
        ModuleSerializationTags.EXPRESSION_RECORD_CASE,
        ModuleSerializationTags.EXPRESSION_RECORD_EXTENSION,
        ModuleSerializationTags.EXPRESSION_RECORD_SELECTION,
        ModuleSerializationTags.EXPRESSION_SWITCH,
        ModuleSerializationTags.EXPRESSION_TAIL_RECURSIVE_CALL,
        ModuleSerializationTags.EXPRESSION_VAR,
        ModuleSerializationTags.EXPRESSION_RECORD_UPDATE
    };
    
    /**
     * ErrorInfos are generated by the compiler during the process of compiling. They are used to
     * contain information about the position in the source code of a call to error, undefined or assert.
     * 
     * ErrorInfos are immutable value objects created by the compiler from CAL source, or other
     * compiler input forms. They are not directly created by clients.
     * 
     * @author Greg McClement
     */
    
    public static final class ErrorInfo extends Expression {
        
        private static final int serializationSchema = 0;
        
        private final QualifiedName topLevelFunctionName;
        private final int line;
        private final int column;

        ErrorInfo(QualifiedName topLevelFunctionName, int line, int column) {
            if (topLevelFunctionName == null) {
                throw new IllegalArgumentException("Expression.ErrorInfo.ErrorInfo(QualifiedName, int, int): topLevelFunctionName may not be null.");
            }

            this.topLevelFunctionName = topLevelFunctionName;
            
            this.line = line;
            this.column = column;
        }

        @Override
        public String toString() {
            return "EErr " + topLevelFunctionName + ": line " + line + " column " + column;
        }
        
        public QualifiedName getTopLevelFunctionName(){
            return topLevelFunctionName;
        }
        
        public int getLine(){
            return line;
        }
        
        public int getColumn(){
            return column;
        }

        /** 
         * This is a programmatically added object so I didn't think that
         * the visitor would need to see it. 
         * @param v
        */ 
        
        @Override
        void walk(Visitor v) {
        }
        
        /**
         * {@inheritDoc}
         */
        @Override
        public <T, R> R accept(ExpressionVisitor<T, R> visitor, T arg) {
            return visitor.visitErrorInfo(this, arg);
        }     
        
        
        /**
         * Write this instance of ErrorInfo to the RecordOutputStream.
         * @param s
         * @throws IOException
         */
        @Override
        final void write (RecordOutputStream s) throws IOException {
            s.startRecord(ModuleSerializationTags.EXPRESSION_ERROR_INFO, serializationSchema);
            s.writeQualifiedName(topLevelFunctionName);
            s.writeIntCompressed(line);
            s.writeIntCompressed(column);
            s.endRecord ();
        }      
        
        /**
         * Load an instance of ErrorInfo from a RecordInputStream
         * @param s
         * @param schema
         * @param mti
         * @param msgLogger the logger to which to log deserialization messages.
         * @return an instance of ErrorInfo
         * @throws IOException
         */
        public static ErrorInfo load (RecordInputStream s, int schema, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
            DeserializationHelper.checkSerializationSchema(schema, serializationSchema, mti.getModuleName(), "Expression.ErrorInfo", msgLogger);
            
            QualifiedName topLevelFunctionName = s.readQualifiedName();
            int line = s.readIntCompressed();
            int column = s.readIntCompressed();
            s.skipRestOfRecord();
            
            return new ErrorInfo (topLevelFunctionName, line, column);
        }
    }
    
    /**
     * A literal. Contains a literal as recognised by the parser.
     */
    public static final class Literal extends Expression {
        private static final int serializationSchema = 0;
        private static final int LITERAL_TYPE_CHARACTER = 0;
        private static final int LITERAL_TYPE_BOOLEAN = 1;
        private static final int LITERAL_TYPE_INTEGER = 2;
        private static final int LITERAL_TYPE_DOUBLE = 3;
        private static final int LITERAL_TYPE_BYTE = 4;
        private static final int LITERAL_TYPE_SHORT = 5;
        private static final int LITERAL_TYPE_FLOAT = 6;
        private static final int LITERAL_TYPE_LONG = 7;
        private static final int LITERAL_TYPE_STRING = 8;
        private static final int LITERAL_TYPE_BIG_INTEGER = 9;        

        private final Object literal;
        
        Literal(Object literal) {
            if (literal == null) {
                throw new NullPointerException("Expression.Literal constructor: the argument 'literal' cannot be null.");
            }
            
            this.literal = literal;
        }
        
        @Override
        public String toString() {
            return "ELit " + literal;
        }
        
        public Object getLiteral() {
            return literal;
        }
        
        @Override
        void walk(Visitor v) {
            v.enterLiteral(this);
            v.exitLiteral(this);
        }       

        /**
         * {@inheritDoc}
         */
        @Override
        public <T, R> R accept(ExpressionVisitor<T, R> visitor, T arg) {
            return visitor.visitLiteral(this, arg);
        }     
        
        
        /**
         * Write this instance of Literal to the RecordOutputStream.
         * @param s
         * @throws IOException
         */
        @Override
        final void write (RecordOutputStream s) throws IOException {
            s.startRecord (ModuleSerializationTags.EXPRESSION_LITERAL, serializationSchema);
            Class<? extends Object> valueClass = literal.getClass();
            if (valueClass == java.lang.Character.class) {
                s.writeByte(LITERAL_TYPE_CHARACTER);
                s.writeChar(((Character)literal).charValue());
            } else if (valueClass == java.lang.Boolean.class) {
                s.writeByte(LITERAL_TYPE_BOOLEAN);
                s.writeBoolean(((Boolean)literal).booleanValue());
            } else if (valueClass == java.lang.Integer.class) {
                s.writeByte(LITERAL_TYPE_INTEGER);
                s.writeInt(((Integer)literal).intValue());
            } else if (valueClass == java.lang.Double.class) {
                s.writeByte(LITERAL_TYPE_DOUBLE);
                s.writeDouble(((Double)literal).doubleValue());
            } else if (valueClass == java.lang.Byte.class) {
                s.writeByte(LITERAL_TYPE_BYTE);
                s.writeByte(((Byte)literal).byteValue());
            } else if (valueClass == java.lang.Short.class) {
                s.writeByte(LITERAL_TYPE_SHORT);
                s.writeShort(((Short)literal).shortValue());
            } else if (valueClass == java.lang.Float.class) {
                s.writeByte(LITERAL_TYPE_FLOAT);
                s.writeFloat(((Float)literal).floatValue());
            } else if (valueClass == java.lang.Long.class) {
                s.writeByte(LITERAL_TYPE_LONG);
                s.writeLong(((Long)literal).longValue());
            } else if (valueClass == String.class) {
                s.writeByte(LITERAL_TYPE_STRING);
                s.writeUTF((String)literal);
            } else if (valueClass == BigInteger.class) {
                s.writeByte(LITERAL_TYPE_BIG_INTEGER);
                String ds = ((BigInteger)literal).toString();
                s.writeUTF(ds);
            }  else {
                throw new IOException ("Attemp to write unhandled literal value of type: " + literal.getClass().getName());
            }
            
            s.endRecord ();
        }   
        
        /**
         * Load an instance of Literal from a RecordInputStream
         * @param s
         * @param schema
         * @param mti
         * @param msgLogger the logger to which to log deserialization messages.
         * @return an instance of Literal
         * @throws IOException
         */
        public static Literal load (RecordInputStream s, int schema, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
            DeserializationHelper.checkSerializationSchema(schema, serializationSchema, mti.getModuleName(), "Expression.Literal", msgLogger);

            byte litType = s.readByte();
            Object litVal = null;
            
            switch (litType) {
            case LITERAL_TYPE_CHARACTER: {
                char c = s.readChar();
                litVal = Character.valueOf(c);
                break;
            }
            case LITERAL_TYPE_BOOLEAN: {
                boolean b = s.readBoolean();
                litVal = Boolean.valueOf(b);
                break;
            }
            case LITERAL_TYPE_INTEGER: {
                int i = s.readInt();
                litVal = Integer.valueOf(i);
                break;
            }
            case LITERAL_TYPE_DOUBLE: {
                double d = s.readDouble();
                litVal = Double.valueOf(d);
                break;
            }
            case LITERAL_TYPE_BYTE: {
                byte b = s.readByte();
                litVal = Byte.valueOf(b);
                break;
            }
            case LITERAL_TYPE_SHORT: {
                short sh = s.readShort();
                litVal = Short.valueOf(sh);
                break;
            }
            case LITERAL_TYPE_FLOAT: {
                float f = s.readFloat();
                litVal = Float.valueOf(f);
                break;
            }
            case LITERAL_TYPE_LONG: {
                long l = s.readLong();
                litVal = Long.valueOf(l);
                break;
            }
            case LITERAL_TYPE_STRING: {
                String st = s.readUTF();
                litVal = st;
                break;
            }
            case LITERAL_TYPE_BIG_INTEGER: {
                String st = s.readUTF();
                litVal = (new BigInteger (st));
                break;
            }
            default: {
                throw new IOException ("Attempt to read unhandled literal value with type tag " + litType + ".");
            }
            }
            
            s.skipRestOfRecord();
            return new Literal (litVal);
        }
        
    }

    /**
     * A variable. Contains the unique name of the variable. Note, Expression.Var
     * holds both variables (in the sense of CAL syntax) and data constructors. It
     * is a low level class for use during code generation, and so this distinction
     * is blurred.
     */
    public static final class Var extends Expression {
        private static final int serializationSchema = 0;

        private final QualifiedName name;
        
        /** 
         * this field will be non-null if the entity corresponds to a top-level entity in the
         * ModuleTypeInfo. For example, for a foreign function or a data constructor.
         * However, for local functions or local variables, it will be null.         
         */                                          
        private final FunctionalAgent functionalAgent;
        
        /**
         * Will only be non-null in the case of the Prelude.error function.
         */
        private final ErrorInfo errorInfo;
             
        /** 
         * Do not use this constructor for entities that correspond to top-level CAL entities
         * present in the ModuleTypeInfo e.g. foreign functions, data constructors, etc.
         * @param name
         */
        Var(QualifiedName name) {
            if (name == null) {
                throw new NullPointerException("Expression.Var constructor: the argument 'name' cannot be null.");
            }
            
            String s = name.getUnqualifiedName ();
            if (Character.isUpperCase (s.charAt(0))) {                    
                throw new IllegalArgumentException ("Expression.Var constructor: do not call this constructor for data constructors!");
            } 
            
            //todoBI it would be nice to put this in, but it doesn't hold for adjuncts at the moment...
//            if (s.indexOf('$') == -1 && !s.equals("if")) {
//               //System.out.println("Expression.Var constructor- top level name without FunctionalAgent " + name);
//               //throw new IllegalArgumentException ("Expression.Var constructor: do not call this constructor for top-level entities!");
//            }                 
                                   
            this.name = name;
            this.functionalAgent = null;
            this.errorInfo = null;
        }
        
        /**
         * Special constructor for the Prelude.error function.
         * @param errorInfo
         */
        Var(ErrorInfo errorInfo) {  
            if (errorInfo == null) {
                throw new NullPointerException("Expression.Var errorInfo cannot be null.");
            }
            this.name = CAL_Prelude.Functions.error;
            this.functionalAgent = null;
            this.errorInfo = errorInfo;
        }
        
        Var(FunctionalAgent functionalAgent) {
            this.name = functionalAgent.getName();
            this.functionalAgent = functionalAgent; 
            this.errorInfo = null;
        }
        
        /**
         * private constructor for use in loading serialized format.      
         * @param name
         * @param functionalAgent
         * @param errorInfo   
         */
        private Var (QualifiedName name, FunctionalAgent functionalAgent, ErrorInfo errorInfo) {
            this.name = name;
            this.functionalAgent = functionalAgent;
            this.errorInfo = errorInfo;
        }
        @Override
        public String toString() {
            return "EVar \"" + name.getQualifiedName() + "\"";
        }
        
        public QualifiedName getName() {
            return name;
        }
        
        public FunctionalAgent getFunctionalAgent (){
            return functionalAgent;
        }
        
        public ErrorInfo getErrorInfo(){ 
            return errorInfo;
        }
        
        public ForeignFunctionInfo getForeignFunctionInfo() {            
            if (functionalAgent != null && functionalAgent instanceof Function)  {
                return ((Function)functionalAgent).getForeignFunctionInfo();
            }
                
            return null;
        }               
        
        public DataConstructor getDataConstructor() {
            if (functionalAgent != null && functionalAgent instanceof DataConstructor) {
                return (DataConstructor)functionalAgent;
            }
                
            return null;
        }
        
        /**
         * {@inheritDoc}
         */
        @Override
        public <T, R> R accept(ExpressionVisitor<T, R> visitor, T arg) {
            return visitor.visitVar(this, arg);
        }     
        
        @Override
        void walk(Visitor v) {
            v.enterVar(this);
            v.exitVar(this);
        }
        
        /**
         * Write this instance of Var to the RecordOutputStream.
         * @param s
         * @throws IOException
         */
        @Override
        void write (RecordOutputStream s) throws IOException {
            s.startRecord (ModuleSerializationTags.EXPRESSION_VAR, serializationSchema);
            boolean flags[] = new boolean [3];
            flags[0] = name != null;
            flags[1] = functionalAgent != null;
            flags[2] = errorInfo != null;
            s.writeByte(RecordOutputStream.booleanArrayToBitArray(flags)[0]);
            
            if (flags[0]) {
                s.writeQualifiedName(name);
            }
            
            if (flags[1]) {
                s.writeQualifiedName(functionalAgent.getName());
            }
            
            if (flags[2]) {
                errorInfo.write(s);
            }
            s.endRecord ();
        }
        
        /**
         * Load an instance of Var from a RecordInputStream
         * @param s
         * @param schema
         * @param mti
         * @param msgLogger the logger to which to log deserialization messages.
         * @return an instance of Var
         * @throws IOException
         */
        public static Var load (RecordInputStream s, int schema, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
            DeserializationHelper.checkSerializationSchema(schema, serializationSchema, mti.getModuleName(), "Expression.Var", msgLogger);
            byte flagByte = s.readByte();
            
            QualifiedName qn = null;
            if (RecordInputStream.booleanFromBitArray(flagByte, 0)) {
                qn = s.readQualifiedName();
            }
            
            QualifiedName entityName = null;
            if (RecordInputStream.booleanFromBitArray(flagByte, 1)) {
                entityName = s.readQualifiedName();
            }
            
            ErrorInfo ei = null;
            if (RecordInputStream.booleanFromBitArray(flagByte, 2)) {
                ei = (ErrorInfo)Expression.load (s, mti, msgLogger);
            }
            
            s.skipRestOfRecord();
            
            FunctionalAgent ee = null;
            if (entityName != null) {
                ModuleTypeInfo typeInfo = mti.getModule().findModule(entityName.getModuleName()).getModuleTypeInfo();
                ee = typeInfo.getFunctionalAgent(entityName.getUnqualifiedName());
                if (ee == null) {
                    throw new IOException ("Unable to find FunctionalAgent " + entityName + " while loading Expression.Var.");
                }
            }
            
            return new Var (qn, ee, ei); 
        }        

    }

    /**
     * An application.  Applies expr1 to expr2.
     */
    public static final class Appl extends Expression {
        
        private static final int serializationSchema = 0;
        
        private Expression expr1;
        private Expression expr2;
        
        Appl(Expression expr1, Expression expr2) {
            
            if (expr1 == null || expr2 == null) {
                throw new NullPointerException("Expression.Appl constructor: the arguments 'expr1' and 'expr2' cannot be null.");
            }
            
            this.expr1 = expr1;
            this.expr2 = expr2;
        }
        
        @Override
        public String toString() {
            return "EAp (" + expr1 + ") (" + expr2 + ")";
        }
        
        public Expression getE1() {
            return expr1;
        }
        
        public Expression getE2() {
            return expr2;
        }
        
        void setE1 (Expression e) {
            if (e == null) {
                throw new IllegalArgumentException("Attempt to set null E1 in Expression.Appl");
            }
            expr1 = e;
        }
        
        void setE2 (Expression e) {
            if (e == null) {
                throw new IllegalArgumentException("Attempt to set null E2 in Expression.Appl");
            }
            expr2 = e;
        }
        
        @Override
        void walk(Visitor v) {
            v.enterAppl(this);
            
            expr1.walk (v);
            expr2.walk (v); 
            
            v.exitAppl(this);
        }
        
        /**
         * {@inheritDoc}
         */
        @Override
        public <T, R> R accept(ExpressionVisitor<T, R> visitor, T arg) {
            return visitor.visitApplication(this, arg);
        }     
        
        /**
         * Write this instance of Appl to the RecordOutputStream.
         * @param s
         * @throws IOException
         */
        @Override
        final void write (RecordOutputStream s) throws IOException {
            s.startRecord (ModuleSerializationTags.EXPRESSION_APPL, serializationSchema);
            expr1.write (s);
            expr2.write (s);
            s.endRecord ();
        }       
        
        /**
         * Load an instance of Appl from a RecordInputStream
         * @param s
         * @param schema
         * @param mti
         * @param msgLogger the logger to which to log deserialization messages.
         * @return an instance of Appl
         * @throws IOException
         */
        public static Appl load (RecordInputStream s, int schema, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
            DeserializationHelper.checkSerializationSchema(schema, serializationSchema, mti.getModuleName(), "Expression.Appl", msgLogger);
            
            Expression expr1 = Expression.load (s, mti, msgLogger);
            Expression expr2 = Expression.load (s, mti, msgLogger);
            
            s.skipRestOfRecord ();
            
            return new Appl (expr1, expr2);
        }
    }

    /**
     * Base class for recursive or non-recursive lets.
     */
    public abstract static class Let extends Expression {
        
        private static final int serializationSchema = 0;
        
        private Expression body;
        
        Let(Expression body) {
            
            if (body == null) {
                throw new NullPointerException("Expression.Let constructor: the argument 'body' cannot be null.");
            }
                       
            this.body = body;
        }  
        
        /**
         * Default constructor for use by serialization code.
         */
        Let () {}
        
        
        public abstract LetDefn[] getDefns();
        
        abstract void setDefns(LetDefn[] defns);
        
        public Expression getBody() {
            return body;
        }
        
        void setBody (Expression e) {
            if (e == null) {
                throw new IllegalArgumentException("Attempt to set null body in Expression.Let");
            }
            body = e;
        }
        
        /**
         * Write this instance of Let to the RecordOutputStream.
         * @param s
         * @throws IOException
         */
        void writeContent (RecordOutputStream s) throws IOException {
            s.startRecord(ModuleSerializationTags.EXPRESSION_LET, serializationSchema);
            body.write (s);
            s.endRecord ();
        }
        
        /**
         * Load an instance of ErrorInfo from a RecordInputStream
         * @param s
         * @param mti
         * @param msgLogger the logger to which to log deserialization messages.
         * @throws IOException
         */
        private void readContent (RecordInputStream s, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
            RecordHeaderInfo rhi = s.findRecord(ModuleSerializationTags.EXPRESSION_LET);
            if (rhi == null) {
                throw new IOException("Unable to find Expression.Let record header.");
            }
            DeserializationHelper.checkSerializationSchema(rhi.getSchema(), serializationSchema, mti.getModuleName(), "Expression.Let", msgLogger);

            Expression expr = Expression.load (s, mti, msgLogger);
            
            this.body = expr;
            
            s.skipRestOfRecord();
        }                
        
        public static final class LetDefn {
            private static final int serializationSchema = 0;
            
            private final String var;
            private Expression expr;
            /**
             * The type of the variable being defined in this let definition.
             */
            private TypeExpr varType;
            int useCount;

            LetDefn(String var, Expression expr, TypeExpr varType) {
                
                if (var == null || expr == null || varType == null) {
                    throw new NullPointerException("Expression.Let.LetDefn constructor: the arguments 'var' and 'expr' cannot be null.");
                }
                
                this.var = var;
                this.expr = expr;
                this.varType = varType;
            }

            public String getVar() {
                return var;
            }

            public Expression getExpr() {
                return expr;
            }
            
            public TypeExpr getVarType() {
                return varType;
            }
            
            void setExpr (Expression e) {
                if (e == null) {
                    throw new IllegalArgumentException("Attempt to set null expr in Expression.Let.LetDefn");
                }
                expr = e;
            }
            
            public int getUseCount ()  {
                return useCount;
            }
            
            void incrementUseCount () {
                useCount++;
            }
            void setUseCount (int i) {
                this.useCount = i;
            }
            
            @Override
            public String toString() {
                return var + ":" + expr;
            }

            /**
             * 
             * @param visitor
             * @param arg
             * @return the result of visiting this LetDefn
             */
            public <T, R> R accept(ExpressionVisitor<T, R> visitor, T arg) {
                return visitor.visitLetDefn(this, arg);
            }  
            
            /**
             * Write this instance of LetDefn to the RecordOutputStream.
             * @param s
             * @throws IOException
             */
            final void write (RecordOutputStream s) throws IOException {
                s.startRecord(ModuleSerializationTags.EXPRESSION_LET_DEFN, serializationSchema);
                s.writeUTF (var);
                s.writeInt(useCount);
                expr.write (s);
                varType.write(s);
                s.endRecord ();
            }
            
            /**
             * Load an instance of ErrorInfo from a RecordInputStream
             * @param s
             * @param mti
             * @param msgLogger
             * @return an instance of ErrorInfo
             * @throws IOException
             */
            public static LetDefn load (RecordInputStream s, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
                RecordHeaderInfo rhi = s.findRecord(ModuleSerializationTags.EXPRESSION_LET_DEFN);
                if (rhi == null) {
                    throw new IOException ("Unable to find record header for LetDefn");
                }
                DeserializationHelper.checkSerializationSchema(rhi.getSchema(), serializationSchema, mti.getModuleName(), "Expression.Let.LetDefn", msgLogger);
                
                String var = s.readUTF ();
                int useCount = s.readInt ();
                Expression expr = Expression.load(s, mti, msgLogger);
                TypeExpr varType = TypeExpr.load(s, mti, msgLogger);
                s.skipRestOfRecord();
                
                LetDefn letDef =  new LetDefn (var, expr, varType);
                letDef.setUseCount (useCount);
                return letDef;
            }            
        }
    }
    
    /**
     * Used to represent recursive let bindings. The compiler guarantees that all the definitions
     * appearing in the block are mutually recursive and cannot be split into subgroups.
     * 
     * @author Bo Ilic
     */
    public static final class LetRec extends Let {
        private static final int serializationSchema = 0;

        private LetDefn[] defns;

        LetRec(LetDefn[] defns, Expression body) {
            super(body);
            if (defns == null) {
                throw new NullPointerException();
            }
            if (defns.length == 0) {
                throw new IllegalArgumentException();
            }

            this.defns = defns;
        }

        /**
         * Default constructor for use by serialization code.
         */
        LetRec () {}
        
        
        @Override
        public LetDefn[] getDefns() {
            return defns;
        }

        @Override
        void setDefns(LetDefn[] defns) {
            if (defns == null) {
                throw new IllegalArgumentException("Attempt to set null defns in Expression.LetRec");
            }
            this.defns = defns;
        }
        
        @Override
        public String toString() {
            return "ELetRec (" + defnsString() + ") (" + super.body + ")";
        }

        private String defnsString() {
            StringBuilder sb = new StringBuilder();
            // For each definition, add some description
            int defnsLength = defns.length;
            for (int i = 0; i < defnsLength; i++) {
                LetDefn ld = defns[i];
                if (i > 0) {
                    sb.append(',');
                }
                sb.append(ld);               
            }
            return sb.toString();
        }
        
        @Override
        void walk(Visitor v) {
            v.enterLetRec(this);
            
            for (int i = 0; i < defns.length; ++i) {
                v.enterLetRecDef(defns[i]);
                defns[i].getExpr().walk(v);
                v.exitLetRecDef(defns[i]);
            }
            
            getBody().walk(v);   
            v.exitLetRec(this);
        }
        
        /**
         * {@inheritDoc}
         */
        @Override
        public <T, R> R accept(ExpressionVisitor<T, R> visitor, T arg) {
            return visitor.visitLetRec(this, arg);
        }     
        
        
        /**
         * Write this instance of LetRec to the RecordOutputStream.
         * @param s
         * @throws IOException
         */
        @Override
        final void write (RecordOutputStream s) throws IOException {
            s.startRecord (ModuleSerializationTags.EXPRESSION_LET_REC, serializationSchema);
            super.writeContent (s);
            s.writeIntCompressed(defns.length);
            for (int i = 0; i < defns.length; ++i) {
                defns[i].write (s);
            }
            s.endRecord ();
        }        
        
        /**
         * Load an instance of LetRec from a RecordInputStream
         * @param s
         * @param schema
         * @param mti
         * @param msgLogger the logger to which to log deserialization messages.
         * @return an instance of LetRec
         * @throws IOException
         */
        public static LetRec load (RecordInputStream s, int schema, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
            DeserializationHelper.checkSerializationSchema(schema, serializationSchema, mti.getModuleName(), "Expression.LetRec", msgLogger);
            
            LetRec lnr = new LetRec ();
            lnr.readContent (s, mti, msgLogger);
            return lnr;
        }
        
        private void readContent (RecordInputStream s, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
            super.readContent (s, mti, msgLogger);
            int nVars = s.readIntCompressed();
            defns = new LetDefn[nVars];
            for (int i = 0; i < nVars; ++i) {
                defns[i] = LetDefn.load(s, mti, msgLogger);
            }
            
            s.skipRestOfRecord();
        }        

    }
    
    /**
     * Used to represent non-recursive let definitions. If the definition is of the form "let x = e1 in e2" then
     * the compiler guarantees that x does not occur in e1. Also this is a *minimal* grouping so there will only
     * ever be 1 definition in a LetNonRec.
     * 
     * @author Bo Ilic
     */
    public static final class LetNonRec extends Let {
        private static final int serializationSchema = 0;
        
        private LetDefn defn;
        
        LetNonRec (LetDefn defn, Expression body) {
            super(body);
            if (defn == null) {
                throw new NullPointerException();
            }
            
            this.defn = defn;
        }
        
        private LetNonRec () {}
        
        @Override
        public LetDefn[] getDefns() {
            return new LetDefn[] {defn};
        }
        
        @Override
        void setDefns(LetDefn[] defns) {
            if (defns == null || defns[0] == null) {
                throw new IllegalArgumentException("Attempt to set null defn in Expression.LetNonRec");
            }
            
            defn = defns[0];
        }
        
        public LetDefn getDefn() {
            return defn;             
        }
        
        @Override
        public String toString() {
            return "ELetNonRec (" + defn + ") (" + super.body + ")";
        }
        
        @Override
        void walk(Visitor v) {
            v.enterLetNonRec(this);
            
            v.enterLetNonRecDef(defn);
            defn.getExpr().walk(v); 
            v.exitLetNonRecDef(defn);
            
            getBody().walk(v);
            v.exitLetNonRec(this);
        }
        
        /**
         * {@inheritDoc}
         */
        @Override
        public <T, R> R accept(ExpressionVisitor<T, R> visitor, T arg) {
            return visitor.visitLetNonRec(this, arg);
        }     
        
        
        /**
         * Write this instance of LetNonRec to the RecordOutputStream.
         * @param s
         * @throws IOException
         */
        @Override
        final void write (RecordOutputStream s) throws IOException {
            s.startRecord (ModuleSerializationTags.EXPRESSION_LET_NONREC, serializationSchema);
            super.writeContent (s);
            defn.write (s);
            s.endRecord ();
        }      
        
        /**
         * Load an instance of LetNonRec from a RecordInputStream
         * @param s
         * @param schema
         * @param mti
         * @param msgLogger the logger to which to log deserialization messages.
         * @return an instance of LetNonRec
         * @throws IOException
         */
        public static LetNonRec load (RecordInputStream s, int schema, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
            DeserializationHelper.checkSerializationSchema(schema, serializationSchema, mti.getModuleName(), "Expression.LetNonRec", msgLogger);
            
            LetNonRec lnr = new LetNonRec ();
            lnr.readContent (s, mti, msgLogger);
            return lnr;
        }
        
        private void readContent (RecordInputStream s, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
            super.readContent (s, mti, msgLogger);
            defn = LetDefn.load (s, mti, msgLogger);
            s.skipRestOfRecord();
        }        
    }

    /**
     * A constructor.
     * 
     * Note: this does not correspond to the Cons nodes as used in the compiler (which are used
     * for any symbol in CAL which starts with an upper case letter such as a class method name, module name, data
     * constructor name. Rather, they are used for creating special functions during code generation, one for each
     * data constructor.
     */
    public static final class PackCons extends Expression {
        private static final int serializationSchema = 0;

        private final DataConstructor dataConstructor;
      
        PackCons(DataConstructor dataConstructor) {
            if (dataConstructor == null) {
                throw new NullPointerException("Expression.Cons constructor: the argument 'dataConstructor' cannot be null.");
            }
            
            this.dataConstructor = dataConstructor;
            
            //System.out.println(toString());
        }
        
        @Override
        public String toString() {
            return "ECons (" + dataConstructor + ")";
        }
        
        public DataConstructor getDataConstructor() {
            return dataConstructor;
        } 
        
        @Override
        void walk(Visitor v) {
            v.enterPackCons(this);
            v.exitPackCons(this);
        }
        
        /**
         * {@inheritDoc}
         */
        @Override
        public <T, R> R accept(ExpressionVisitor<T, R> visitor, T arg) {
            return visitor.visitPackCons(this, arg);
        }     
        
        /**
         * Write this instance of PackCons to the RecordOutputStream.
         * @param s
         * @throws IOException
         */
        @Override
        final void write (RecordOutputStream s) throws IOException {
            s.startRecord (ModuleSerializationTags.EXPRESSION_PACKCONS, serializationSchema);
            s.writeQualifiedName(dataConstructor.getName());
            s.endRecord ();
        }  
        
        /**
         * Load an instance of PackCons from a RecordInputStream
         * @param s
         * @param schema
         * @param mti
         * @param msgLogger the logger to which to log deserialization messages.
         * @return an instance of PackCons
         * @throws IOException
         */
        public static PackCons load (RecordInputStream s, int schema, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
            DeserializationHelper.checkSerializationSchema(schema, serializationSchema, mti.getModuleName(), "Expression.PackCons", msgLogger);
            QualifiedName qn = s.readQualifiedName();
            s.skipRestOfRecord();
            
            DataConstructor dc = mti.getReachableDataConstructor(qn);
            if (dc == null) {
                throw new IOException ("Unable to find data constructor " + qn + " while loading Expression.PackCons.");
            }
            
            return new PackCons (dc);
        }        

    }

    /**
     * A switch.  Switches to one of alts depending on swExpr.
     */
    public static final class Switch extends Expression {
        private static final int serializationSchema = 0;

        private Expression swExpr;
        private final SwitchAlt[] alts;
        private final ErrorInfo errorInfo;
        
        Switch(Expression swExpr, SwitchAlt[] alts, ErrorInfo errorInfo) {
            
            if (swExpr == null || alts == null) {
                throw new NullPointerException("Expression.Switch constructor: the arguments 'swExpr' and 'alts' cannot be null.");
            }
            
            this.swExpr = swExpr;
            this.alts = alts;
            this.errorInfo = errorInfo;
        }
        
        /**
         * @return The error information that identifies the position in the source of the expression. Maybe null. 
         */
        public ErrorInfo getErrorInfo(){ 
            return errorInfo;
        }
        
        @Override
        public String toString() {
            StringBuilder out = new StringBuilder("ESwitch (");
            out.append(swExpr.toString());
            out.append(", [");
            for (int i = 0; i < alts.length; ++i) {
                if (i > 0) {
                    out.append(", ");
                }
                out.append(alts[i].toString());
            }
            out.append("])");
            return out.toString();
            //return "ESwitch (" + swExpr + "," + alts + ")";
        }
        
        public Expression getSwitchExpr() {
            return swExpr;
        }
        
        void setSwitchExpr (Expression e) {
            if (e == null) {
                throw new IllegalArgumentException("Attempt to set null swExpr in Expression.Switch");
            }
            swExpr = e;
        }
        
        public SwitchAlt[] getAlts() {
            return alts;
        }
        
        public SwitchAlt getAlt(int i) {
            return alts[i];
        }
        
        public int getNAlts() {
            return alts.length;
        }
        
        public boolean hasDefaultAlt() {
            for (int i = 0; i < alts.length; ++i) {
                if (alts[i].isDefaultAlt()) {
                    return true;
                }
            }
            return false;
        }
        
        public static abstract class SwitchAlt {
            private static final int serializationSchema = 0;
            private static final byte ALT_TAG_TYPE_INTEGER = 0;
            private static final byte ALT_TAG_TYPE_BOOLEAN = 1;
            private static final byte ALT_TAG_TYPE_CHARACTER = 2;
            private static final byte ALT_TAG_TYPE_DATACONSTRUCTOR = 3;
            private static final byte ALT_TAG_TYPE_STRING = 4;
            
            /** the altTag to use to represent the wildcard pattern match. */
            public static final String WILDCARD_TAG = "_";
            
            /**the varName to use to represent the wildcard pattern match. */
            public static final String WILDCARD_VAR = "$_";
            
            /**
             * The array of possible record tags used in calls to {@link RecordInputStream#findRecord(short[])} by
             * the {@link #load} method.
             */
            private static final short[] SWITCH_ALT_RECORD_TAGS = new short[]{
                ModuleSerializationTags.EXPRESSION_SWITCHALT_MATCHING,
                ModuleSerializationTags.EXPRESSION_SWITCHALT_POSITIONAL
            };
            
            /** The tag for the alt.
             *  If the alt represents a data constructor which takes arguments, the tag must be of type DataConstructor. */
            private List<Object> altTags;
            
            /** The expression for this alt. */
            private Expression expr;

            
            /**
             * Write this instance of SwitchAlt to the RecordOutputStream.
             * @param s
             * @throws IOException
             */
            abstract void write (RecordOutputStream s) throws IOException;
            
            /**
             * Write this instance of SwitchAlt to the RecordOutputStream.
             * @param s
             * @throws IOException
             */
            void writeContent (RecordOutputStream s) throws IOException {
                s.startRecord (ModuleSerializationTags.EXPRESSION_SWITCHALT, serializationSchema);
                
                s.writeIntCompressed(altTags.size());
                for (int i = 0; i < altTags.size(); ++i) {
                    Object tag = altTags.get(i);
                    if (tag instanceof Integer) {
                        s.writeByte(ALT_TAG_TYPE_INTEGER);
                        s.writeInt(((Integer)tag).intValue());
                    } else
                    if (tag instanceof Boolean) {
                        s.writeByte(ALT_TAG_TYPE_BOOLEAN);
                        s.writeBoolean(((Boolean)tag).booleanValue());
                    } else 
                    if (tag instanceof Character) {
                        s.writeByte(ALT_TAG_TYPE_CHARACTER);
                        s.writeChar(((Character)tag).charValue());
                    } else
                    if (tag instanceof DataConstructor) {
                        s.writeByte(ALT_TAG_TYPE_DATACONSTRUCTOR);
                        s.writeQualifiedName(((DataConstructor)tag).getName());
                    } else 
                    if (tag instanceof String) {
                        s.writeByte(ALT_TAG_TYPE_STRING);
                        s.writeUTF((String)tag);
                    } else {
                        throw new IOException ("Unrecognized SwitchAlt tag type: " + tag.getClass() + ".");
                    }
                }
                
                expr.write (s);
                
                s.endRecord ();
            }
            
            /**
             * Load an instance of SwitchAlt from a RecordInputStream
             * @param s
             * @param mti
             * @param msgLogger the logger to which to log deserialization messages.
             * @return an instance of SwitchAlt
             * @throws IOException
             */
            public static SwitchAlt load (RecordInputStream s, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
                RecordHeaderInfo rhi = s.findRecord(SWITCH_ALT_RECORD_TAGS);
                if (rhi == null) {
                    throw new IOException ("Unable to find SwitchAlt record header.");
                }
                DeserializationHelper.checkSerializationSchema(rhi.getSchema(), serializationSchema, mti.getModuleName(), "Expression.Switch.SwitchAlt", msgLogger);
                
                if (rhi.getRecordTag() == ModuleSerializationTags.EXPRESSION_SWITCHALT_MATCHING) {
                    return SwitchAlt.Matching.load(s, rhi.getSchema(), mti, msgLogger);
                } else 
                if (rhi.getRecordTag() == ModuleSerializationTags.EXPRESSION_SWITCHALT_POSITIONAL) {
                    return SwitchAlt.Positional.load(s, rhi.getSchema(), mti, msgLogger);
                } else {
                    throw new IOException ("Unhandled SwitchAlt record tag " + rhi.getRecordTag() + ".");
                }
            }
            
            private void readContent (RecordInputStream s, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
                RecordHeaderInfo rhi = s.findRecord (ModuleSerializationTags.EXPRESSION_SWITCHALT);
                if (rhi == null) {
                    throw new IOException ("Unable to find SwitchAltRecordHeader.");
                }
                DeserializationHelper.checkSerializationSchema(rhi.getSchema(), serializationSchema, mti.getModuleName(), "Expression.Switch.SwitchAlt", msgLogger);
                
                int nTags = s.readIntCompressed();
                altTags = new ArrayList<Object> ();
                for (int i = 0; i < nTags; ++i) {
                    byte tagType = s.readByte();
                    switch (tagType) {
                    case ALT_TAG_TYPE_INTEGER:
                        altTags.add (Integer.valueOf(s.readInt()));
                        break;
                    case ALT_TAG_TYPE_BOOLEAN:
                        altTags.add (Boolean.valueOf(s.readBoolean()));
                        break;
                    case ALT_TAG_TYPE_CHARACTER:
                        altTags.add (Character.valueOf(s.readChar()));
                        break;
                    case ALT_TAG_TYPE_DATACONSTRUCTOR: {
                        QualifiedName qn = s.readQualifiedName();
                        DataConstructor dc = mti.getReachableDataConstructor(qn);
                        if (dc == null) {
                            throw new IOException ("Unable to find DataConstructor " + qn + " while loading SwitchAlt.");
                        }
                        altTags.add (dc);
                        break;
                    }
                    case ALT_TAG_TYPE_STRING: 
                        altTags.add (s.readUTF());
                        break;
                        
                    default: 
                        throw new IOException ("Unhandled tag type " + tagType + " encountered while loading Switch.SwitchAlt.");
                    }
                }
                
                expr = Expression.load (s, mti, msgLogger);
                
                s.skipRestOfRecord();

            }

            
            /**
             * A switch alt where the variables are specified by position.
             * @author Edward Lam
             */
            public static final class Positional extends SwitchAlt {
                private static final int serializationSchema = 0;

                /** (Integer->String) map from position to var name for all used alt vars.*/
                private SortedMap<Integer, String> positionToVarNameMap;    
                
                Positional(Object altTag, SortedMap<Integer, String> positionToVarNameMap, Expression expr) {
                    this(Collections.singletonList(altTag), positionToVarNameMap, expr);
                }

                Positional(List<Object> altTags, SortedMap<Integer, String> positionToVarNameMap, Expression expr) {
                    super (altTags, expr);
                    
                    if (positionToVarNameMap == null) {
                        throw new NullPointerException ("Expression.Switch.SwitchAlt.Matching constructor: the argument 'fieldNameToVarNameMap' cannot be null.");
                    }
                    this.positionToVarNameMap = positionToVarNameMap;
                }

                /**
                 * Default constructor for use by serialization code.
                 */
                private Positional () {}
                
                public SortedMap<Integer, String> getPositionToVarNameMap() {
                    return Collections.unmodifiableSortedMap(positionToVarNameMap);
                }
                
                /**
                 * {@inheritDoc}
                 */
                @Override
                public boolean hasVars() {
                    return !positionToVarNameMap.isEmpty();
                }

                /**
                 * @return the names of the alt variables used in the associated expr. 
                 */
                @Override
                public String[] getVarNames() {
                    String[] names = new String[positionToVarNameMap.size()];
                    int i = 0;
                    for (final Map.Entry<Integer, String> entry : positionToVarNameMap.entrySet()) {                       
                        names[i++] = entry.getValue();
                    }
                    
                    return names;
                }
                
                /**
                 * {@inheritDoc}
                 */
                @Override
                public String toArgumentString() {
                    
                    StringBuilder varsDisplay = new StringBuilder();
                    boolean firstIteration = true;
                    
                    if (positionToVarNameMap.size() > 0){
                    Integer lastInteger = positionToVarNameMap.lastKey();
                    for (int i = 0, lastInt = lastInteger.intValue(); i < lastInt + 1; i++) {
                        String varName = positionToVarNameMap.get(Integer.valueOf(i));
                        
                        if (varName == null) {
                            varName = "_";
                        }
                        
                        if (firstIteration) {
                            firstIteration = false;
                        } else {
                            varsDisplay.append(" ");
                        }
                        varsDisplay.append(varName);
                        }
                    }
                    return varsDisplay.toString();
                }
                
                /**
                 * 
                 * @param visitor
                 * @param arg
                 * @return the result of visiting this LetDefn
                 */
                @Override
                public <T, R> R accept(ExpressionVisitor<T, R> visitor, T arg) {
                    return visitor.visitSwitchAlt_Positional(this, arg);
                }  

                /**
                 * Write this instance of SwitchAlt.Positional to the RecordOutputStream.
                 * @param s
                 * @throws IOException
                 */
                @Override
                void write (RecordOutputStream s) throws IOException {
                    s.startRecord (ModuleSerializationTags.EXPRESSION_SWITCHALT_POSITIONAL, serializationSchema);
                    super.writeContent(s);
                    s.writeIntCompressed(positionToVarNameMap.size ());
                   
                    for (final Map.Entry<Integer, String> entry : positionToVarNameMap.entrySet()){
                        Integer i = entry.getKey();
                        String varName = entry.getValue();
                        s.writeIntCompressed(i.intValue());
                        s.writeUTF(varName);
                    }
                    s.endRecord ();
                }
                
                /**
                 * Load an instance of SwitchAlt.Positional from a RecordInputStream
                 * @param s
                 * @param schema
                 * @param mti
                 * @param msgLogger the logger to which to log deserialization messages.
                 * @return an instance of SwitchAlt.Positional
                 * @throws IOException
                 */
                public static Positional load (RecordInputStream s, int schema, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
                    DeserializationHelper.checkSerializationSchema(schema, serializationSchema, mti.getModuleName(), "Expression.Switch.SwitchAlt.Positional", msgLogger);
                    
                    Positional m = new Positional ();
                    m.readContent (s, mti, msgLogger);
                    return m;
                }
                
                private void readContent (RecordInputStream s, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
                    super.readContent (s, mti, msgLogger);

                    int nFields = s.readIntCompressed();
                    positionToVarNameMap = new TreeMap<Integer, String>();
                    for (int i = 0; i < nFields; ++i) {
                        int ord = s.readIntCompressed();
                        String varName = s.readUTF();
                        positionToVarNameMap.put (Integer.valueOf(ord), varName);
                    }
                    
                    s.skipRestOfRecord();
                }

            }
            
            /**
             * A switch alt where the variables are specified by field name.
             * @author Edward Lam
             */
            public static final class Matching extends SwitchAlt {
                private static final int serializationSchema = 0;

                /** (FieldName->String) map from field name to var name for all used alt vars.*/
                private Map<FieldName, String> fieldNameToVarNameMap;    
                
                Matching(Object altTag, Map<FieldName, String> fieldNameToVarNameMap, Expression expr) {
                    this(Collections.singletonList(altTag), fieldNameToVarNameMap, expr);
                }

                Matching(List<Object> altTags, Map<FieldName, String> fieldNameToVarNameMap, Expression expr) {
                    super (altTags, expr);
                    
                    if (fieldNameToVarNameMap == null) {
                        throw new NullPointerException ("Expression.Switch.SwitchAlt.Matching constructor: the argument 'fieldNameToVarNameMap' cannot be null.");
                    }
                    this.fieldNameToVarNameMap = fieldNameToVarNameMap;
                }

                /** 
                 * Default constructor for use by serialization code.
                 */
                private Matching () {}
                
                
                public Map<FieldName, String> getFieldNameToVarNameMap() {
                    return Collections.unmodifiableMap(fieldNameToVarNameMap);
                }
                
                /**
                 * {@inheritDoc}
                 */
                @Override
                public boolean hasVars() {
                    return !fieldNameToVarNameMap.isEmpty();
                }
                
                /**
                 * @return the names of the alt variables used in the associated expr. 
                 */
                @Override
                public String[] getVarNames() {
                    String[] names = new String[fieldNameToVarNameMap.size()];
                    int i = 0;
                    for (final Map.Entry<FieldName, String> entry : fieldNameToVarNameMap.entrySet()) {                       
                        names[i++] = entry.getValue();
                    }
                    
                    return names;
                }
                
                /**
                 * {@inheritDoc}
                 */
                @Override
                public String toArgumentString() {
                    
                    StringBuilder varsDisplay = new StringBuilder();
                    
                    varsDisplay.append("{");
                    
                    boolean firstIteration = true;
                    for (final Map.Entry<FieldName, String> entry : fieldNameToVarNameMap.entrySet()) { 
                        FieldName fieldName = entry.getKey();
                        String varName = entry.getValue();
                        
                        if (firstIteration) {
                            firstIteration = false;
                        } else {
                            varsDisplay.append(", ");
                        }
                        varsDisplay.append(fieldName + "=" + varName);
                    }
                    varsDisplay.append("}");
                    
                    return varsDisplay.toString();
                }
                
                /**
                 * 
                 * @param visitor
                 * @param arg
                 * @return the result of visiting this LetDefn
                 */
                @Override
                public <T, R> R accept(ExpressionVisitor<T, R> visitor, T arg) {
                    return visitor.visitSwitchAlt_Matching(this, arg);
                }  

                /**
                 * Write this instance of SwitchAlt.Matching to the RecordOutputStream.
                 * @param s
                 * @throws IOException
                 */
                @Override
                void write (RecordOutputStream s) throws IOException {
                    s.startRecord (ModuleSerializationTags.EXPRESSION_SWITCHALT_MATCHING, serializationSchema);
                    super.writeContent (s);
                    s.writeIntCompressed(fieldNameToVarNameMap.size());                    
                    for (final Map.Entry<FieldName, String> entry : fieldNameToVarNameMap.entrySet()) { 
                        FieldName fn = entry.getKey();
                        String varName = entry.getValue();
                        FieldNameIO.writeFieldName(fn, s);
                        s.writeUTF (varName);
                    }
                    s.endRecord ();
                }   
                
                /**
                 * Load an instance of SwitchAlt.Matching from a RecordInputStream
                 * @param s
                 * @param schema
                 * @param mti
                 * @param msgLogger the logger to which to log deserialization messages.
                 * @return an instance of SwitchAlt.Matching
                 * @throws IOException
                 */
                public static Matching load (RecordInputStream s, int schema, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
                    DeserializationHelper.checkSerializationSchema(schema, serializationSchema, mti.getModuleName(), "Expression.Switch.SwitchAlt.Matching", msgLogger);
                    
                    Matching m = new Matching ();
                    m.readContent (s, mti, msgLogger);
                    return m;
                }
                
                private void readContent (RecordInputStream s, ModuleTypeInfo mti, CompilerMessageLogger msgLogger) throws IOException {
                    super.readContent (s, mti, msgLogger);

                    int nFields = s.readIntCompressed();
                    fieldNameToVarNameMap = new HashMap<FieldName, String>();
                    for (int i = 0; i < nFields; ++i) {
                        FieldName fn = FieldNameIO.load (s, mti.getModuleName(), msgLogger);
                        String varName = s.readUTF();
                
