/** TIME SPENT: 20 hours and 46 minutes. */ 

package student;
import java.util.*;
import danaus.*;

public class Butterfly extends AbstractButterfly {
	private TileState[][] mapStates; // TileState[][] array generated by learn()
	private List<Flower> oldFlowers; // List of flowers blooming before the invocation of learn()
	Direction[][] backPointers;      // Array to store the directions which indicate the shortest path
	int[][] distances;               // Array to store the distances between every tile with the 
	                                 // initial tile
	int nRows;                       // Number of rows in the map
	int nCols;                       // Number of columns in the map
	Stack<Direction> path;           // Stores the nearest path to one tile
	
	/** Return a two-dimensional array of TileStates that represents the map the
	 * butterfly is on.
	 * 
	 * During the learning phase of a simulation, butterflies are tasked with
	 * learning the map in preparation for the running phase of a simulation. 
	 * A butterfly will traverse the entire map and generate a two-dimensional
	 * array of TileStates in which each TileState corresponds to the
	 * appropriate in the map.
	 * 
	 * @return A two-dimensional array of TileStates that represents the map the
	 * butterfly is on.
	 */
	public @Override TileState[][] learn() {
		// Initialize the nRows and nCols
		nRows = getMapHeight();
		nCols = getMapWidth();
		
		// Initialize the TileState[][] result array
		mapStates = new TileState[nRows][nCols];
		oldFlowers = new ArrayList<Flower>();
		
		// Depth First Search
		DFS();

		return mapStates;
	}
	
	/** Do the Depth First Search along the Direction dir.
	 * When search() is called, it will first fetch the state of current 
	 * tile and store it in mapStates[][]. After that, it will recursively 
	 * search along the possible directions.
	 * When the method finishes, the butterfly will return to the original 
	 * location when the method is called.
	 */
	private void DFS() {
		// Get the state of the current tile
		refreshState();
		mapStates[location.row][location.col] = state;
		
		// Add the flowers on current tile to oldFlowers
		oldFlowers.addAll(state.getFlowers());

		// Search from adjacent tiles
		for (Direction nextDir : Direction.values()) {
			int nextRow = Common.mod(location.row + nextDir.dRow, nRows);
			int nextCol = Common.mod(location.col + nextDir.dCol, nCols);
			if (mapStates[nextRow][nextCol] == null)
				try {
					fly(nextDir, Speed.NORMAL);
					DFS();
					fly(Direction.opposite(nextDir), Speed.NORMAL);
				}
				catch (ObstacleCollisionException e) {
					// Butterfly hits a cliff or water, sets the corresponding
					// TileState to Nil
					mapStates[nextRow][nextCol] = TileState.nil;
				}
		}
	}
	
	/** Simulate the butterfly's flight.
	 * During the run(), a shortest-path algorithm will be used to calculate
	 * the shortest path from every flyable tile to the initial tile.
	 * Then the butterfly will use the shortest-paths to collect the old 
	 * flowers. For the new flowers that bloom after learning phase, the 
	 * butterfly will exploit its aroma to find an efficient path to collect
	 * them.
	 * 
	 * @param flowers A vector of flowers which the butterfly has to collect
     * @see danaus.AbstractButterfly#collect(Flower)
	 */
	public @Override void run(List<Long> flowerIds) {
        // According to flowerIds, find the corresponding old flowers in the 
		// oldFlowers list
		List<Flower> flowersToCollect = new ArrayList<Flower>();
		List<Long> newFlowerIds = new ArrayList<Long>(flowerIds);
		for (Flower flower : oldFlowers)
			if (flowerIds.contains(flower.getFlowerId())) {
				flowersToCollect.add(flower);
				newFlowerIds.remove(flower.getFlowerId());
			}

		// Collect old flowers
		collectOldFlowers(flowersToCollect);
		
		// Collect new flowers
		collectNewFlowers(newFlowerIds);
	}
	
	
	/** Collect the flowers that bloom before the execution of learn().
	 * Every time, choose the nearest flower and collect it. Use Dijkstra shortest
	 * path algorithm to calculate the shortest path between the initial tile and 
	 * the flower to be collected.
	 * 
	 * @param flowersToCollect List of flowers to be collected.
	 */
	private void collectOldFlowers(List<Flower> flowersToCollect) {
		while (!flowersToCollect.isEmpty()) {
			// Find the nearest flower
			Flower nearFlower = nearestFlower(flowersToCollect);
			
			// Form the path to nearFlower
			int curRow = nearFlower.getLocation().row;
			int curCol = nearFlower.getLocation().col;
			Direction backPointer = backPointers[curRow][curCol];
			while(backPointer != null) {
				path.push(Direction.opposite(backPointer));
				
				// Move to the previous tile
				curRow = (curRow + backPointer.dRow + nRows) % nRows;
				curCol = (curCol + backPointer.dCol + nCols) % nCols;
				backPointer = backPointers[curRow][curCol];
			}
			
			// Fly to the tile and collect the flower
			while (!path.empty())
				fly(path.pop(), Speed.NORMAL);
			collect(nearFlower);
			flowersToCollect.remove(nearFlower);
		}
	}
	
	/** Collect the flowers that bloom after the execution of learn().
	 * In every turn, the butterfly will fly to the tile with higher 
	 * intensity of the aroma of the corresponding flower. It will 
	 * also remember the last direction it made as a prediction for next
	 * turn.
	 * 
	 * @param newFlowerIds Long array containing the Ids of the flowers to
	 * be collected.
	 */
	private void collectNewFlowers(List<Long> newFlowerIds) {
		// For the new flowers, use their aroma to find and collect them
		for (Long newFlowerId : newFlowerIds) {
			// Get aromas on current tile
			refreshState();
			List<Aroma> aromas = state.getAromas();
			
			// Get the corresponding aroma
			Aroma curAroma = null;
			for (Aroma aroma : aromas)
				if (aroma.getFlowerId() == newFlowerId)
					curAroma = aroma;
			
			// Find the direction in which curAroma has greater intensity
			Aroma nextAroma = null;
			boolean arrived = false;
			int i = 0;
			while (!arrived) {
				arrived = true;
				for (int j = 0; j < Direction.values().length; j++) {
					Direction dir = Direction.values()[i];
					int nextRow = Common.mod(location.row + dir.dRow, nRows);
					int nextCol = Common.mod(location.col + dir.dCol, nCols);
					
					// Special Case: Maps with only one row or one column
					if (nextRow == location.row && nextCol == location.col) {
						// Current Direction is illegal
						i = (i + 1) % Direction.values().length;
						continue;
					}
					
					if (mapStates[nextRow][nextCol] != null &&
							!mapStates[nextRow][nextCol].equals(TileState.nil)) {
						fly(dir, Speed.NORMAL);
						refreshState();
						aromas = state.getAromas();
						for (Aroma aroma : aromas)
							if (aroma.getFlowerId() == newFlowerId)
								nextAroma = aroma;
						
						if (nextAroma.intensity > curAroma.intensity) {
							// Correct direction and not arrived
							arrived = false;
							curAroma = nextAroma;
							break;
						}
						else {
							// Wrong direction
							fly(Direction.opposite(dir), Speed.NORMAL);
							i = (i + 1) % Direction.values().length;
						}	
					}
					else
						i = (i + 1) % Direction.values().length;
				}
			}
					
			// Butterfly arrives at final location, collect the flower
			refreshState();
			for (Flower newFlower : state.getFlowers())
				if (newFlower.getFlowerId() == newFlowerId) {
					collect(newFlower);
					break;
				}
		}
	}
	
	/** Return the nearest flower from the current location.
	 * 
	 * @param flowersToCollect
	 * @return Flower object that have the smallest distance.
	 */
	private Flower nearestFlower(List<Flower> flowersToCollect) {
		Dijkstra();
		Flower nearestFlower = null;
		int minDistance = Integer.MAX_VALUE;
		for (Flower flower : flowersToCollect)
			if (distances[flower.getLocation().row][flower.getLocation().col] < minDistance) {
				minDistance = distances[flower.getLocation().row][flower.getLocation().col];
				nearestFlower = flower;
			}
		return nearestFlower;
	}
	
	/** A class contains the information of the row, col and distance from the 
	 * initial tile of one flyable tile.
	 */
	class Distance implements Comparable<Distance> {
		private int row; // Row of the tile.
		private int col; // Column of the tile.
		private int dist = Integer.MAX_VALUE; // Distance from the initial tile.
		
		/** Constructor: an instance with coordinates [row, col] and distance dist */
		public Distance(int row, int col, int dist) {
			this.col = col;
			this.row = row;
			this.dist = dist;
		}
		
		/** Constructor: an instance with equal to d */
		public Distance(Distance d) {
			col = d.col;
			row = d.row;
			dist = d.dist;
		}
		
		/** Return a negative integer, zero, or a positive integer depending on
	     * whether this Distance comes before Distance d. The comparison
	     * is made only on the dist field. */
		public @Override int compareTo(Distance d) {
			return dist - d.dist;
		}
		
		/** Return a string containing the three fields. */
		public @Override String toString() {
			return row + ", " + col + ", " + dist;
		}
	}
	
	/** The Dijkstra algorithm to calculate the shortest path from each flyable
	 * tile to the initial tile whose location is location.
	 */
	private void Dijkstra() {
		// Declare the Direction array that stores the back pointers of each 
		// tile along its shortest-path to the initial tile.
		backPointers = new Direction[nRows][nCols];
		distances = new int[nRows][nCols];
		path = new Stack<Direction>();
		
		// The priority queue that contains TileState of all flyable tiles
		PriorityQueue<Distance> Q = new PriorityQueue<Distance>();
		for (int i = 0; i < nRows; i++)
			for (int j = 0; j < nCols; j++)
				if (mapStates[i][j] != null && !mapStates[i][j].equals(TileState.nil))
					if (i == location.row && j == location.col) {
						Q.add(new Distance(i, j, 0));
						distances[i][j] = 0;
					}
					else {
						Q.add(new Distance(i, j, Integer.MAX_VALUE));
						distances[i][j] = Integer.MAX_VALUE;
					}
						
		
		// The location of the tile with the smallest distance and its adjacent tiles
		Distance curLoc;
		int nextRow = 0;
		int nextCol = 0;
		
		// Alternative distance
		int alt = 0;
		
		// The main loop
		while (Q.size() != 0) {
			// Find the location of the tile with the smallest distance
			curLoc = Q.poll();
			
			// The remaining tiles are unreachable
			if (curLoc.dist == Integer.MAX_VALUE)
				break;
			
			for (Direction dir: Direction.values()) {
				// Get the coordinates of adjacent tile v
				nextRow = (curLoc.row + dir.dRow + nRows) % nRows;
				nextCol = (curLoc.col + dir.dCol + nCols) % nCols;
				
				// If v is flyable, update the shortest distance and its back pointer
				if (!mapStates[nextRow][nextCol].equals(TileState.nil)) {
					alt = curLoc.dist + 1;
					
					// Find the appropriate tile in Q
					for (Distance nextLoc : Q) {
						if (nextLoc.row == nextRow && nextLoc.col == nextCol) {
							if (alt < nextLoc.dist) {
								Q.remove(nextLoc);
								Q.add(new Distance(nextRow, nextCol, alt));
								backPointers[nextRow][nextCol] = Direction.opposite(dir);
								distances[nextRow][nextCol] = alt;
							}
							break;
						}
					}
				}
			}
		}
	}
}
