package quoridor.backend.ai;

import java.util.ArrayList;
import java.util.Random;

import quoridor.backend.containers.Position;
import quoridor.backend.pieces.Pawn;
import quoridor.backend.pieces.Walls;
import quoridor.network.server.AIServer;

/**
 * @author Team 4 Men And A Cripple
 * @version 2014-05-04
 *
 * This class represents an AI in a game of Quoridor.
 */
public class AI {

    private Pawn myself, closest;
    private AIServer parent;

    /**
     * Construct a new AI.
     * 
     * @param parent The server this AI runs on.
     * @param p The pawn representing this AI.
     * @param filename Filename in the event the parser gets added on time.
     */
    public AI(AIServer parent, Pawn p, String filename) {
        myself = p;
        this.parent = parent;
    }

    /**
     * Generates a wall placement or pawn movement.
     * 
     * @return The move generated by this AI.
     */
    public String genMove() {
        determinePawns();
        ArrayList<Position> myPath
            = myself.genPath(parent.getGameState().getWalls(),
                    parent.getGameState().getPawns());
        ArrayList<Position> theirPath
            = closest.genPath(parent.getGameState().getWalls(),
                    parent.getGameState().getPawns());
        if(myPath.size() > theirPath.size()) {
            if(parent.getNWalls() > 0) {
                String s = block();
                if(!s.equals("ERROR")) {
                    parent.deductWall();
                    return s;
                }
            }
        }
        return myself.genPath(parent.getGameState().getWalls(),
                parent.getGameState().getPawns()).get(0).toString();
    }

    /**
     * Determines where to place a wall to best block the opponent closest to
     * their endzone.
     * 
     * @return The wall placement generated by this block.
     */
    public String block() {
        determinePawns();
        String wp = "ERROR";
        int greatestWeight = 0;
        for(int i = 0; i < 9; i++)
            for(int j = 0; j < 9; j++) {
                Position pos = new Position(i, j);
                int k = testWall(pos.toString() + 'v');
                int l = testWall(pos.toString() + 'h');
                if(k > greatestWeight || (k == greatestWeight
                        && new Random().nextBoolean())) {
                    greatestWeight = k;
                    wp = pos.toString() + 'v';
                } if(l > greatestWeight || (l == greatestWeight
                        && new Random().nextBoolean())) {
                    greatestWeight = l;
                    wp = pos.toString() + 'h';
                }
            }
        if(greatestWeight > 0 && !wp.equals("ERROR")) {
            return wp;
        }
        return "ERROR";
    }

    /**
     * Determines a location where a wall can be placed and determines how
     * effective that wall placement would be in slowing down opponents.
     * 
     * @param s An encoding of the wall being considered.
     * @return The weight of the wall placement.
     */
    private int testWall(String s) {
        s = s.toUpperCase().trim();
        Position a = new Position(s.substring(0, 2));
        Position b;
        if (s.charAt(2) == 'H')
            b = new Position(a.x, a.y + 1);
        else
            b = new Position(a.x + 1, a.y);
        if(!parent.getGameState().getWalls().canAdd(a, b,
                parent.getGameState()))
            return 0;
        Walls temp = new Walls(parent.getGameState().getWalls());
        temp.add(a, b);
        int i = myself.genPath(temp, parent.getGameState().getPawns()).size()
                - myself.genPath(parent.getGameState().getWalls(),
                parent.getGameState().getPawns()).size();
        int j = closest.genPath(temp, parent.getGameState().getPawns()).size()
                - closest.genPath(parent.getGameState().getWalls(),
                parent.getGameState().getPawns()).size();
        return j - i;
    }

    /**
     * Determines the pawn closest to it's endzone, not including the pawn
     * that represents this AI.
     */
    private void determinePawns() {
        int shortest = 0;
        for(Pawn p : parent.getGameState().getPawns()) {
            if(!p.equals(myself)) {
                ArrayList<Position> path
                    = p.genPath(parent.getGameState().getWalls(),
                            parent.getGameState().getPawns());
                if(shortest == 0 || path.size() < shortest || (path.size()
                        == shortest && new Random().nextBoolean())) {
                    shortest = path.size();
                    closest = p;
                }
            }
        }
    }

}

