/* Generated By:JavaCC: Do not edit this line. TigerParser.java */
package sidekick.java.parser;

import sidekick.java.node.*;

import java.io.*;
import java.util.*;

/**
 * Based on grammar to parse Java version 1.5 written by Sreenivasa Viswanadha,
 * parses a java file for the JBrowse plugin to provide a java code
 * browser that works with java 1.5.
 * <p>
 * Example usage:<p>
 * <code>
 * TigerParser parser = new TigerParser(filename);<br>
 * CUNode root = parser.CompilationUnit();<br>
 * </code>
 * Calling <code>CompilationUnit()</code> causes the file to be parsed into
 * TigerNodes, of which, CUNode is the top-level.  The TigerNodes have a parent/
 * child relastionship, which naturally forms a tree structure.
 * <p>
 * To turn this .jj file into a .java file, run <code>javacc Tiger.jj</code>
 * from the directory that contains this file.  Javacc will produce a number of
 * .java files, Be careful -- not all files in the directory are produced by
 * javacc, in particular ModifierSet.java and Token.java are required files and
 * are NOT produced by javacc. So the sequence is:<br>
 * .jj -> javacc -> .java -> javac -> .class
 */
public class TigerParser implements TigerParserConstants {
   // accumulates counts of classes, interfaces, methods and fields. 
   private Results results = new Results();


   private InputStream inputStream = null;

    /**
     * Constructor for TigerParser.  Note that JBrowse does not use this 
     * constructor -- since the options for build the parser have both
     * USER_TOKEN_MANAGER and USER_CHAR_STREAM set to false (these are the
     * default values so are not explicitly set), javacc will create a
     * constructor "public TigerParser(InputStream)".  It is that constructor
     * that JBrowse uses.
     * @param fileName name of the file to parse
     */
   public TigerParser(String filename)
   {
      this(System.in);
      try {
          inputStream = new FileInputStream(new File(filename));
          ReInit(inputStream);
      }
      catch(Exception e) {
        e.printStackTrace();
      }
   }

        /**
	 * @return the accumulated counts of classes, interfaces, methods, and fields.   
	 */
   public Results getResults() {
        return results;
   }

   public Location getLocation(Token t) {
       if (t == null)
           return new Location(0, 0);
       return new Location(t.beginLine, t.beginColumn);
   }

   public void error_skipto(int kind) {
       ParseException e = generateParseException();  // generate the exception object.
       addException(e);
       Token t = null;
       do {
           t = getNextToken();
       } while (t.kind != kind);
   }

   private List exceptions = new ArrayList();

   private void addException(ParseException pe) {
       ErrorNode en = new ErrorNode(pe);
       exceptions.add(en);
   }

   public List getErrors() {
       return exceptions;
   }

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

/**
 * Main entry point for parsing.
 * @return a CUNode, which is parent or root node of all other nodes.
 */
  final public CUNode CompilationUnit() throws ParseException {
    CUNode n = new CUNode();
    TigerNode a;
    String packageName = "";
    ImportNode in = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PACKAGE:
        packageName = PackageDeclaration();
        break;
      default:
        ;
      }
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPORT:
          ;
          break;
        default:
          break label_1;
        }
        in = ImportDeclaration();
                                      n.addImport(in);
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case CLASS:
        case ENUM:
        case FINAL:
        case INTERFACE:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOLATILE:
        case SEMICOLON:
        case AT:
          ;
          break;
        default:
          break label_2;
        }
        a = TypeDeclaration();
               n.addChild(a);
      }
      jj_consume_token(0);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        try {
            if (inputStream != null)
                inputStream.close();
        }
        catch(Exception e) {
            // not to worry
        }
        n.setPackageName(packageName);
        {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public String PackageDeclaration() throws ParseException {
    String name = "";
    try {
      jj_consume_token(PACKAGE);
      name = Name();
      jj_consume_token(SEMICOLON);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public ImportNode ImportDeclaration() throws ParseException {
    String name = null;
    try {
      jj_consume_token(IMPORT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATIC:
        jj_consume_token(STATIC);
        break;
      default:
        ;
      }
      name = Name();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        jj_consume_token(STAR);
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return name == null ? null : new ImportNode(name);}
    throw new Error("Missing return statement in function");
  }

/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 */
  final public int Modifiers() throws ParseException {
   int modifiers = 0;
    label_3:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUBLIC:
        jj_consume_token(PUBLIC);
              modifiers |= ModifierSet.PUBLIC;
        break;
      case STATIC:
        jj_consume_token(STATIC);
              modifiers |= ModifierSet.STATIC;
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
                 modifiers |= ModifierSet.PROTECTED;
        break;
      case PRIVATE:
        jj_consume_token(PRIVATE);
               modifiers |= ModifierSet.PRIVATE;
        break;
      case FINAL:
        jj_consume_token(FINAL);
             modifiers |= ModifierSet.FINAL;
        break;
      case ABSTRACT:
        jj_consume_token(ABSTRACT);
                modifiers |= ModifierSet.ABSTRACT;
        break;
      case SYNCHRONIZED:
        jj_consume_token(SYNCHRONIZED);
                    modifiers |= ModifierSet.SYNCHRONIZED;
        break;
      case NATIVE:
        jj_consume_token(NATIVE);
              modifiers |= ModifierSet.NATIVE;
        break;
      case TRANSIENT:
        jj_consume_token(TRANSIENT);
                 modifiers |= ModifierSet.TRANSIENT;
        break;
      case VOLATILE:
        jj_consume_token(VOLATILE);
                modifiers |= ModifierSet.VOLATILE;
        break;
      case STRICTFP:
        jj_consume_token(STRICTFP);
                modifiers |= ModifierSet.STRICTFP;
        break;
      case AT:
        Annotation();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return modifiers;}
    throw new Error("Missing return statement in function");
  }

/*
 * Declaration syntax follows.
 */

// Handle classes, interfaces, enums, and annotations. 
  final public TigerNode TypeDeclaration() throws ParseException {
   int modifiers;
   TigerNode tn = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      case ABSTRACT:
      case CLASS:
      case ENUM:
      case FINAL:
      case INTERFACE:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case AT:
        modifiers = Modifiers();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLASS:
        case INTERFACE:
          tn = ClassOrInterfaceDeclaration(modifiers);
          break;
        case ENUM:
          tn = EnumDeclaration(modifiers);
          break;
        case AT:
          AnnotationTypeDeclaration(modifiers);
                                                    tn = null;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

/**
 * @return a ClassNode or an InterfaceNode
 */
  final public TigerNode ClassOrInterfaceDeclaration(int modifiers) throws ParseException {
   boolean isInterface = false;
   Token t = null;
   TigerNode kids = null;   // only need the children of this node
   String type_params = "";
   List extends_list = null;
   List implements_list = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
        jj_consume_token(CLASS);
        break;
      case INTERFACE:
        jj_consume_token(INTERFACE);
                                isInterface = true;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        type_params = TypeParameters();
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        extends_list = ExtendsList(isInterface);
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLEMENTS:
        implements_list = ImplementsList(isInterface);
        break;
      default:
        ;
      }
      kids = ClassOrInterfaceBody(isInterface);
      if (jj_2_2(2)) {
        jj_consume_token(SEMICOLON);
      } else {
        ;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        ClassNode node = isInterface ? new InterfaceNode(t.image, modifiers) : new ClassNode(t.image, modifiers);
        if (isInterface)
            results.incInterfaceCount();
        else
            results.incClassCount();

        node.setStartLocation(new Location(t.beginLine, 0));
        if (kids != null)
            node.setEndLocation(kids.getEndLocation());

        // add the child nodes, don't need the 'kids' node itself, it's just a holder
        // for the nodes I want (although I do want the end location).
        if (kids != null && kids.getChildren() != null)
            node.addChildren(kids.getChildren());
        node.setTypeParams(type_params);
        node.setExtendsList(extends_list);
        node.setImplementsList(implements_list);
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

/**
 * @return a list of sidekick.java.node.Types representing items in an 'extends'
 * list, e.g. the "Bar" in "public class Foo extends Bar"
 */
  final public List ExtendsList(boolean isInterface) throws ParseException {
   boolean extendsMoreThanOne = false;
   List list = new ArrayList();     // a list of Types
   Type type_s = null;
   Type type_a = null;
    try {
      jj_consume_token(EXTENDS);
      type_s = ClassOrInterfaceType();
                                                 list.add(type_s);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_4;
        }
        jj_consume_token(COMMA);
        type_a = ClassOrInterfaceType();
                                             extendsMoreThanOne = true; list.add(type_a);
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        if (extendsMoreThanOne && !isInterface)
            {if (true) throw new ParseException("A class cannot extend more than one other class");}
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * @return a list of sidekick.java.node.Types representing items in an 'implements'
 * list, e.g. the "Bar" and "Serializable" in "public class Foo implements Bar, Serializable"
 */
  final public List ImplementsList(boolean isInterface) throws ParseException {
    List list = new ArrayList();
    Type type_s = null;
    Type type_a = null;
    try {
      jj_consume_token(IMPLEMENTS);
      type_s = ClassOrInterfaceType();
                                                     list.add(type_s);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_5;
        }
        jj_consume_token(COMMA);
        type_a = ClassOrInterfaceType();
                                             list.add(type_a);
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        if (isInterface)
            {if (true) throw new ParseException("An interface cannot implement other interfaces");}
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * @return an EnumNode
 */
  final public TigerNode EnumDeclaration(int modifiers) throws ParseException {
    Token t = null;
    Token start_t = null;
    Location end_loc = null;
    try {
      start_t = jj_consume_token(ENUM);
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLEMENTS:
        ImplementsList(false);
        break;
      default:
        ;
      }
      end_loc = EnumBody();
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        EnumNode node = new EnumNode(t.image, modifiers);
        if (start_t != null)
            node.setStartLocation(getLocation(start_t));
        if (end_loc != null)
            node.setEndLocation(end_loc);
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public Location EnumBody() throws ParseException {
    Token t = null;
    try {
      jj_consume_token(LBRACE);
      EnumConstant();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_6;
        }
        jj_consume_token(COMMA);
        EnumConstant();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ABSTRACT:
          case BOOLEAN:
          case BYTE:
          case CHAR:
          case CLASS:
          case DOUBLE:
          case ENUM:
          case FINAL:
          case FLOAT:
          case INT:
          case INTERFACE:
          case LONG:
          case NATIVE:
          case PRIVATE:
          case PROTECTED:
          case PUBLIC:
          case SHORT:
          case STATIC:
          case STRICTFP:
          case SYNCHRONIZED:
          case TRANSIENT:
          case VOID:
          case VOLATILE:
          case IDENTIFIER:
          case LBRACE:
          case SEMICOLON:
          case AT:
          case LT:
            ;
            break;
          default:
            break label_7;
          }
          ClassOrInterfaceBodyDeclaration(false);
        }
        break;
      default:
        ;
      }
      t = jj_consume_token(RBRACE);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return t == null ? null : getLocation(t);}
    throw new Error("Missing return statement in function");
  }

/// what is this?  Should I be handling it?
  final public void EnumConstant() throws ParseException {
    try {
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        Arguments();
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ClassOrInterfaceBody(false);
        break;
      default:
        ;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

/**
 * @return a string representing a generics type, e.g. the "<String>" in
 * "List<String> list = new List();", the string will contain the angle brackets.
 */
  final public String TypeParameters() throws ParseException {
    String s = "<";
    String a = "";
    try {
      jj_consume_token(LT);
      a = TypeParameter();
              s += a;
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_8;
        }
        jj_consume_token(COMMA);
                  s += ",";
        a = TypeParameter();
                  s += a;
      }
      jj_consume_token(GT);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s + ">";}
    throw new Error("Missing return statement in function");
  }

  final public String TypeParameter() throws ParseException {
    String s = "";
    Token t = null;
    try {
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        s = TypeBound();
        break;
      default:
        ;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        StringBuffer sb = new StringBuffer();
        if (t.image != null)
            sb.append(t.image);
        if (s.length() > 0)
            sb.append(" ").append(s);
        {if (true) return sb.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String TypeBound() throws ParseException {
    String s = "extends";
    Type type_s = null;
    Type type_a = null;
    try {
      jj_consume_token(EXTENDS);
      type_a = ClassOrInterfaceType();
              s += " " + type_a.toString();
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BIT_AND:
          ;
          break;
        default:
          break label_9;
        }
        jj_consume_token(BIT_AND);
                  s += " & ";
        type_a = ClassOrInterfaceType();
                  s += type_a.toString();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

/**
 * @return a node representing the contents of a Class or Interface body.  The
 * returned node is simply a holder for the contents, it is the children of this
 * node that is useful as they are the methods and fields of the class or
 * interface.
 */
  final public TigerNode ClassOrInterfaceBody(boolean isInterface) throws ParseException {
    TigerNode parent = new TigerNode("", -1);
    TigerNode child;
    Token start_t = null;
    Token end_t = null;
    try {
      start_t = jj_consume_token(LBRACE);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case IDENTIFIER:
        case LBRACE:
        case SEMICOLON:
        case AT:
        case LT:
          ;
          break;
        default:
          break label_10;
        }
        child = ClassOrInterfaceBodyDeclaration(isInterface);
                  if (child != null) parent.addChild(child);
      }
      end_t = jj_consume_token(RBRACE);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        if (start_t != null)
          parent.setStartLocation(getLocation(start_t));
        if (end_t != null)
          parent.setEndLocation(getLocation(end_t));
        {if (true) return parent.getChildren() != null ? parent : null;}
    throw new Error("Missing return statement in function");
  }

/**
 * @return one of several different nodes, could be a ClassNode, EnumNode,
 * ConstructorNode, FieldNode, MethodNode, or an InterfaceNode.
 */
  final public TigerNode ClassOrInterfaceBodyDeclaration(boolean isInterface) throws ParseException {
   // see note above (~ line 510), I think my changes here have broken the test for a
   // trailing ; after a class body.
   boolean isNestedInterface = false;
   int modifiers;
   TigerNode a = null;
   TigerNode initializer = null;
   String type_params = null;
    try {
      if (jj_2_5(2)) {
        initializer = Initializer();
             if (isInterface)
                {if (true) throw new ParseException("An interface cannot have initializers");}
             if (initializer != null)
                 {if (true) return initializer;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case IDENTIFIER:
        case AT:
        case LT:
          modifiers = Modifiers();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CLASS:
          case INTERFACE:
            a = ClassOrInterfaceDeclaration(modifiers);
            break;
          case ENUM:
            a = EnumDeclaration(modifiers);
            break;
          default:
            if (jj_2_3(2147483647)) {
              a = ConstructorDeclaration();
                ((ConstructorNode)a).setModifiers(modifiers);
                ((ConstructorNode)a).setTypeParams(type_params);
            } else if (jj_2_4(2147483647)) {
              a = FieldDeclaration(modifiers);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case BOOLEAN:
              case BYTE:
              case CHAR:
              case DOUBLE:
              case FLOAT:
              case INT:
              case LONG:
              case SHORT:
              case VOID:
              case IDENTIFIER:
              case LT:
                a = MethodDeclaration(modifiers);
                break;
              default:
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
          break;
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
       {if (true) return a;}
    throw new Error("Missing return statement in function");
  }

/**
 * @return a FieldNode
 */
  final public TigerNode FieldDeclaration(int modifiers) throws ParseException {
    Type type = null;
    TigerNode name  = null;
    TigerNode a;
    Token t = null;
    try {
      // Modifiers are already matched in the caller
              /// might need to change this, I'm collecting multiple declarations into a single
              /// field, which seems to be okay, e.g. I'm putting "int x = 0, y = 6" into a 
              /// field with Type "int" and name "x, y".  It might be better to create individual
              /// nodes for each, so for this example, this method could return 2 fields, one
              /// for "int x" and one for "int y".
              type = Type();
      name = VariableDeclarator();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_11;
        }
        jj_consume_token(COMMA);
        a = VariableDeclarator();
                                                                             name.setName(name.getName() + ", " + a.getName());
      }
      t = jj_consume_token(SEMICOLON);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        FieldNode fn = new FieldNode(name.getName(), modifiers, type);
        if (fn.isPrimitive())
          results.incPrimitiveFieldCount();
        else
          results.incReferenceFieldCount();
        fn.setStartLocation(new Location(name.getStartLocation().line, 0));
        fn.setEndLocation(getLocation(t));
        {if (true) return fn;}
    throw new Error("Missing return statement in function");
  }

  final public TigerNode VariableDeclarator() throws ParseException {
    TigerNode s = null;
    try {
      s = VariableDeclaratorId();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        VariableInitializer();
        break;
      default:
        ;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public TigerNode VariableDeclaratorId() throws ParseException {
    Token t = null;
    try {
      t = jj_consume_token(IDENTIFIER);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ;
          break;
        default:
          break label_12;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        TigerNode tn = new TigerNode(t.image, 0);
        tn.setStartLocation(new Location(t.beginLine, t.beginColumn));
        tn.setEndLocation(new Location(t.beginLine, t.beginColumn + t.image.length()));
        {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public void VariableInitializer() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ArrayInitializer();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void ArrayInitializer() throws ParseException {
    try {
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        VariableInitializer();
        label_13:
        while (true) {
          if (jj_2_6(2)) {
            ;
          } else {
            break label_13;
          }
          jj_consume_token(COMMA);
          VariableInitializer();
        }
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        ;
      }
      jj_consume_token(RBRACE);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

/**
 * @return a MethodNode
 */
  final public TigerNode MethodDeclaration(int modifiers) throws ParseException {
    String type_params = "";
    String return_type = "";
    MethodNode m_node = null;
    String name_list = "";
    int line_number = -1;
    BlockNode block = null;
    Location endLoc = null;
    Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        type_params = TypeParameters();
        break;
      default:
        ;
      }
      return_type = ResultType();
      m_node = MethodDeclarator();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THROWS:
        jj_consume_token(THROWS);
        name_list = NameList();
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        block = Block();
        break;
      case SEMICOLON:
        t = jj_consume_token(SEMICOLON);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        MethodNode node = new MethodNode();
        node.setName(m_node.getName());
        node.setStartLocation(new Location(m_node.getStartLocation().line, 0));
        node.setModifiers(modifiers);
        node.setFormalParams(m_node.getFormalParams());
        node.setReturnType(return_type);
        node.setTypeParams(type_params);
        node.setThrows(name_list);
        if (block == null && t != null) {
            node.setEndLocation(getLocation(t));
        }
        else {
            node.addChildren(block.getChildren());
            node.setEndLocation(block.getEndLocation());
        }
        results.incMethodCount();
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public MethodNode MethodDeclarator() throws ParseException {
    Token t = null;
    String s = "";
    List f = null;
    try {
      t = jj_consume_token(IDENTIFIER);
      f = FormalParameters();
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ;
          break;
        default:
          break label_14;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        MethodNode node = new MethodNode();
        node.setName(t.image);
        node.setStartLocation(getLocation(t));
        node.setFormalParams(f);
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public List FormalParameters() throws ParseException {
    ArrayList params = new ArrayList();
    Parameter a = null;
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        a = FormalParameter();
                params.add(a);
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            break label_15;
          }
          jj_consume_token(COMMA);
          a = FormalParameter();
                    params.add(a);
        }
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return params;}
    throw new Error("Missing return statement in function");
  }

  final public Parameter FormalParameter() throws ParseException {
    Parameter param = new Parameter();
    TigerNode n;
    Type type_a = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINAL:
        jj_consume_token(FINAL);
          param.isFinal = true;
        break;
      default:
        ;
      }
      type_a = Type();
         param.type = type_a;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELLIPSIS:
        jj_consume_token(ELLIPSIS);
          param.isVarArg = true;
        break;
      default:
        ;
      }
      n = VariableDeclaratorId();
         param.name = n.getName();
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

  final public ConstructorNode ConstructorDeclaration() throws ParseException {
    Token t = null;
    List params = null;
    String a = "";
    String type_params = null;
    Token end_t = null;
    TigerNode child = null;
    ConstructorNode cn = new ConstructorNode();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        type_params = TypeParameters();
        break;
      default:
        ;
      }
      // Modifiers matched in the caller
                  t = jj_consume_token(IDENTIFIER);
      params = FormalParameters();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THROWS:
        jj_consume_token(THROWS);
        a = NameList();
        break;
      default:
        ;
      }
      jj_consume_token(LBRACE);
      if (jj_2_7(2147483647)) {
        ExplicitConstructorInvocation();
      } else {
        ;
      }
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSERT:
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CHAR:
        case CLASS:
        case CONTINUE:
        case DO:
        case DOUBLE:
        case FALSE:
        case FINAL:
        case FLOAT:
        case FOR:
        case IF:
        case INT:
        case INTERFACE:
        case LONG:
        case NEW:
        case NULL:
        case RETURN:
        case SHORT:
        case SUPER:
        case SWITCH:
        case SYNCHRONIZED:
        case THIS:
        case THROW:
        case TRUE:
        case TRY:
        case VOID:
        case WHILE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACE:
        case SEMICOLON:
        case INCR:
        case DECR:
          ;
          break;
        default:
          break label_16;
        }
        child = BlockStatement();
                                       if (child != null) cn.addChildren(child.getChildren());
      }
      end_t = jj_consume_token(RBRACE);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        cn.setName(t.image);
        cn.setStartLocation(new Location(t.beginLine, 0));
        cn.setEndLocation(getLocation(end_t));
        cn.setFormalParams(params);
        cn.setTypeParams(type_params);
        cn.setThrows(a);
        {if (true) return cn;}
    throw new Error("Missing return statement in function");
  }

  final public void ExplicitConstructorInvocation() throws ParseException {
    try {
      if (jj_2_9(2147483647)) {
        jj_consume_token(THIS);
        Arguments();
        jj_consume_token(SEMICOLON);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
          if (jj_2_8(2)) {
            PrimaryExpression();
            jj_consume_token(DOT);
          } else {
            ;
          }
          jj_consume_token(SUPER);
          Arguments();
          jj_consume_token(SEMICOLON);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

/**
 * @return an InitializerNode, this handles static initializer blocks
 */
  final public TigerNode Initializer() throws ParseException {
    Token t = null;
    BlockNode block = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATIC:
        t = jj_consume_token(STATIC);
        break;
      default:
        ;
      }
      block = Block();
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        if (t != null && block != null) {
            TigerNode node = new InitializerNode(t.beginLine);
            node.setStartLocation(block.getStartLocation());
            node.setEndLocation(block.getEndLocation());
            node.addChild(block);
            {if (true) return node;}
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/*
 * Type, name and expression syntax follows.
 */
  final public Type Type() throws ParseException {
    Type s = null;
    try {
      if (jj_2_10(2)) {
        s = ReferenceType();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case SHORT:
          s = PrimitiveType();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public Type ReferenceType() throws ParseException {
    Type s = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
        s = PrimitiveType();
        label_17:
        while (true) {
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
          if (jj_2_11(2)) {
            ;
          } else {
            break label_17;
          }
        }
        break;
      case IDENTIFIER:
        s = ClassOrInterfaceType();
        label_18:
        while (true) {
          if (jj_2_12(2)) {
            ;
          } else {
            break label_18;
          }
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public Type ClassOrInterfaceType() throws ParseException {
    Type s = new Type();
    String type_arg = "";
    Token t = null;
    try {
      t = jj_consume_token(IDENTIFIER);
      if (jj_2_13(2)) {
        type_arg = TypeArguments();
      } else {
        ;
      }
            s.type = t.image; s.typeArgs=type_arg;
      label_19:
      while (true) {
        if (jj_2_14(2)) {
          ;
        } else {
          break label_19;
        }
        jj_consume_token(DOT);
        t = jj_consume_token(IDENTIFIER);
        if (jj_2_15(2)) {
          type_arg = TypeArguments();
        } else {
          ;
        }
                s.type += "." + t.image; s.typeArgs += type_arg;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String TypeArguments() throws ParseException {
    String s = "<";
    String a = "";
    try {
      jj_consume_token(LT);
      a = TypeArgument();
                               s += a;
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_20;
        }
        jj_consume_token(COMMA);
        a = TypeArgument();
                                 s += "," + a;
      }
      jj_consume_token(GT);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s + ">";}
    throw new Error("Missing return statement in function");
  }

  final public String TypeArgument() throws ParseException {
    Type type = null;
    String s = "";
    String a = "";
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        type = ReferenceType();
                                  s=type.toString();
        break;
      case HOOK:
        jj_consume_token(HOOK);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXTENDS:
        case SUPER:
          a = WildcardBounds();
                                    s = "?" + a;
          break;
        default:
          ;
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String WildcardBounds() throws ParseException {
    Type type = null;
    String s = "";
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        jj_consume_token(EXTENDS);
        type = ReferenceType();
                                         s="extends " + type.toString();
        break;
      case SUPER:
        jj_consume_token(SUPER);
        type = ReferenceType();
                                       s="super " + type.toString();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public Type PrimitiveType() throws ParseException {
    Type s = new Type();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
                      s.type = "boolean";
        break;
      case CHAR:
        jj_consume_token(CHAR);
                   s.type = "char";
        break;
      case BYTE:
        jj_consume_token(BYTE);
                   s.type = "byte";
        break;
      case SHORT:
        jj_consume_token(SHORT);
                    s.type = "short";
        break;
      case INT:
        jj_consume_token(INT);
                  s.type = "int";
        break;
      case LONG:
        jj_consume_token(LONG);
                   s.type = "long";
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
                    s.type = "float";
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
                     s.type = "double";
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
      s.isPrimitive = true;
      {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String ResultType() throws ParseException {
    Type s = new Type();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        jj_consume_token(VOID);
            s.type = "void";
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        s = Type();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String Name() throws ParseException {
    Token t = null;
    String s = "";
    try {
      t = jj_consume_token(IDENTIFIER);
                         s = t.image;
      label_21:
      while (true) {
        if (jj_2_16(2)) {
          ;
        } else {
          break label_21;
        }
        jj_consume_token(DOT);
        t = jj_consume_token(IDENTIFIER);
                                            s += "." + t.image;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String NameList() throws ParseException {
    String s = "";
    String a = "";
    try {
      s = Name();
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_22;
        }
        jj_consume_token(COMMA);
        a = Name();
                                  s += "," + a;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
        {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

/*
 * Expression syntax follows.
 */
  final public void Expression() throws ParseException {
    try {
      ConditionalExpression();
      if (jj_2_17(2)) {
        AssignmentOperator();
        Expression();
      } else {
        ;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void AssignmentOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      break;
    case STARASSIGN:
      jj_consume_token(STARASSIGN);
      break;
    case SLASHASSIGN:
      jj_consume_token(SLASHASSIGN);
      break;
    case REMASSIGN:
      jj_consume_token(REMASSIGN);
      break;
    case PLUSASSIGN:
      jj_consume_token(PLUSASSIGN);
      break;
    case MINUSASSIGN:
      jj_consume_token(MINUSASSIGN);
      break;
    case LSHIFTASSIGN:
      jj_consume_token(LSHIFTASSIGN);
      break;
    case RSIGNEDSHIFTASSIGN:
      jj_consume_token(RSIGNEDSHIFTASSIGN);
      break;
    case RUNSIGNEDSHIFTASSIGN:
      jj_consume_token(RUNSIGNEDSHIFTASSIGN);
      break;
    case ANDASSIGN:
      jj_consume_token(ANDASSIGN);
      break;
    case XORASSIGN:
      jj_consume_token(XORASSIGN);
      break;
    case ORASSIGN:
      jj_consume_token(ORASSIGN);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ConditionalExpression() throws ParseException {
    try {
      ConditionalOrExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HOOK:
        jj_consume_token(HOOK);
        Expression();
        jj_consume_token(COLON);
        Expression();
        break;
      default:
        ;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void ConditionalOrExpression() throws ParseException {
    try {
      ConditionalAndExpression();
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC_OR:
          ;
          break;
        default:
          break label_23;
        }
        jj_consume_token(SC_OR);
        ConditionalAndExpression();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void ConditionalAndExpression() throws ParseException {
    try {
      InclusiveOrExpression();
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SC_AND:
          ;
          break;
        default:
          break label_24;
        }
        jj_consume_token(SC_AND);
        InclusiveOrExpression();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void InclusiveOrExpression() throws ParseException {
    try {
      ExclusiveOrExpression();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BIT_OR:
          ;
          break;
        default:
          break label_25;
        }
        jj_consume_token(BIT_OR);
        ExclusiveOrExpression();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void ExclusiveOrExpression() throws ParseException {
    try {
      AndExpression();
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case XOR:
          ;
          break;
        default:
          break label_26;
        }
        jj_consume_token(XOR);
        AndExpression();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void AndExpression() throws ParseException {
    try {
      EqualityExpression();
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BIT_AND:
          ;
          break;
        default:
          break label_27;
        }
        jj_consume_token(BIT_AND);
        EqualityExpression();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void EqualityExpression() throws ParseException {
    try {
      InstanceOfExpression();
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQ:
        case NE:
          ;
          break;
        default:
          break label_28;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQ:
          jj_consume_token(EQ);
          break;
        case NE:
          jj_consume_token(NE);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        InstanceOfExpression();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void InstanceOfExpression() throws ParseException {
    try {
      RelationalExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INSTANCEOF:
        jj_consume_token(INSTANCEOF);
        Type();
        break;
      default:
        ;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void RelationalExpression() throws ParseException {
    try {
      ShiftExpression();
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
        case LE:
        case GE:
        case GT:
          ;
          break;
        default:
          break label_29;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          jj_consume_token(LT);
          break;
        case GT:
          jj_consume_token(GT);
          break;
        case LE:
          jj_consume_token(LE);
          break;
        case GE:
          jj_consume_token(GE);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        ShiftExpression();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void ShiftExpression() throws ParseException {
    try {
      AdditiveExpression();
      label_30:
      while (true) {
        if (jj_2_18(1)) {
          ;
        } else {
          break label_30;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LSHIFT:
          jj_consume_token(LSHIFT);
          break;
        default:
          if (jj_2_19(1)) {
            RSIGNEDSHIFT();
          } else if (jj_2_20(1)) {
            RUNSIGNEDSHIFT();
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        AdditiveExpression();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void AdditiveExpression() throws ParseException {
    try {
      MultiplicativeExpression();
      label_31:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
          ;
          break;
        default:
          break label_31;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          break;
        case MINUS:
          jj_consume_token(MINUS);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        MultiplicativeExpression();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void MultiplicativeExpression() throws ParseException {
    try {
      UnaryExpression();
      label_32:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STAR:
        case SLASH:
        case REM:
          ;
          break;
        default:
          break label_32;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STAR:
          jj_consume_token(STAR);
          break;
        case SLASH:
          jj_consume_token(SLASH);
          break;
        case REM:
          jj_consume_token(REM);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        UnaryExpression();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void UnaryExpression() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          break;
        case MINUS:
          jj_consume_token(MINUS);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        UnaryExpression();
        break;
      case INCR:
        PreIncrementExpression();
        break;
      case DECR:
        PreDecrementExpression();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
        UnaryExpressionNotPlusMinus();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void PreIncrementExpression() throws ParseException {
    try {
      jj_consume_token(INCR);
      PrimaryExpression();
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void PreDecrementExpression() throws ParseException {
    try {
      jj_consume_token(DECR);
      PrimaryExpression();
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void UnaryExpressionNotPlusMinus() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BANG:
      case TILDE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TILDE:
          jj_consume_token(TILDE);
          break;
        case BANG:
          jj_consume_token(BANG);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        UnaryExpression();
        break;
      default:
        if (jj_2_21(2147483647)) {
          CastExpression();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BOOLEAN:
          case BYTE:
          case CHAR:
          case DOUBLE:
          case FALSE:
          case FLOAT:
          case INT:
          case LONG:
          case NEW:
          case NULL:
          case SHORT:
          case SUPER:
          case THIS:
          case TRUE:
          case VOID:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case IDENTIFIER:
          case LPAREN:
            PostfixExpression();
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
  final public void CastLookahead() throws ParseException {
    try {
      if (jj_2_22(2)) {
        jj_consume_token(LPAREN);
        PrimitiveType();
      } else if (jj_2_23(2147483647)) {
        jj_consume_token(LPAREN);
        Type();
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          Type();
          jj_consume_token(RPAREN);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TILDE:
            jj_consume_token(TILDE);
            break;
          case BANG:
            jj_consume_token(BANG);
            break;
          case LPAREN:
            jj_consume_token(LPAREN);
            break;
          case IDENTIFIER:
            jj_consume_token(IDENTIFIER);
            break;
          case THIS:
            jj_consume_token(THIS);
            break;
          case SUPER:
            jj_consume_token(SUPER);
            break;
          case NEW:
            jj_consume_token(NEW);
            break;
          case FALSE:
          case NULL:
          case TRUE:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
            Literal();
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void PostfixExpression() throws ParseException {
    try {
      PrimaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
      case DECR:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INCR:
          jj_consume_token(INCR);
          break;
        case DECR:
          jj_consume_token(DECR);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        ;
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void CastExpression() throws ParseException {
    try {
      if (jj_2_24(2147483647)) {
        jj_consume_token(LPAREN);
        Type();
        jj_consume_token(RPAREN);
        UnaryExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          Type();
          jj_consume_token(RPAREN);
          UnaryExpressionNotPlusMinus();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void PrimaryExpression() throws ParseException {
    try {
      PrimaryPrefix();
      label_33:
      while (true) {
        if (jj_2_25(2)) {
          ;
        } else {
          break label_33;
        }
        PrimarySuffix();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void MemberSelector() throws ParseException {
    try {
      jj_consume_token(DOT);
      TypeArguments();
      jj_consume_token(IDENTIFIER);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void PrimaryPrefix() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FALSE:
      case NULL:
      case TRUE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
        Literal();
        break;
      case THIS:
        jj_consume_token(THIS);
        break;
      case SUPER:
        jj_consume_token(SUPER);
        jj_consume_token(DOT);
        jj_consume_token(IDENTIFIER);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        Expression();
        jj_consume_token(RPAREN);
        break;
      case NEW:
        AllocationExpression();
        break;
      default:
        if (jj_2_26(2147483647)) {
          ResultType();
          jj_consume_token(DOT);
          jj_consume_token(CLASS);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            Name();
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void PrimarySuffix() throws ParseException {
    try {
      if (jj_2_27(2)) {
        jj_consume_token(DOT);
        jj_consume_token(THIS);
      } else if (jj_2_28(2)) {
        jj_consume_token(DOT);
        AllocationExpression();
      } else if (jj_2_29(3)) {
        MemberSelector();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
          break;
        case DOT:
          jj_consume_token(DOT);
          jj_consume_token(IDENTIFIER);
          break;
        case LPAREN:
          Arguments();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void Literal() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        jj_consume_token(INTEGER_LITERAL);
        break;
      case FLOATING_POINT_LITERAL:
        jj_consume_token(FLOATING_POINT_LITERAL);
        break;
      case CHARACTER_LITERAL:
        jj_consume_token(CHARACTER_LITERAL);
        break;
      case STRING_LITERAL:
        jj_consume_token(STRING_LITERAL);
        break;
      case FALSE:
      case TRUE:
        BooleanLiteral();
        break;
      case NULL:
        NullLiteral();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void BooleanLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
      break;
    case FALSE:
      jj_consume_token(FALSE);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NullLiteral() throws ParseException {
    jj_consume_token(NULL);
  }

  final public void Arguments() throws ParseException {
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ArgumentList();
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
    } catch (ParseException pe) {
        error_skipto(SEMICOLON);
    }
  }

  final public void ArgumentList() throws ParseException {
    try {
      Expression();
      label_34:
      while (true)
