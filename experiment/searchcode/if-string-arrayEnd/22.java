/*
 * VeriParser.java
 * 
 * last update: 30.01.2010 by Vlad Badoiu
 * 
 * author:	JavaCC ?
 * 
 * Obs: Generated By:JavaCC: Do not edit this line. VeriParser.java
 */

package engine;

import java.io.*;
import java.util.*;
import middle.*;

/**
 * Tha main class.
 */
public class VeriParser implements VeriParserConstants {

	static Hashtable moduleDescriptions;
	public static Hashtable builtinGates = new Hashtable();

	static { //initialize the
		//standard primitives:
		try {
			Class.forName("engine.StdGateDescription");
		} catch (ClassNotFoundException cnfex) {
			throw new Error("oops: " + cnfex);
		}
	}
	static ModuleDescription curModule;

	static HashSet instantiatedModules;

	public static Vector exportedModules;

	public static final String topName = "@top";

	/**
	 * The current filename
	 */
	public static String fileName;

	/**
	 * This should nullify as many references as it can, 
	 * in order to help gc.
	 */
	public static void performCleanup(){
		moduleDescriptions = null;
		instantiatedModules = null;
		exportedModules = null;
		Preprocessor.performCleanup();
		//    System.gc(); //see Time.runSimulation
	}

	static void init() {
		moduleDescriptions = new Hashtable(builtinGates);
		instantiatedModules = new HashSet();
		exportedModules = new Vector();
		Preprocessor.init();
	}

	/**
	 * this one fixes some stuff pending due to textual order or implicit conventions
	 */
	public static void performCheckup()throws ParseException{
		for(Enumeration e = moduleDescriptions.elements() ; e.hasMoreElements() ; ){
			try {
				((DefaultNameSpaceDescription)e.nextElement()).checkup();
			} catch (ClassCastException cex) {}
		}
	}

	// transforms \t, \n. \ddd & \" in strings
	// for now, only used within the VeriParser, but...
	public static String stringTran(String s) throws ParseException{
		String result = new String("");
		int j;
		while (!s.equals("")) {
			j = s.indexOf('\\');
			if (j == -1) return result + s;
			if (j > 0) result += s.substring(0, j);
			xConsole.debug("result: \"" + result + "\"");
			char c = s.charAt(j+1);
			switch (c) {
			case '"':
			case '\\': result += c;  break;
			case 't': result += "\t";  break;
			case 'n': result += "\n";  break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
				int x = c - '0';
				for (int count = 0; count < 2 && j+2 < s.length(); count++) {
					c = s.charAt(j+2);
					if (c >= '0' && c <= '7') {
						j++;
						x = x << 3 + c - '0';
					}
				}
				result  = result + c; //simplu, dom'le !
				// uh... la faza asta... nu stiu.  (Power)
				break;
			default: throw new ParseException("Invalid escape sequence in string");
			}
			s = s.substring(j+2);
		}
		return result;
	}


	/**
	 * Eliminates underscores from s.
	 * (used for numbers)
	 */
	public static String unUnderscore(String s){
		char [] cs = s.toCharArray();
		char [] cs1 = new char[cs.length];
		int i, j;
		for(i = j = 0 ; i < cs.length ; i++)
			if(cs[i] != '_')
				cs1[j++] = cs[i];
		return new String(cs1, 0, j);
	}

	////////////////////////////////////////////////////////////
	//
	// DONE WITH LEXICAL STUFF
	//
	//////////////////////////////////////////////////////////
	final public void start(String fileName) throws ParseException {
		trace_call("start");
		try {
			int line = 0;
			switch (jj_nt.kind) {
			case EXPORT:
				exportStatement();
				break;
			default:
				jj_la1[0] = jj_gen;
				;
			}
			label_1:
				while (true) {
					switch (jj_nt.kind) {
					case PRIMITIVE:
						startUdp(fileName);
						break;
					case MODULE:
					case MACROMODULE:
						startModule(fileName);
						break;
					case DEFNETTYPE:
						defaultNetType();
						break;
					default:
						jj_la1[1] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					switch (jj_nt.kind) {
					case MODULE:
					case MACROMODULE:
					case PRIMITIVE:
					case DEFNETTYPE:
						;
						break;
					default:
						jj_la1[2] = jj_gen;
						break label_1;
					}
				}
		} finally {
			trace_return("start");
		}
	}

	final public void exportStatement() throws ParseException {
		trace_call("exportStatement");
		try {
			String s;
			jj_consume_token(EXPORT);
			jj_consume_token(PAREN_OPEN);
			label_2:
				while (true) {
					s = name();
					exportedModules.add(s);
					switch (jj_nt.kind) {
					case IDENTIFIER:
						;
						break;
					default:
						jj_la1[3] = jj_gen;
						break label_2;
					}
				}
			jj_consume_token(PAREN_CLOSE);
			jj_consume_token(SEMICOLON);
		} finally {
			trace_return("exportStatement");
		}
	}

	final public void defaultNetType() throws ParseException {
		trace_call("defaultNetType");
		try {
			int netType = 0;
			jj_consume_token(DEFNETTYPE);
			switch (jj_nt.kind) {
			case WIRE:
				jj_consume_token(WIRE);
				netType = Assignable.typeWire;
				break;
			case WAND:
				jj_consume_token(WAND);
				netType = Assignable.typeWand;
				break;
			case WOR:
				jj_consume_token(WOR);
				netType = Assignable.typeWor;
				break;
			case TRI:
				jj_consume_token(TRI);
				netType = Assignable.typeTrireg;
				break;
			case TRIAND:
				jj_consume_token(TRIAND);
				netType = Assignable.typeTriand;
				break;
			case TRIOR:
				jj_consume_token(TRIOR);
				netType = Assignable.typeTrior;
				break;
			case TRIREG:
				jj_consume_token(TRIREG);
				netType = Assignable.typeTrireg;
				break;
			case TRI0:
				jj_consume_token(TRI0);
				netType = Assignable.typeTri0;
				break;
			case TRI1:
				jj_consume_token(TRI1);
				netType = Assignable.typeTri1;
				break;
			default:
				jj_la1[4] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			jj_consume_token(COMMA);
			WireDescription.defaultNetType = netType;
		} finally {
			trace_return("defaultNetType");
		}
	}

	////////////////////////////////////////////////////////
	//
	//          UDP STRUCTURE
	//
	/////////////////////////////////////////////////////////
	final public void startUdp(String fileName) throws ParseException {
		trace_call("startUdp");
		try {
			int lineNo;
			String te;
			UDPDescription udp;
			jj_consume_token(PRIMITIVE);
			lineNo = token.beginLine;
			name();
			udp = new UDPDescription(token.image, lineNo, fileName);
			moduleDescriptions.put(token.image, udp);
			xConsole.cout("parsing UDP: "+ token.image + '\n');
			jj_consume_token(PAREN_OPEN);
			switch (jj_nt.kind) {
			case IDENTIFIER:
				UDPPortListItem(udp, PortDescription.output);
				label_3:
					while (true) {
						switch (jj_nt.kind) {
						case COMMA:
							;
							break;
						default:
							jj_la1[5] = jj_gen;
							break label_3;
						}
						jj_consume_token(COMMA);
						UDPPortListItem(udp, PortDescription.input);
					}
				break;
			default:
				jj_la1[6] = jj_gen;
				;
			}
			jj_consume_token(PAREN_CLOSE);
			jj_consume_token(SEMICOLON);
			label_4:
				while (true) {
					switch (jj_nt.kind) {
					case INPUT:
					case OUTPUT:
						;
						break;
					default:
						jj_la1[7] = jj_gen;
						break label_4;
					}
					switch (jj_nt.kind) {
					case INPUT:
						inputDeclare(udp);
						break;
					case OUTPUT:
						outputDeclare(udp);
						break;
					default:
						jj_la1[8] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					jj_consume_token(SEMICOLON);
				}
			switch (jj_nt.kind) {
			case REG:
				regDeclare(udp);
				jj_consume_token(SEMICOLON);
				if(udp.type == UDPDescription.UNKType)
					udp.type |= UDPDescription.SEQType;
				else {if (true) throw new ParseException(udp.toString(token.beginLine) +
						": error: an UDP can have only one register");}
				label_5:
					while (true) {
						switch (jj_nt.kind) {
						case INPUT:
						case OUTPUT:
							;
							break;
						default:
							jj_la1[9] = jj_gen;
							break label_5;
						}
						switch (jj_nt.kind) {
						case INPUT:
							inputDeclare(udp);
							break;
						case OUTPUT:
							outputDeclare(udp);
							break;
						default:
							jj_la1[10] = jj_gen;
							jj_consume_token(-1);
							throw new ParseException();
						}
						jj_consume_token(SEMICOLON);
					}
						switch (jj_nt.kind) {
						case INITIAL:
							UDPInitial(udp);
							break;
						default:
							jj_la1[11] = jj_gen;
							;
						}
						jj_consume_token(TABLE);
						label_6:
							while (true) {
								te = UDPTableSEQEntry();
								udp.addTableEntry(te, token.beginLine);
								switch (jj_nt.kind) {
								case SYM_0:
								case SYM_1:
								case SYM_B:
								case SYM_F:
								case SYM_N:
								case SYM_P:
								case SYM_R:
								case SYM_X:
								case SYM_QUESTION:
								case SYM_ANY:
								case PAREN_OPEN:
									;
									break;
								default:
									jj_la1[12] = jj_gen;
									break label_6;
								}
							}
						jj_consume_token(ENDTABLE);
						break;
			case TABLE:
				jj_consume_token(TABLE);
				udp.type |= UDPDescription.COMType;
				label_7:
					while (true) {
						te = UDPTableCOMEntry();
						udp.addTableEntry(te, token.beginLine);
						switch (jj_nt.kind) {
						case SYM_0:
						case SYM_1:
						case SYM_B:
						case SYM_X:
						case SYM_QUESTION:
							;
							break;
						default:
							jj_la1[13] = jj_gen;
							break label_7;
						}
					}
				jj_consume_token(ENDTABLE);
				break;
			default:
				jj_la1[14] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			jj_consume_token(ENDPRIMITIVE);
		} finally {
			trace_return("startUdp");
		}
	}

	final public void UDPInitial(UDPDescription udp) throws ParseException {
		trace_call("UDPInitial");
		try {
			ProcAssignInstrucDescription paid;
			String reg, initValue;
			jj_consume_token(INITIAL);
			if (udp.type != UDPDescription.SEQType)
			{if (true) throw new ParseException(udp.toString(token.beginLine) +
					": error: combinational UDP's cannot have initializer");}
			reg = name();
			if (udp.regs.get(token.image) == null)
			{if (true) throw new ParseException(udp.toString(token.beginLine) +
					": error: only he UDP's state can be initialized");}
			jj_consume_token(EQUAL);
			jj_consume_token(INITVALUE);
			initValue = token.image;
			jj_consume_token(SEMICOLON);
			udp.addInitial(new
					ProcAssignInstrucDescription(0, token.beginLine, udp,
							new GenericSelectorDescription(new FQNDescription(reg),
									null, null,
									false),
									ConstantDescription.createNewUnsignedConstantDescription(1,
											2,
											initValue),
											0, true), token.beginLine);
		} finally {
			trace_return("UDPInitial");
		}
	}

	final public String UDPTableCOMEntry() throws ParseException {
		trace_call("UDPTableCOMEntry");
		try {
			StringBuffer ent = new StringBuffer();
			String tmp;
			label_8:
				while (true) {
					tmp = levelSymbol();
					ent.append(tmp);
					switch (jj_nt.kind) {
					case SYM_0:
					case SYM_1:
					case SYM_B:
					case SYM_X:
					case SYM_QUESTION:
						;
						break;
					default:
						jj_la1[15] = jj_gen;
						break label_8;
					}
				}
			jj_consume_token(COLON);
			tmp = outputSymbol();
			ent.append(tmp);
			jj_consume_token(SEMICOLON);
			{if (true) return new String(ent);}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("UDPTableCOMEntry");
		}
	}

	final public String UDPTableSEQEntry() throws ParseException {
		trace_call("UDPTableSEQEntry");
		try {
			StringBuffer ent = new StringBuffer();
			String tmp;
			boolean edgeUsed = false;
			label_9:
				while (true) {
					switch (jj_nt.kind) {
					case SYM_0:
					case SYM_1:
					case SYM_B:
					case SYM_X:
					case SYM_QUESTION:
						tmp = levelSymbol();
						break;
					case SYM_F:
					case SYM_N:
					case SYM_P:
					case SYM_R:
					case SYM_ANY:
					case PAREN_OPEN:
						tmp = edgeSymbol();
						break;
					default:
						jj_la1[16] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					ent.append(tmp);
					switch (jj_nt.kind) {
					case SYM_0:
					case SYM_1:
					case SYM_B:
					case SYM_F:
					case SYM_N:
					case SYM_P:
					case SYM_R:
					case SYM_X:
					case SYM_QUESTION:
					case SYM_ANY:
					case PAREN_OPEN:
						;
						break;
					default:
						jj_la1[17] = jj_gen;
						break label_9;
					}
				}
			jj_consume_token(COLON);
			tmp = levelSymbol();
			ent.append(tmp);
			jj_consume_token(COLON);
			switch (jj_nt.kind) {
			case SYM_0:
			case SYM_1:
			case SYM_B:
			case SYM_X:
			case SYM_QUESTION:
				tmp = levelSymbol();
				break;
			case SYM_SAME:
				jj_consume_token(SYM_SAME);
				tmp = "-";
				break;
			default:
				jj_la1[18] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			ent.append(tmp);
			jj_consume_token(SEMICOLON);
			{if (true) return new String(ent);}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("UDPTableSEQEntry");
		}
	}

	final public String outputSymbol() throws ParseException {
		trace_call("outputSymbol");
		try {
			switch (jj_nt.kind) {
			case SYM_0:
				jj_consume_token(SYM_0);
				break;
			case SYM_1:
				jj_consume_token(SYM_1);
				break;
			case SYM_X:
				jj_consume_token(SYM_X);
				break;
			default:
				jj_la1[19] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			{if (true) return token.image.toLowerCase();}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("outputSymbol");
		}
	}

	final public String edgeSymbol() throws ParseException {
		trace_call("edgeSymbol");
		try {
			StringBuffer s = new StringBuffer();
			switch (jj_nt.kind) {
			case SYM_F:
			case SYM_N:
			case SYM_P:
			case SYM_R:
			case SYM_ANY:
				switch (jj_nt.kind) {
				case SYM_R:
					jj_consume_token(SYM_R);
					break;
				case SYM_F:
					jj_consume_token(SYM_F);
					break;
				case SYM_P:
					jj_consume_token(SYM_P);
					break;
				case SYM_N:
					jj_consume_token(SYM_N);
					break;
				case SYM_ANY:
					jj_consume_token(SYM_ANY);
					break;
				default:
					jj_la1[20] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
				s.append(token.image.toLowerCase());
				break;
			case PAREN_OPEN:
				jj_consume_token(PAREN_OPEN);
				levelSymbol();
				s.append("(" + token.image.toLowerCase());
				levelSymbol();
				s.append(token.image.toLowerCase() + ")");
				jj_consume_token(PAREN_CLOSE);
				break;
			default:
				jj_la1[21] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			{if (true) return new String(s);}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("edgeSymbol");
		}
	}

	final public String levelSymbol() throws ParseException {
		trace_call("levelSymbol");
		try {
			switch (jj_nt.kind) {
			case SYM_0:
				jj_consume_token(SYM_0);
				break;
			case SYM_1:
				jj_consume_token(SYM_1);
				break;
			case SYM_X:
				jj_consume_token(SYM_X);
				break;
			case SYM_B:
				jj_consume_token(SYM_B);
				break;
			case SYM_QUESTION:
				jj_consume_token(SYM_QUESTION);
				break;
			default:
				jj_la1[22] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			{if (true) return token.image.toLowerCase();}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("levelSymbol");
		}
	}

	final public void UDPPortListItem(UDPDescription udp, int type) throws ParseException {
		trace_call("UDPPortListItem");
		try {
			GenericSelectorDescription gsd;
			String id;
			name();
			udp.addPort(token.image, token.beginLine, type);
			udp.addConnection(token.image, token.beginLine,
					new GenericSelectorDescription(new
							FQNDescription(token.image),
							null, null, false));
		} finally {
			trace_return("UDPPortListItem");
		}
	}

	////////////////////////////////////////////////////////
	//
	//            MODULE STRUCTURE
	//
	///////////////////////////////////////////////////////_
	final public void startModule(String fileName) throws ParseException {
		trace_call("startModule");
		try {
			int line = 0;
			switch (jj_nt.kind) {
			case MODULE:
				jj_consume_token(MODULE);
				break;
			case MACROMODULE:
				jj_consume_token(MACROMODULE);
				break;
			default:
				jj_la1[23] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			line = token.beginLine;
			name();
			curModule = new ModuleDescription(fileName, line, token.image);
			moduleDescriptions.put(token.image, curModule);
			xConsole.cout("parsing module: " + token.image + '\n');
			switch (jj_nt.kind) {
			case PAREN_OPEN:
				portList(curModule);
				break;
			default:
				jj_la1[24] = jj_gen;
				;
			}
			jj_consume_token(SEMICOLON);
			label_10:
				while (true) {
					switch (jj_nt.kind) {
					case WIRE:
					case WAND:
					case WOR:
					case TRI:
					case TRIAND:
					case TRIOR:
					case TRIREG:
					case INOUT:
					case INTEGER:
					case REAL:
					case TIME:
					case REALTIME:
					case EVENT:
					case PARAMETER:
					case OR:
					case INPUT:
					case OUTPUT:
					case REG:
					case IDENTIFIER:
						;
						break;
					default:
						jj_la1[25] = jj_gen;
						break label_10;
					}
					moduleDeclare(curModule);
				}
			label_11:
				while (true) {
					switch (jj_nt.kind) {
					case ALWAYS:
					case DEFPARAM:
					case ASSIGN:
					case TASK:
					case FUNCTION:
					case INITIAL:
						;
						break;
					default:
						jj_la1[26] = jj_gen;
						break label_11;
					}
					moduleItem(curModule);
				}
				jj_consume_token(ENDMODULE);
		} finally {
			trace_return("startModule");
		}
	}

	final public void portList(NameSpaceDescription nsd) throws ParseException {
		trace_call("portList");
		try {
			int i = 0;
			jj_consume_token(PAREN_OPEN);
			portListItem(nsd, i++);
			label_12:
				while (true) {
					switch (jj_nt.kind) {
					case COMMA:
						;
						break;
					default:
						jj_la1[27] = jj_gen;
						break label_12;
					}
					jj_consume_token(COMMA);
					portListItem(nsd, i++);
				}
			jj_consume_token(PAREN_CLOSE);
		} finally {
			trace_return("portList");
		}
	}

	/**
	 * Unlike the standard, we allow mixing of named/unnamed connections, but
	 * we assign implicit name <unnamed#0..> to the unnamed ones
	 */
	final public void portListItem(NameSpaceDescription nsd, int i) throws ParseException {
		trace_call("portListItem");
		try {
			ExpressionDescription exd = null;
			int lineNo = 0;
			String name = "<unnamed#" + i + ">";
			if (jj_2_1(3)) {
				jj_consume_token(POINT);
				name = name();
				lineNo = token.beginLine;
				jj_consume_token(PAREN_OPEN);
				switch (jj_nt.kind) {
				case POINT:
				case BRACE_OPEN:
				case IDENTIFIER:
					exd = portSelection();
					break;
				default:
					jj_la1[28] = jj_gen;
					;
				}
				jj_consume_token(PAREN_CLOSE);
			} else {
				switch (jj_nt.kind) {
				case POINT:
				case BRACE_OPEN:
				case IDENTIFIER:
					exd = portSelection();
					lineNo = token.beginLine;
					try{
						//if it's a single name, it is equivalent to a named port:
							GenericSelectorDescription gsd = (GenericSelectorDescription) exd;
							if (!gsd.hasLimits) {
								if (gsd.fqn.len() > 1)
								{if (true) throw new ParseException ("bad port name: \"" + gsd.fqn + "\"");}
								name = (String) gsd.fqn.node; //this should contain only one node !
								nsd.addPort(name, lineNo, PortDescription.none);
							}
					}catch(ClassCastException ex){}
					break;
				default:
					jj_la1[29] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			nsd.addConnection(name, lineNo, exd);
		} finally {
			trace_return("portListItem");
		}
	}

	final public ExpressionDescription portSelection() throws ParseException {
		trace_call("portSelection");
		try {
			SelectionExpressionDescription sed = new SelectionExpressionDescription();
			ExpressionDescription c;
			switch (jj_nt.kind) {
			case POINT:
			case IDENTIFIER:
				c = symbolSelection();
				{if (true) return c;}
				break;
			case BRACE_OPEN:
				jj_consume_token(BRACE_OPEN);
				c = symbolSelection();
				sed.addChunk(c);
				label_13:
					while (true) {
						switch (jj_nt.kind) {
						case COMMA:
							;
							break;
						default:
							jj_la1[30] = jj_gen;
							break label_13;
						}
						jj_consume_token(COMMA);
						c = symbolSelection();
						sed.addChunk(c);
					}
				jj_consume_token(BRACE_CLOSE);
				{if (true) return sed;}
				break;
			default:
				jj_la1[31] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("portSelection");
		}
	}

	final public void blockDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("blockDeclare");
		try {
			switch (jj_nt.kind) {
			case PARAMETER:
				paramDeclare(ns);
				break;
			case REG:
				regDeclare(ns);
				break;
			case INTEGER:
				integerDeclare(ns);
				break;
			case REAL:
				realDeclare(ns);
				break;
			case TIME:
				timeDeclare(ns);
				break;
			case REALTIME:
				realtimeDeclare(ns);
				break;
			case EVENT:
				eventDeclare(ns);
				break;
			default:
				jj_la1[32] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			jj_consume_token(SEMICOLON);
		} finally {
			trace_return("blockDeclare");
		}
	}

	final public void moduleDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("moduleDeclare");
		try {
			switch (jj_nt.kind) {
			case INTEGER:
			case REAL:
			case TIME:
			case REALTIME:
			case EVENT:
			case PARAMETER:
			case REG:
				blockDeclare(ns);
				break;
			case WIRE:
			case WAND:
			case WOR:
			case TRI:
			case TRIAND:
			case TRIOR:
			case TRIREG:
			case INOUT:
			case OR:
			case INPUT:
			case OUTPUT:
			case IDENTIFIER:
				switch (jj_nt.kind) {
				case WIRE:
				case WAND:
				case WOR:
				case TRI:
				case TRIAND:
				case TRIOR:
				case TRIREG:
					netDeclare(ns);
					break;
				case INPUT:
					inputDeclare(ns);
					break;
				case OUTPUT:
					outputDeclare(ns);
					break;
				case INOUT:
					inoutDeclare(ns);
					break;
				case OR:
				case IDENTIFIER:
					moduleInstanceDeclare(ns);
					break;
				default:
					jj_la1[33] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
				jj_consume_token(SEMICOLON);
				break;
			default:
				jj_la1[34] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		} finally {
			trace_return("moduleDeclare");
		}
	}

	final public void moduleItem(NameSpaceDescription ns) throws ParseException {
		trace_call("moduleItem");
		try {
			switch (jj_nt.kind) {
			case FUNCTION:
				functionItem(ns);
				break;
			case TASK:
				taskItem(ns);
				break;
			case INITIAL:
				initialItem(ns);
				break;
			case ASSIGN:
				assignItem(ns);
				break;
			case ALWAYS:
				alwaysItem(ns);
				break;
			case DEFPARAM:
				defParamItem(ns);
				break;
			default:
				jj_la1[35] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		} finally {
			trace_return("moduleItem");
		}
	}

	//_______________________________________
	//
	//           MODULE DECLARES
	//_______________________________________
	final public void timeDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("timeDeclare");
		try {
			int lineNo;
			jj_consume_token(TIME);
			lineNo = token.beginLine;
		} finally {
			trace_return("timeDeclare");
		}
	}

	final public void realtimeDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("realtimeDeclare");
		try {
			int lineNo;
			jj_consume_token(REALTIME);
			lineNo = token.beginLine;
		} finally {
			trace_return("realtimeDeclare");
		}
	}

	final public void eventDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("eventDeclare");
		try {
			int lineNo;
			jj_consume_token(EVENT);
			lineNo = token.beginLine;
		} finally {
			trace_return("eventDeclare");
		}
	}

	final public void paramDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("paramDeclare");
		try {
			ExpressionDescription ex;
			String sym;
			int lineNo;
			jj_consume_token(PARAMETER);
			sym = name();
			ns.addParameter(sym, token.beginLine);
			switch (jj_nt.kind) {
			case EQUAL:
				jj_consume_token(EQUAL);
				ex = expression();
				curModule.defParam(sym, ex);
				break;
			default:
				jj_la1[36] = jj_gen;
				;
			}
		} finally {
			trace_return("paramDeclare");
		}
	}

	final public void realDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("realDeclare");
		try {
			String id;
			jj_consume_token(REAL);
			id = name();
			ns.addReal(id, token.beginLine);
			label_14:
				while (true) {
					switch (jj_nt.kind) {
					case COMMA:
						;
						break;
					default:
						jj_la1[37] = jj_gen;
						break label_14;
					}
					jj_consume_token(COMMA);
					id = name();
					ns.addReal(id, token.beginLine);
				}
		} finally {
			trace_return("realDeclare");
		}
	}

	final public void integerDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("integerDeclare");
		try {
			String id;
			ExpressionDescription arrayStart = null, arrayEnd = null;
			int lineNo;
			jj_consume_token(INTEGER);
			id = name();
			lineNo = token.beginLine;
			switch (jj_nt.kind) {
			case SQ_BRA:
				jj_consume_token(SQ_BRA);
				arrayStart = expression();
				jj_consume_token(COLON);
				arrayEnd = expression();
				jj_consume_token(SQ_KET);
				break;
			default:
				jj_la1[38] = jj_gen;
				;
			}
			ns.addInteger(id, lineNo, arrayStart, arrayEnd);
			arrayStart = arrayEnd = null;
			label_15:
				while (true) {
					switch (jj_nt.kind) {
					case COMMA:
						;
						break;
					default:
						jj_la1[39] = jj_gen;
						break label_15;
					}
					jj_consume_token(COMMA);
					id = name();
					lineNo = token.beginLine;
					switch (jj_nt.kind) {
					case SQ_BRA:
						jj_consume_token(SQ_BRA);
						arrayStart = expression();
						jj_consume_token(COLON);
						arrayEnd = expression();
						jj_consume_token(SQ_KET);
						break;
					default:
						jj_la1[40] = jj_gen;
						;
					}
					ns.addInteger(id, lineNo, arrayStart, arrayEnd);
					arrayStart = arrayEnd = null;
				}
		} finally {
			trace_return("integerDeclare");
		}
	}

	final public void regDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("regDeclare");
		try {
			String id;
			int nStart = 0, nEnd = 0;
			ExpressionDescription  arrayStart = null , arrayEnd = null;
			ExpressionDescription msb = null, lsb = null;
			int lineNo;
			jj_consume_token(REG);
			switch (jj_nt.kind) {
			case SQ_BRA:
				jj_consume_token(SQ_BRA);
				msb = expression();
				jj_consume_token(COLON);
				lsb = expression();
				jj_consume_token(SQ_KET);
				break;
			default:
				jj_la1[41] = jj_gen;
				;
			}
			id = name();
			lineNo = token.beginLine;
			switch (jj_nt.kind) {
			case SQ_BRA:
				jj_consume_token(SQ_BRA);
				arrayStart = expression();
				jj_consume_token(COLON);
				arrayEnd = expression();
				jj_consume_token(SQ_KET);
				break;
			default:
				jj_la1[42] = jj_gen;
				;
			}
			ns.addRegister(id, lineNo, msb, lsb, arrayStart, arrayEnd);
			arrayStart = arrayEnd = null;
			label_16:
				while (true) {
					switch (jj_nt.kind) {
					case COMMA:
						;
						break;
					default:
						jj_la1[43] = jj_gen;
						break label_16;
					}
					jj_consume_token(COMMA);
					id = name();
					lineNo = token.beginLine;
					switch (jj_nt.kind) {
					case SQ_BRA:
						jj_consume_token(SQ_BRA);
						arrayStart = expression();
						jj_consume_token(COLON);
						arrayEnd = expression();
						jj_consume_token(SQ_KET);
						break;
					default:
						jj_la1[44] = jj_gen;
						;
					}
					ns.addRegister(id, lineNo, msb, lsb, arrayStart, arrayEnd);
					arrayStart = arrayEnd = null;
				}
		} finally {
			trace_return("regDeclare");
		}
	}

	final public void netDeclare(NameSpaceDescription nsd) throws ParseException {
		trace_call("netDeclare");
		try {
			String id;
			ExpressionDescription msb = null, lsb = null;
			int expandType = WireDescription.vectored; //the implicit is correct ??
			int lineNo;
			Delay3Description delays = Delay3Description.nullDelay;
			byte strength = Strength.defaultStrength;
			int netType = -1;
			switch (jj_nt.kind) {
			case WIRE:
			case WAND:
			case WOR:
			case TRI:
			case TRIAND:
			case TRIOR:
				switch (jj_nt.kind) {
				case WIRE:
				case TRI:
					switch (jj_nt.kind) {
					case WIRE:
						jj_consume_token(WIRE);
						break;
					case TRI:
						jj_consume_token(TRI);
						break;
					default:
						jj_la1[45] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					netType = Assignable.typeWire;
					break;
				case WAND:
				case TRIAND:
					switch (jj_nt.kind) {
					case WAND:
						jj_consume_token(WAND);
						break;
					case TRIAND:
						jj_consume_token(TRIAND);
						break;
					default:
						jj_la1[46] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					netType = Assignable.typeWand;
					break;
				case WOR:
				case TRIOR:
					switch (jj_nt.kind) {
					case WOR:
						jj_consume_token(WOR);
						break;
					case TRIOR:
						jj_consume_token(TRIOR);
						break;
					default:
						jj_la1[47] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					netType = Assignable.typeWor;
					break;
				default:
					jj_la1[48] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
				switch (jj_nt.kind) {
				case VECTORED:
				case SCALARED:
					switch (jj_nt.kind) {
					case VECTORED:
						jj_consume_token(VECTORED);
						expandType = WireDescription.vectored;
						break;
					case SCALARED:
						jj_consume_token(SCALARED);
						expandType = WireDescription.scalared;
						break;
					default:
						jj_la1[49] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					break;
				default:
					jj_la1[50] = jj_gen;
					;
				}
				if (jj_2_2(3)) {
					switch (jj_nt.kind) {
					case PAREN_OPEN:
						strength = driveStrength();
						break;
					default:
						jj_la1[51] = jj_gen;
						;
					}
					switch (jj_nt.kind) {
					case SQ_BRA:
						jj_consume_token(SQ_BRA);
						msb = expression();
						jj_consume_token(COLON);
						lsb = expression();
						jj_consume_token(SQ_KET);
						break;
					default:
						jj_la1[52] = jj_gen;
						;
					}
					switch (jj_nt.kind) {
					case DIEZ:
						delays = delay3(nsd);
						break;
					default:
						jj_la1[53] = jj_gen;
						;
					}
					netDeclareWithAssignItem(nsd, msb, lsb, expandType, netType, delays, strength);
					label_17:
						while (true) {
							switch (jj_nt.kind) {
							case COMMA:
								;
								break;
							default:
								jj_la1[54] = jj_gen;
								break label_17;
							}
							jj_consume_token(COMMA);
							netDeclareWithAssignItem(nsd, msb, lsb, expandType, netType, delays,
									strength);
						}
				} else {
					switch (jj_nt.kind) {
					case DIEZ:
					case SQ_BRA:
					case IDENTIFIER:
						switch (jj_nt.kind) {
						case SQ_BRA:
							jj_consume_token(SQ_BRA);
							msb = expression();
							jj_consume_token(COLON);
							lsb = expression();
							jj_consume_token(SQ_KET);
							break;
						default:
							jj_la1[55] = jj_gen;
							;
						}
						switch (jj_nt.kind) {
						case DIEZ:
							delays = delay3(nsd);
							break;
						default:
							jj_la1[56] = jj_gen;
							;
						}
						netDeclareItem(nsd, msb, lsb, expandType, netType, delays, strength);
						label_18:
							while (true) {
								switch (jj_nt.kind) {
								case COMMA:
									;
									break;
								default:
									jj_la1[57] = jj_gen;
									break label_18;
								}
								jj_consume_token(COMMA);
								netDeclareItem(nsd, msb, lsb, expandType, netType, delays,
										strength);
							}
						break;
					default:
						jj_la1[58] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
				}
				break;
			case TRIREG:
				jj_consume_token(TRIREG);
				netType = Assignable.typeTrireg;
				switch (jj_nt.kind) {
				case VECTORED:
				case SCALARED:
					switch (jj_nt.kind) {
					case VECTORED:
						jj_consume_token(VECTORED);
						expandType = WireDescription.vectored;
						break;
					case SCALARED:
						jj_consume_token(SCALARED);
						expandType = WireDescription.scalared;
						break;
					default:
						jj_la1[59] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					break;
				default:
					jj_la1[60] = jj_gen;
					;
				}
				switch (jj_nt.kind) {
				case PAREN_OPEN:
					strength = chargeStrength();
					break;
				default:
					jj_la1[61] = jj_gen;
					;
				}
				switch (jj_nt.kind) {
				case SQ_BRA:
					jj_consume_token(SQ_BRA);
					msb = expression();
					jj_consume_token(COLON);
					lsb = expression();
					jj_consume_token(SQ_KET);
					break;
				default:
					jj_la1[62] = jj_gen;
					;
				}
				switch (jj_nt.kind) {
				case DIEZ:
					delays = delay3(nsd);
					break;
				default:
					jj_la1[63] = jj_gen;
					;
				}
				netDeclareItem(nsd, msb, lsb, expandType, netType, delays, strength);
				label_19:
					while (true) {
						switch (jj_nt.kind) {
						case COMMA:
							;
							break;
						default:
							jj_la1[64] = jj_gen;
							break label_19;
						}
						jj_consume_token(COMMA);
						netDeclareItem(nsd, msb, lsb, expandType, netType, delays,
								strength);
					}
				break;
			default:
				jj_la1[65] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		} finally {
			trace_return("netDeclare");
		}
	}

	final public void netDeclareWithAssignItem(NameSpaceDescription nsd, ExpressionDescription msb, ExpressionDescription lsb,
			int expandType, int netType,  Delay3Description delays, byte strength) throws ParseException {
		trace_call("netDeclareWithAssignItem");
		try {
			int lineNo;
			String id;
			ExpressionDescription rVal;
			id = name();
			lineNo = token.beginLine;
			nsd.addWire(id, lineNo, msb, lsb, expandType, netType, delays);
			switch (jj_nt.kind) {
			case EQUAL:
				jj_consume_token(EQUAL);
				rVal = expression();
				nsd.addConnection(lineNo,
						new GenericSelectorDescription(new FQNDescription(id)),
						rVal, delays, Strength.defaultStrength);
				break;
			default:
				jj_la1[66] = jj_gen;
				;
			}
		} finally {
			trace_return("netDeclareWithAssignItem");
		}
	}

	final public void netDeclareItem(NameSpaceDescription nsd, ExpressionDescription msb, ExpressionDescription lsb,
			int expandType, int netType,  Delay3Description delays, byte strength) throws ParseException {
		trace_call("netDeclareItem");
		try {
			int lineNo;
			String id;
			id = name();
			lineNo = token.beginLine;
			nsd.addWire(id, lineNo, msb, lsb, expandType, netType, delays);
		} finally {
			trace_return("netDeclareItem");
		}
	}

	final public void inputDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("inputDeclare");
		try {
			ExpressionDescription msb = null, lsb = null;
			jj_consume_token(INPUT);
			switch (jj_nt.kind) {
			case SQ_BRA:
				jj_consume_token(SQ_BRA);
				msb = expression();
				jj_consume_token(COLON);
				lsb = expression();
				jj_consume_token(SQ_KET);
				break;
			default:
				jj_la1[67] = jj_gen;
				;
			}
			name();
			ns.addPort(token.image, token.beginLine, PortDescription.input, msb, lsb);
			label_20:
				while (true) {
					switch (jj_nt.kind) {
					case COMMA:
						;
						break;
					default:
						jj_la1[68] = jj_gen;
						break label_20;
					}
					jj_consume_token(COMMA);
					name();
					ns.addPort(token.image, token.beginLine, PortDescription.input, msb, lsb);
				}
		} finally {
			trace_return("inputDeclare");
		}
	}

	final public void outputDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("outputDeclare");
		try {
			ExpressionDescription msb = null, lsb = null;
			jj_consume_token(OUTPUT);
			switch (jj_nt.kind) {
			case SQ_BRA:
				jj_consume_token(SQ_BRA);
				msb = expression();
				jj_consume_token(COLON);
				lsb = expression();
				jj_consume_token(SQ_KET);
				break;
			default:
				jj_la1[69] = jj_gen;
				;
			}
			name();
			ns.addPort(token.image, token.beginLine, PortDescription.output, msb, lsb);
			label_21:
				while (true) {
					switch (jj_nt.kind) {
					case COMMA:
						;
						break;
					default:
						jj_la1[70] = jj_gen;
						break label_21;
					}
					jj_consume_token(COMMA);
					name();
					ns.addPort(token.image, token.beginLine, PortDescription.output, msb, lsb);
				}
		} finally {
			trace_return("outputDeclare");
		}
	}

	final public void inoutDeclare(NameSpaceDescription ns) throws ParseException {
		trace_call("inoutDeclare");
		try {
			ExpressionDescription msb = null, lsb = null;
			jj_consume_token(INOUT);
			switch (jj_nt.kind) {
			case SQ_BRA:
				jj_consume_token(SQ_BRA);
				msb = expression();
				jj_consume_token(COLON);
				lsb = expression();
				jj_consume_token(SQ_KET);
				break;
			default:
				jj_la1[71] = jj_gen;
				;
			}
			name();
			ns.addPort(token.image, token.beginLine, PortDescription.inout, msb, lsb);
			label_22:
				while (true) {
					switch (jj_nt.kind) {
					case COMMA:
						;
						break;
					default:
						jj_la1[72] = jj_gen;
						break label_22;
					}
					jj_consume_token(COMMA);
					name();
					ns.addPort(token.image, token.beginLine, PortDescription.inout, msb, lsb);
				}
		} finally {
			trace_return("inoutDeclare");
		}
	}

	//note that this does not verify for corectness of
	//the instantiation (the number of arguments, etc)
	final public void moduleInstanceDeclare(NameSpaceDescription nsd) throws ParseException {
		trace_call("moduleInstanceDeclare");
		try {
			String descName;
			Vector parameters = new Vector();
			Delay3Description delays = null;
			ExpressionDescription exp = null;
			byte strength = Strength.defaultStrength;
			switch (jj_nt.kind) {
			case IDENTIFIER:
				descName = name();
				break;
			case OR:
				jj_consume_token(OR);
				descName = token.image; /*'or' fix*/
				break;
			default:
				jj_la1[73] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			switch (jj_nt.kind) {
			case PAREN_OPEN:
				strength = driveStrength();
				break;
			default:
				jj_la1[74] = jj_gen;
				;
			}
			switch (jj_nt.kind) {
			case DIEZ:
				if (jj_2_3(2147483647)) {
					delays = delay3(nsd);
				} else {
					switch (jj_nt.kind) {
					case DIEZ:
						jj_consume_token(DIEZ);
						jj_consume_token(PAREN_OPEN);
						exp = expression();
						parameters.addElement(exp);
						label_23:
							while (true) {
								switch (jj_nt.kind) {
								case COMMA:
									;
									break;
								default:
									jj_la1[75] = jj_gen;
									break label_23;
								}
								jj_consume_token(COMMA);
								exp = expression();
								parameters.addElement(exp);
							}
						jj_consume_token(PAREN_CLOSE);
						break;
					default:
						jj_la1[76] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
				}
				break;
			default:
				jj_la1[77] = jj_gen;
				;
			}
			moduleInstance(nsd, descName, parameters, strength, delays);
			label_24:
				while (true) {
					switch (jj_nt.kind) {
					case COMMA:
						;
						break;
					default:
						jj_la1[78] = jj_gen;
						break label_24;
					}
					jj_consume_token(COMMA);
					moduleInstance(nsd, descName, parameters, strength, delays);
				}
			instantiatedModules.add(descName);
		} finally {
			trace_return("moduleInstanceDeclare");
		}
	}

	final public void moduleInstance(NameSpaceDescription nsd, String descName,
			Vector<ExpressionDescription> parameters, byte strength, Delay3Description delays) throws ParseException {
		trace_call("moduleInstance");
		try {
			String moduleName = null;
			Vector<ExpressionDescription> portsVector = new Vector<ExpressionDescription>();
			Hashtable<String, ConnectionDescription> portsHash = new Hashtable<String, ConnectionDescription>();
			ExpressionDescription exp = null, rangeStart = null, rangeEnd = null;
			ExpressionDescription moduleArrayStart = null, moduleArrayEnd = null;
			int lineNo = 0; //make javac happy 
			String name;
			switch (jj_nt.kind) {
			case IDENTIFIER:
				moduleName = name();
				lineNo = token.beginLine;
				break;
			default:
				jj_la1[79] = jj_gen;
				;
			}
			switch (jj_nt.kind) {
			case SQ_BRA:
				jj_consume_token(SQ_BRA);
				moduleArrayStart = expression();
				jj_consume_token(COLON);
				moduleArrayEnd = expression();
				jj_consume_token(SQ_KET);
				break;
			default:
				jj_la1[80] = jj_gen;
				;
			}
			switch (jj_nt.kind) {
			case PAREN_OPEN:
				jj_consume_token(PAREN_OPEN);
				lineNo = token.beginLine;
				if (jj_2_4(3)) {
					jj_consume_token(POINT);
					name = name();
					lineNo = token.beginLine;
					switch (jj_nt.kind) {
					case SQ_BRA:
						jj_consume_token(SQ_BRA);
						rangeStart = expression();
						jj_consume_token(COLON);
						rangeEnd = expression();
						jj_consume_token(SQ_KET);
						break;
					default:
						jj_la1[81] = jj_gen;
						;
					}
					jj_consume_token(PAREN_OPEN);
					switch (jj_nt.kind) {
					case ST_TIME:
					case POINT:
					case ADD:
					case SUB:
					case LNEG:
					case BNEG:
					case BAND:
					case BOR:
					case BXOR:
					case BNAND:
					case BNOR:
					case BNXOR:
					case BRACE_OPEN:
					case STRING:
					case unsigned_number:
					case bin_number:
					case oct_number:
					case dec_number:
					case hex_number:
					case real_number:
					case IDENTIFIER:
					case PAREN_OPEN:
						exp = expression();
						break;
					default:
						jj_la1[82] = jj_gen;
						;
					}
					portsHash.put(name, new ConnectionDescription (name,
							lineNo,
							exp));
					jj_consume_token(PAREN_CLOSE);
					label_25:
						while (true) {
							switch (jj_nt.kind) {
							case COMMA:
								;
								break;
							default:
								jj_la1[83] = jj_gen;
								break label_25;
							}
							jj_consume_token(COMMA);
							jj_consume_token(POINT);
							name = name();
							lineNo = token.beginLine; exp = null;
							jj_consume_token(PAREN_OPEN);
							switch (jj_nt.kind) {
							case ST_TIME:
							case POINT:
							case ADD:
							case SUB:
							case LNEG:
							case BNEG:
							case BAND:
							case BOR:
							case BXOR:
							case BNAND:
							case BNOR:
							case BNXOR:
							case BRACE_OPEN:
							case STRING:
							case unsigned_number:
							case bin_number:
							case oct_number:
							case dec_number:
							case hex_number:
							case real_number:
							case IDENTIFIER:
							case PAREN_OPEN:
								exp = expression();
								break;
							default:
								jj_la1[84] = jj_gen;
								;
							}
							portsHash.put(name, new ConnectionDescription (name,
									lineNo,
									exp));
							jj_consume_token(PAREN_CLOSE);
						}
				} else {
					switch (jj_nt.kind) {
					case ST_TIME:
					case POINT:
					case ADD:
					case SUB:
					case LNEG:
					case BNEG:
					case BAND:
					case BOR:
					case BXOR:
					case BNAND:
					case BNOR:
					case BNXOR:
					case BRACE_OPEN:
					case STRING:
					case unsigned_number:
					case bin_number:
					case oct_number:
					case dec_number:
					case hex_number:
					case real_number:
					case IDENTIFIER:
					case PAREN_OPEN:
						exp = expression();
						break;
					default:
						jj_la1[85] = jj_gen;
						;
					}
					portsVector.addElement(exp);exp = null;
					label_26:
						while (true) {
							switch (jj_nt.kind) {
							case COMMA:
								;
								break;
							default:
								jj_la1[86] = jj_gen;
								break label_26;
							}
							jj_consume_token(COMMA);
							switch (jj_nt.kind) {
							case ST_TIME:
							case POINT:
							case ADD:
							case SUB:
							case LNEG:
							case BNEG:
							case BAND:
							case BOR:
							case BXOR:
							case BNAND:
							case BNOR:
							case BNXOR:
							case BRACE_OPEN:
							case STRING:
							case unsigned_number:
							case bin_number:
							case oct_number:
							case dec_number:
							case hex_number:
							case real_number:
							case IDENTIFIER:
							case PAREN_OPEN:
								exp = expression();
								break;
							default:
								jj_la1[87] = jj_gen;
								;
							}
							portsVector.addElement(exp);exp = null;
						}
				}
				jj_consume_token(PAREN_CLOSE);
				break;
			default:
				jj_la1[88] = jj_gen;
				;
			}
			if (moduleName == null)
				if (builtinGates.get(descName) != null)
					moduleName = ((StdGateDescription) builtinGates.get(descName)).createNewName();
				else
				{if (true) throw new ParseException("instance name expected");}

			if(moduleArrayStart != null)
				nsd.addModuleArray(moduleName, lineNo, descName, moduleArrayStart,
						moduleArrayEnd, portsVector, portsHash, parameters,
						strength, delays);
			else
				nsd.addSubModule(moduleName, lineNo,
						descName, portsVector,
						portsHash, parameters,
						strength, delays);
		} finally {
			trace_return("moduleInstance");
		}
	}

	//////////////////////////////////////////////
	//
	//           MODULE ITEMS
	//
	///////////////////////////////////////////////
	final public void functionItem(NameSpaceDescription nsd) throws ParseException {
		trace_call("functionItem");
		try {
			String name;
			int type;
			ExpressionDescription msb = null, lsb = null;
			FunctionDescription fd;
			InstructionDescription i;
			int line;
			jj_consume_token(FUNCTION);
			line = token.beginLine;
			switch (jj_nt.kind) {
			case REAL:
				jj_consume_token(REAL);
				type = Symbol.realType;
				break;
			case INTEGER:
				jj_consume_token(INTEGER);
				type = Symbol.intType;
				break;
			case SQ_BRA:
				jj_consume_token(SQ_BRA);
				msb = expression();
				jj_consume_token(COLON);
				lsb = expression();
				jj_consume_token(SQ_KET);
				type = Symbol.regType;
				break;
			default:
				jj_la1[89] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			name = name();
			jj_consume_token(SEMICOLON);
			fd = type == Symbol.regType ? new FunctionDescription(nsd, name, line, msb, lsb) :
				new FunctionDescription(nsd, name, line, type);
			label_27:
				while (true) {
					switch (jj_nt.kind) {
					case INTEGER:
					case REAL:
					case TIME:
					case REALTIME:
					case EVENT:
					case PARAMETER:
					case INPUT:
					case REG:
						;
						break;
					default:
						jj_la1[90] = jj_gen;
						break label_27;
					}
					switch (jj_nt.kind) {
					case INTEGER:
					case REAL:
					case TIME:
					case REALTIME:
					case EVENT:
					case PARAMETER:
					case REG:
						blockDeclare(fd);
						break;
					case INPUT:
						inputDeclare(fd);
						break;
					default:
						jj_la1[91] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					jj_consume_token(SEMICOLON);
				}
			i = instruction(fd);
			fd.addInstruction(i);
			jj_consume_token(ENDFUNCTION);
		} finally {
			trace_return("functionItem");
		}
	}

	final public void taskItem(NameSpaceDescription nsd) throws ParseException {
		trace_call("taskItem");
		try {
			TaskDescription td;
			InstructionDescription i = null;
			String name;
			jj_consume_token(TASK);
			name = name();
			jj_consume_token(SEMICOLON);
			td = new TaskDescription(nsd, name, token.beginLine);
			label_28:
				while (true) {
					switch (jj_nt.kind) {
					case INOUT:
					case INTEGER:
					case REAL:
					case TIME:
					case REALTIME:
					case EVENT:
					case PARAMETER:
					case INPUT:
					case OUTPUT:
					case REG:
						;
						break;
					default:
						jj_la1[92] = jj_gen;
						break label_28;
					}
					switch (jj_nt.kind) {
					case INTEGER:
					case REAL:
					case TIME:
					case REALTIME:
					case EVENT:
					case PARAMETER:
					case REG:
						blockDeclare(td);
						break;
					case INOUT:
					case INPUT:
					case OUTPUT:
						switch (jj_nt.kind) {
						case INPUT:
							inputDeclare(td);
							break;
						case OUTPUT:
							outputDeclare(td);
							break;
						case INOUT:
							inoutDeclare(td);
							break;
						default:
							jj_la1[93] = jj_gen;
							jj_consume_token(-1);
							throw new ParseException();
						}
						jj_consume_token(SEMICOLON);
						break;
					default:
						jj_la1[94] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
				}
			switch (jj_nt.kind) {
			case BEGIN:
			case IF:
			case CASE:
			case CASEX:
			case CASEZ:
			case FOR:
			case WHILE:
			case REPEAT:
			case FORK:
			case DISPLAY:
			case DISPLAYB:
			case DISPLAYO:
			case DISPLAYH:
			case WRITE:
			case WRITEB:
			case WRITEO:
			case WRITEH:
			case MONITOR:
			case MONITORB:
			case MONITORO:
			case MONITORH:
			case STROBE:
			case STROBEB:
			case STROBEO:
			case STROBEH:
			case COUT:
			case STOP:
			case FINISH:
			case DIEZ:
			case POINT:
			case AT:
			case BRACE_OPEN:
			case IDENTIFIER:
			case SEMICOLON:
				i = instruction(td);
				td.addInstruction(i);
				break;
			default:
				jj_la1[95] = jj_gen;
				;
			}
			jj_consume_token(ENDTASK);
		} finally {
			trace_return("taskItem");
		}
	}

	final public void defParamItem(NameSpaceDescription ns) throws ParseException {
		trace_call("defParamItem");
		try {
			String sym;
			ExpressionDescription ex;
			jj_consume_token(DEFPARAM);
			sym = name();
			switch (jj_nt.kind) {
			case EQUAL:
				jj_consume_token(EQUAL);
				ex = expression();
				ns.defParam(sym, ex);
				break;
			default:
				jj_la1[96] = jj_gen;
				;
			}
		} finally {
			trace_return("defParamItem");
		}
	}

	final public void assignItem(NameSpaceDescription nsd) throws ParseException {
		trace_call("assignItem");
		try {
			AssignableSelection lVal;
			ExpressionDescription rVal;
			int lineNo;
			Delay3Description delays = Delay3Description.nullDelay;;
			byte strength = Strength.defaultStrength;
			jj_consume_token(ASSIGN);
			switch (jj_nt.kind) {
			case PAREN_OPEN:
				strength = driveStrength();
				break;
			default:
				jj_la1[97] = jj_gen;
				;
			}
			switch (jj_nt.kind) {
			case DIEZ:
				delays = delay3(nsd);
				break;
			default:
				jj_la1[98] = jj_gen;
				;
			}
			lVal = lValue();
			lineNo = token.beginLine;
			jj_consume_token(EQUAL);
			rVal = expression();
			nsd.addConnection(lineNo, lVal, rVal, delays, strength);
			label_29:
				while (true) {
					switch (jj_nt.kind) {
					case COMMA:
						;
						break;
					default:
						jj_la1[99] = jj_gen;
						break label_29;
					}
					jj_consume_token(COMMA);
					lVal = lValue();
					lineNo = token.beginLine;
					jj_consume_token(EQUAL);
					rVal = expression();
					nsd.addConnection(lineNo, lVal, rVal, delays, strength);
				}
			jj_consume_token(SEMICOLON);
		} finally {
			trace_return("assignItem");
		}
	}

	/**
	 * Trireg charge strength
	 */
	final public byte chargeStrength() throws ParseException {
		trace_call("chargeStrength");
		try {
			byte strength = Strength.defaultTriregStrength;
			jj_consume_token(PAREN_OPEN);
			jj_consume_token(SMALL);
			strength = Strength.small;
			jj_consume_token(MEDIUM);
			strength = Strength.medium;
			jj_consume_token(LARGE);
			strength = Strength.large;
			jj_consume_token(PAREN_CLOSE);
			{if (true) return Strength.getStrength(strength, strength);}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("chargeStrength");
		}
	}

	final public byte driveStrength() throws ParseException {
		trace_call("driveStrength");
		try {
			byte s0, s1;
			jj_consume_token(PAREN_OPEN);
			switch (jj_nt.kind) {
			case SUPPLY0:
			case STRONG0:
			case PULL0:
			case WEAK0:
			case HIGHZ0:
				s0 = strength0();
				jj_consume_token(COMMA);
				s1 = strength1();
				break;
			case SUPPLY1:
			case STRONG1:
			case PULL1:
			case WEAK1:
			case HIGHZ1:
				s1 = strength1();
				jj_consume_token(COMMA);
				s0 = strength0();
				break;
			default:
				jj_la1[100] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			jj_consume_token(PAREN_CLOSE);
			{if (true) return Strength.getStrength(s0, s1);}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("driveStrength");
		}
	}

	final public byte strength1() throws ParseException {
		trace_call("strength1");
		try {
			switch (jj_nt.kind) {
			case SUPPLY1:
				jj_consume_token(SUPPLY1);
				{if (true) return Strength.supply;}
				break;
			case STRONG1:
				jj_consume_token(STRONG1);
				{if (true) return Strength.strong;}
				break;
			case PULL1:
				jj_consume_token(PULL1);
				{if (true) return Strength.pull;}
				break;
			case WEAK1:
				jj_consume_token(WEAK1);
				{if (true) return Strength.weak;}
				break;
			case HIGHZ1:
				jj_consume_token(HIGHZ1);
				{if (true) return Strength.highz;}
				break;
			default:
				jj_la1[101] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("strength1");
		}
	}

	final public byte strength0() throws ParseException {
		trace_call("strength0");
		try {
			switch (jj_nt.kind) {
			case SUPPLY0:
				jj_consume_token(SUPPLY0);
				{if (true) return Strength.supply;}
				break;
			case STRONG0:
				jj_consume_token(STRONG0);
				{if (true) return Strength.strong;}
				break;
			case PULL0:
				jj_consume_token(PULL0);
				{if (true) return Strength.pull;}
				break;
			case WEAK0:
				jj_consume_token(WEAK0);
				{if (true) return Strength.weak;}
				break;
			case HIGHZ0:
				jj_consume_token(HIGHZ0);
				{if (true) return Strength.highz;}
				break;
			default:
				jj_la1[102] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("strength0");
		}
	}

	//this SelctionExpression will be a concatenatinio of part-selects only
	// (i.e. no inner concatenation are allowed).
	final public AssignableSelection lValue() throws ParseException {
		trace_call("lValue");
		try {
			SelectionExpressionDescription sed = new SelectionExpressionDescription();
			GenericSelectorDescription c;
			switch (jj_nt.kind) {
			case POINT:
			case IDENTIFIER:
				c = symbolSelection();
				{if (true) return c;}
				break;
			case BRACE_OPEN:
				jj_consume_token(BRACE_OPEN);
				c = symbolSelection();
				sed.addChunk(c);
				label_30:
					while (true) {
						switch (jj_nt.kind) {
						case COMMA:
							;
							break;
						default:
							jj_la1[103] = jj_gen;
							break label_30;
						}
						jj_consume_token(COMMA);
						c = symbolSelection();
						sed.addChunk(c);
					}
				jj_consume_token(BRACE_CLOSE);
				{if (true) return sed;}
				break;
			default:
				jj_la1[104] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("lValue");
		}
	}

	final public void initialItem(NameSpaceDescription nsd) throws ParseException {
		trace_call("initialItem");
		try {
			InstructionDescription i;
			int lineNo;
			jj_consume_token(INITIAL);
			lineNo = token.beginLine;
			i = instruction(nsd);
			nsd.addInitial(i, lineNo);
		} finally {
			trace_return("initialItem");
		}
	}

	final public void alwaysItem(NameSpaceDescription nsd) throws ParseException {
		trace_call("alwaysItem");
		try {
			InstructionDescription i;
			int lineNo;
			jj_consume_token(ALWAYS);
			lineNo = token.beginLine;
			i = instruction(nsd);
			nsd.addAlways(i, lineNo);
		} finally {
			trace_return("alwaysItem");
		}
	}

	final public InstructionDescription instruction(NameSpaceDescription nsd) throws ParseException {
		trace_call("instruction");
		try {
			InstructionDescription i = null;
			int delayBefore = 0;
			int line = 0;
			switch (jj_nt.kind) {
			case DIEZ:
				delayBefore = delay();
				break;
			default:
				jj_la1[105] = jj_gen;
				;
			}
			if (jj_2_5(2)) {
				i = begin(delayBefore, nsd);
			} else if (jj_2_6(2147483647)) {
				i = procAssign(delayBefore, nsd);
			} else {
				switch (jj_nt.kind) {
				case DISPLAY:
				case DISPLAYB:
				case DISPLAYO:
				case DISPLAYH:
				case WRITE:
				case WRITEB:
				case WRITEO:
				case WRITEH:
				case MONITOR:
				case MONITORB:
				case MONITORO:
				case MONITORH:
				case STROBE:
				case STROBEB:
				case STROBEO:
				case STROBEH:
				case COUT:
					i = systemTask(delayBefore, nsd);
					break;
				case AT:
					i = atInstruction(delayBefore, nsd);
					break;
				case REPEAT:
					i = repeatInstruction(delayBefore, nsd);
					break;
				case IF:
					i = ifInstruction(delayBefore, nsd);
					break;
				case CASE:
				case CASEX:
				case CASEZ:
					i = caseInstruction(delayBefore, nsd);
					break;
				case FOR:
					i = forInstruction(delayBefore, nsd);
					break;
				case WHILE:
					i = whileInstruction(delayBefore, nsd);
					break;
				case FORK:
					i = forkInstruction(delayBefore, nsd);
					break;
				case POINT:
				case IDENTIFIER:
					i = taskEnableInstruction(delayBefore, nsd);
					break;
				case STOP:
				case FINISH:
					i = simCtrlTaskInstruction(delayBefore, nsd);
					break;
				case SEMICOLON:
					jj_consume_token(SEMICOLON);
					break;
				default:
					jj_la1[106] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			line = token.beginLine;
			{if (true) return i == null ? new EmptyInstructionDescription(delayBefore, line, nsd) : i;}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("instruction");
		}
	}

	final public InstructionDescription simCtrlTaskInstruction(int delayBefore, NameSpaceDescription nsd) throws ParseException {
		trace_call("simCtrlTaskInstruction");
		try {
			String codeImage = null;
			int code;
			boolean isaStop = true;
			switch (jj_nt.kind) {
			case STOP:
				jj_consume_token(STOP);
				break;
			case FINISH:
				jj_consume_token(FINISH);
				isaStop = false;
				break;
			default:
				jj_la1[107] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			switch (jj_nt.kind) {
			case PAREN_OPEN:
				jj_consume_token(PAREN_OPEN);
				switch (jj_nt.kind) {
				case unsigned_number:
					jj_consume_token(unsigned_number);
					codeImage = token.image;
					break;
				default:
					jj_la1[108] = jj_gen;
					;
				}
				jj_consume_token(PAREN_CLOSE);
				break;
			default:
				jj_la1[109] = jj_gen;
				;
			}
			jj_consume_token(SEMICOLON);
			try {
				if (codeImage != null)
					code = Integer.parseInt(codeImage);
				else code = 0;
				if ((code < 0) || (code > 2))
				{if (true) throw new NumberFormatException();}
			} catch (NumberFormatException nfex) {
				{if (true) throw new ParseException("bad " + (isaStop ? "\"$stop\"" : "\"$finish\"") + " code");}
			}
			if (isaStop)
			{if (true) return new StopTaskDescription(delayBefore, token.beginLine, nsd, code);}
			else
			{if (true) return new FinishTaskDescription(delayBefore, token.beginLine, nsd, code);}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("simCtrlTaskInstruction");
		}
	}

	final public InstructionDescription systemTask(int delayBefore, NameSpaceDescription nsd) throws ParseException {
		trace_call("systemTask");
		try {
			xConsole.debug("systemTask");
			InstructionDescription i;
			switch (jj_nt.kind) {
			case DISPLAY:
			case DISPLAYB:
			case DISPLAYO:
			case DISPLAYH:
				i = displayTask(delayBefore, nsd);
				break;
			case COUT:
				i = coutTask(delayBefore, nsd);
				break;
			case WRITE:
			case WRITEB:
			case WRITEO:
			case WRITEH:
				i = writeTask(delayBefore, nsd);
				break;
			case STROBE:
			case STROBEB:
			case STROBEO:
			case STROBEH:
				i = strobeTask(delayBefore, nsd);
				break;
			case MONITOR:
			case MONITORB:
			case MONITORO:
			case MONITORH:
				i = monitorTask(delayBefore, nsd);
				break;
			default:
				jj_la1[110] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			{if (true) return i;}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("systemTask");
		}
	}

	final public Vector expressionList() throws ParseException {
		trace_call("expressionList");
		try {
			Vector theList = new Vector();
			ExpressionDescription anExpression;
			anExpression = expression();
			theList.addElement(anExpression);
			label_31:
				while (true) {
					switch (jj_nt.kind) {
					case COMMA:
						;
						break;
					default:
						jj_la1[111] = jj_gen;
						break label_31;
					}
					jj_consume_token(COMMA);
					anExpression = expression();
					theList.addElement(anExpression);
				}
			{if (true) return theList;}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expressionList");
		}
	}

	final public InstructionDescription taskEnableInstruction(int delayBefore, NameSpaceDescription nsd) throws ParseException {
		trace_call("taskEnableInstruction");
		try {
			FQNDescription taskName;
			int line;
			Vector paramsList = null;
			taskName = fqName();
			line = token.beginLine;
			switch (jj_nt.kind) {
			case PAREN_OPEN:
				jj_consume_token(PAREN_OPEN);
				paramsList = expressionList();
				jj_consume_token(PAREN_CLOSE);
				break;
			default:
				jj_la1[112] = jj_gen;
				;
			}
			jj_consume_token(SEMICOLON);
			{if (true) return new TaskInstructionDescription(delayBefore, line, nsd, taskName, paramsList == null ? new Vector() : paramsList);}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("taskEnableInstruction");
		}
	}

	final public InstructionDescription forkInstruction(int delayBefore, NameSpaceDescription nsd) throws ParseException {
		trace_call("forkInstruction");
		try {
			ForkDescription fork;
			InstructionDescription id;
			int line;
			String label = null;
			jj_consume_token(FORK);
			line = token.beginLine;
			switch (jj_nt.kind) {
			case COLON:
				jj_consume_token(COLON);
				label = name();
				break;
			default:
				jj_la1[113] = jj_gen;
				;
			}
			fork = new ForkDescription(delayBefore, line, nsd, label);
			label_32:
				while (true) {
					id = instruction(fork);
					fork.addInside(id);
					switch (jj_nt.kind) {
					case BEGIN:
					case IF:
					case CASE:
					case CASEX:
					case CASEZ:
					case FOR:
					case WHILE:
					case REPEAT:
					case FORK:
					case DISPLAY:
					case DISPLAYB:
					case DISPLAYO:
					case DISPLAYH:
					case WRITE:
					case WRITEB:
					case WRITEO:
					case WRITEH:
					case MONITOR:
					case MONITORB:
					case MONITORO:
					case MONITORH:
					case STROBE:
					case STROBEB:
					case STROBEO:
					case STROBEH:
				
