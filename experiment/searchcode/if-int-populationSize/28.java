package lib.easyjava.ml.optimization.ga;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This implements a Genetic Algorithm for optimization of arbitrary structures.
 * It can run generation-by-generation optimization of any type implementing
 * GeneticAlgorithmSolution correctly.
 *
 * @author Rob Rua (robrua@alumni.cmu.edu)
 *
 * @param <T>
 *            the type of solution to be optimized
 */
public class GeneticAlgorithmOptimizer<T extends GeneticAlgorithmSolution> {
    private static class SolutionComparator implements Comparator<GeneticAlgorithmSolution> {
        @Override
        public int compare(final GeneticAlgorithmSolution arg0, final GeneticAlgorithmSolution arg1) {
            final long diff = arg1.fitness() - arg0.fitness();

            if(diff > 0) {
                return 1;
            }
            else if(diff < 0) {
                return -1;
            }
            else {
                return 0;
            }
        }
    }

    private static final double DEFAULT_CROSSOVER_RATE = .75;
    private static final double DEFAULT_ELITE_PERCENTAGE = .2;
    private static final double DEFAULT_MUTATION_RATE = .1;
    private static final int DEFAULT_POPULATION_SIZE = 20;
    private static final SolutionComparator SOLUTION_COMPARATOR = new SolutionComparator();
    private final int eliteCount;
    private final double mutationRate, crossoverRate;
    private final List<T> population;

    /**
     * Creates an optimizer which generates a randomized initial population with
     * default population size, mutation, crossover, and elite rates.
     *
     * @param factory
     *            the factory which produces random solutions for the initial
     *            population
     */
    public GeneticAlgorithmOptimizer(final AbstractSolutionFactory<T> factory) {
        this(DEFAULT_POPULATION_SIZE, DEFAULT_MUTATION_RATE, DEFAULT_CROSSOVER_RATE, DEFAULT_ELITE_PERCENTAGE, factory);
    }

    /**
     * Creates an optimizer which generates a randomized initial population with
     * default mutation, crossover, and elite rates.
     *
     * @param populationSize
     *            the number of solutions in each generation
     * @param factory
     *            the factory which produces random solutions for the initial
     *            population
     */
    public GeneticAlgorithmOptimizer(final int populationSize, final AbstractSolutionFactory<T> factory) {
        this(populationSize, DEFAULT_MUTATION_RATE, DEFAULT_CROSSOVER_RATE, DEFAULT_ELITE_PERCENTAGE, factory);
    }

    /**
     * Creates an optimizer which generates a randomized initial population.
     *
     * @param populationSize
     *            the number of solutions in each generation
     * @param mutationRate
     *            the chance for a new solution to randomly mutate
     * @param crossoverRate
     *            the chance for a new solution to be generated by combination
     *            of two elite solutions, rather than cloned from one
     * @param elitePercentage
     *            the percentage of solutions in each generation to be
     *            considered elite. The best elitePercentage solutions are
     *            elite.
     * @param factory
     *            the factory which produces random solutions for the initial
     *            population
     */
    public GeneticAlgorithmOptimizer(final int populationSize, final double mutationRate, final double crossoverRate, final double elitePercentage,
            final AbstractSolutionFactory<T> factory) {
        population = new ArrayList<T>(populationSize);
        for(int i = 0; i < populationSize; i++) {
            population.add(factory.randomSolution());
        }

        rankPopulation();
        this.mutationRate = mutationRate;
        this.crossoverRate = crossoverRate;
        eliteCount = (int)(elitePercentage * populationSize);
    }

    /**
     * Creates an optimizer which runs starting from the initially seeded
     * population default mutation, crossover, and elite rates.
     *
     * @param population
     *            the initial population to optimize
     */
    public GeneticAlgorithmOptimizer(final List<T> population) {
        this(population, DEFAULT_MUTATION_RATE, DEFAULT_CROSSOVER_RATE, DEFAULT_ELITE_PERCENTAGE);
    }

    /**
     * Creates an optimizer which runs starting from the initially seeded
     * population.
     *
     * @param population
     *            the initial population to optimize
     * @param mutationRate
     *            the chance for a new solution to randomly mutate
     * @param crossoverRate
     *            the chance for a new solution to be generated by combination
     *            of two elite solutions, rather than cloned from one
     * @param elitePercentage
     *            the percentage of solutions in each generation to be
     *            considered elite. The best elitePercentage solutions are
     *            elite.
     */
    public GeneticAlgorithmOptimizer(final List<T> population, final double mutationRate, final double crossoverRate, final double elitePercentage) {
        this.population = population;
        rankPopulation();
        this.mutationRate = mutationRate;
        this.crossoverRate = crossoverRate;
        eliteCount = (int)(elitePercentage * population.size());
    }

    @SuppressWarnings("unchecked")
    private void fillGeneration() {
        List<T> sublist = population.subList(eliteCount, population.size());
        sublist = sublist.parallelStream().map((solution) -> {
            T newSol;
            if(Math.random() < crossoverRate) {
                newSol = (T)randomEliteSolution().crossover(randomEliteSolution());
            }
            else {
                newSol = (T)randomEliteSolution().copy();
            }

            if(Math.random() < mutationRate) {
                newSol.mutate();
            }

            return newSol;
        }).collect(Collectors.toList());

        for(int i = eliteCount; i < population.size(); i++) {
            population.set(i, sublist.get(i - eliteCount));
        }
    }

    /**
     * Proceeds to the next generation
     */
    public void nextGeneration() {
        fillGeneration();
        rankPopulation();
    }

    /**
     * Returns the current population ordered by fitness.
     *
     * @return the current population
     */
    public List<T> population() {
        return Collections.unmodifiableList(population);
    }

    private T randomEliteSolution() {
        return population.get((int)(Math.random() * eliteCount));
    }

    private void rankPopulation() {
        Collections.sort(population, SOLUTION_COMPARATOR);
    }

    /**
     * Proceeds the specified number of generations
     *
     * @param generations
     *            the number of generations to move forward
     */
    public void runFor(final int generations) {
        for(int i = 0; i < generations; i++) {
            nextGeneration();
        }
    }
}

