/*
 * DynamicJava - Copyright (C) 1999-2001
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL DYADE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Dyade shall not be
 * used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from
 * Dyade.
 *
 */

/* Generated By:JavaCC: Do not edit this line. Parser.java */
package koala.dynamicjava.parser;

import java.lang.reflect.Modifier;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import koala.dynamicjava.parser.wrapper.ParseError;
import koala.dynamicjava.parser.wrapper.TreeToken;
import koala.dynamicjava.tree.*;
import koala.dynamicjava.tree.visitor.Visitor;
import koala.dynamicjava.util.LocalizedMessageReader;

/**
 * This class represents a (interpreted) Java 1.1 language parser
 *
 * @author  Stephane Hillion
 * @version 1.1 - 1999/10/25
 */

public class Parser implements ParserConstants {
    /**
     * The name of the file currenty interpreted
     */
    private String filename;

    /**
     * The message reader
     */
    private LocalizedMessageReader reader =
        new LocalizedMessageReader("koala.dynamicjava.parser.resources.messages");

    /**
     * Sets the current filename
     * @param fname the name of the input file
     */
    public void setFilename(String fname) {
        filename = fname;
    }

    /**
     * Creates a primary expression from a refix and a list of suffixes
     * @param prefix   the prefix expression
     * @param suffixes the suffix list built in reverse order
     */
    private static Expression createPrimaryExpression(Expression prefix,
                                                      List       suffixes) {
        Iterator it = suffixes.iterator();
        if (it.hasNext()) {
            return ((ExpressionSuffix)it.next()).createExpression(prefix, it);
        } else {
            if (prefix instanceof CompileTimeQualifiedName) {
                return ((CompileTimeQualifiedName)prefix).createFieldAccess();
            } else if (prefix instanceof CompileTimeExpression) {
                return ((CompileTimeExpression)prefix).createRuntimeExpression();
            } else {
                return prefix;
            }
        }
    }

    /**
     * Creates a field declaration
     */
    private FieldDeclaration createFieldDeclaration(ModifierFlags  mf,
                                                    Type           typ,
                                                    Token          name,
                                                    Expression     exp,
                                                    int            dim) {
        int bl;
        int bc;
        int el;
        int ec;
        int flags = 0;

        // Compute the position of the declaration in the source code
        if (mf != null) {
            bl    = mf.beginLine;
            bc    = mf.beginColumn;
            flags = mf.accessFlags;
        } else {
            bl = typ.getBeginLine();
            bc = typ.getBeginColumn();
        }

        if (exp != null) {
            el = exp.getEndLine();
            ec = exp.getEndColumn();
        } else {
            el = name.endLine;
            ec = name.endColumn;
        }

        // If the field is an array, create an array type node
        if (dim > 0) {
            typ = new ArrayType(typ, dim,
                                filename,
                                typ.getBeginLine(), typ.getBeginColumn(),
                                typ.getEndLine(),   typ.getEndColumn());
        }

        return new FieldDeclaration(flags, typ, name.image, exp,
                                    filename, bl, bc, el, ec);
    }

    /**
     * Creates a variable declaration
     */
    private VariableDeclaration createVariableDeclaration(Token          mf,
                                                          Type           typ,
                                                          Token          name,
                                                          Expression     exp,
                                                          int            dim) {
        int     bl;
        int     bc;
        int     el;
        int     ec;
        boolean isFinal = false;

        // Compute the position of the declaration in the source code
        if (mf != null) {
            bl      = mf.beginLine;
            bc      = mf.beginColumn;
            isFinal = true;
        } else {
            bl = typ.getBeginLine();
            bc = typ.getBeginColumn();
        }

        if (exp != null) {
            el = exp.getEndLine();
            ec = exp.getEndColumn();
        } else {
            el = name.endLine;
            ec = name.endColumn;
        }

        // If the variable contains an array, create an array type node
        if (dim > 0) {
            typ = new ArrayType(typ, dim,
                                filename,
                                typ.getBeginLine(), typ.getBeginColumn(),
                                typ.getEndLine(),   typ.getEndColumn());
        }

        return new VariableDeclaration(isFinal, typ, name.image, exp,
                                       filename, bl, bc, el, ec);
    }

    /*
     * The classes derived from this one are used for parsing only
     */

    abstract class ExpressionSuffix {
        /**
	 * Creates an expression node
	 * @param prefix the prefix expression
	 * @param it     an iterator over the suffixes
	 */
        public abstract Expression createExpression(Expression prefix, Iterator it);
    }

    class DotAllocationSuffix extends ExpressionSuffix {
        /**
	 * The allocation expression
	 */
        public Allocation expression;

        /**
	 * Creates a new suffix
	 * @param exp the expression
	 */
        public DotAllocationSuffix(Allocation exp) {
            expression = exp;
        }

        /**
	 * Creates an expression node
	 * @param prefix the prefix expression
	 * @param it     an iterator over the suffixes
	 */
        public Expression createExpression(Expression prefix, Iterator it) {
            Expression exp = prefix;
            if (it.hasNext()) {
                exp = ((ExpressionSuffix)it.next()).createExpression(prefix, it);
            } else {
                if (prefix instanceof CompileTimeExpression) {
                    exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
                }
            }
            if (expression instanceof SimpleAllocation) {
                SimpleAllocation sa = (SimpleAllocation)expression;
                return new InnerAllocation
                    (exp, sa.getCreationType(), sa.getArguments(),
                     filename,
                     exp.getBeginLine(), exp.getBeginColumn(),
                     sa.getEndLine(),    sa.getEndColumn());
            } else {
                ClassAllocation ca = (ClassAllocation)expression;
                return new InnerClassAllocation
                    (exp, ca.getCreationType(), ca.getArguments(), ca.getMembers(),
                     filename,
                     exp.getBeginLine(), exp.getBeginColumn(),
                     ca.getEndLine(),    ca.getEndColumn());
            }
        }
    }

    class DotIdentifierSuffix extends ExpressionSuffix {
        /**
	 * The identifier
	 */
        public Token identifier;

        /**
	 * Creates a new suffix
	 * @param ident the identifier
	 */
        public DotIdentifierSuffix(Token ident) {
            identifier = ident;
        }

        /**
	 * Creates an expression node
	 * @param prefix the prefix expression
	 * @param it     an iterator over the suffixes
	 */
        public Expression createExpression(Expression prefix, Iterator it) {
            Expression exp = prefix;
            if (it.hasNext()) {
                exp = ((ExpressionSuffix)it.next()).createExpression(prefix, it);
            } else {
                if (prefix instanceof CompileTimeExpression) {
                    exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
                }
            }
            return new ObjectFieldAccess
                (exp, identifier.image,
                 filename,
                 exp.getBeginLine(), exp.getBeginColumn(),
                 identifier.endLine, identifier.endColumn);
        }
    }

    class ArrayReferenceSuffix extends ExpressionSuffix {
        /**
	 * The expression
	 */
        public Expression expression;

        /**
	 * The end line
	 */
        public int endLine;

        /**
	 * The end column
	 */
        public int endColumn;

        /**
	 * Creates a new suffix
	 * @param exp the expression
	 * @param el  the end line
	 * @param ec  the end column
	 */
        public ArrayReferenceSuffix(Expression exp, int el, int ec) {
            expression = exp;
            endLine    = el;
            endColumn  = ec;
        }

        /**
	 * Creates an expression node
	 * @param prefix the prefix expression
	 * @param it     an iterator over the suffixes
	 */
        public Expression createExpression(Expression prefix, Iterator it) {
            Expression exp = prefix;
            if (it.hasNext()) {
                exp = ((ExpressionSuffix)it.next()).createExpression(prefix, it);
            } else {
                if (prefix instanceof CompileTimeExpression) {
                    exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
                }
            }
            return new ArrayAccess
                (exp, expression,
                 filename,
                 exp.getBeginLine(), exp.getBeginColumn(),
                 endLine, endColumn);
        }
    }

    class DotThisSuffix extends ExpressionSuffix {
        /**
	 * The end line
	 */
        public int endLine;

        /**
	 * The end column
	 */
        public int endColumn;

        /**
	 * Creates a new suffix
	 * @param el  the end line
	 * @param ec  the end column
	 * @param fn  the file name
	 */
        public DotThisSuffix(int el, int ec) {
            endLine    = el;
            endColumn  = ec;
        }

        /**
	 * Creates an expression node
	 * @param prefix the prefix expression
	 * @param it     an iterator over the suffixes
	 */
        public Expression createExpression(Expression prefix, Iterator it) {
            Expression exp = prefix;
            if (it.hasNext()) {
                exp = ((ExpressionSuffix)it.next()).createExpression(prefix, it);
            } else {
                if (prefix instanceof CompileTimeExpression) {
                    exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
                }
            }
            if (exp instanceof QualifiedName) {
                return new ThisExpression
                    (((QualifiedName)exp).getIdentifiers(),
                     filename,
                     exp.getBeginLine(), exp.getBeginColumn(),
                     endLine, endColumn);
            } else {
                throw new ParseError(reader.getMessage("this.prefix", null),
                                     filename,
                                     exp.getBeginLine(), exp.getBeginColumn());
            }
        }
    }

    class ArgumentsSuffix extends ExpressionSuffix {
        /**
	 * The arguments
	 */
        public List arguments;

        /**
	 * The end line
	 */
        public int endLine;

        /**
	 * The end column
	 */
        public int endColumn;

        /**
	 * Creates a new argument suffix
	 * @param args  the list of argument
	 * @param el    the end line
	 * @param ec    the end column
	 */
        public ArgumentsSuffix(List args, int el, int ec) {
            arguments = args;
            endLine   = el;
            endColumn = ec;
        }

        /**
	 * Creates an expression node
	 * @param prefix the prefix expression
	 * @param it     an iterator over the suffixes
	 */
        public Expression createExpression(Expression prefix, Iterator it) {
            if (it.hasNext()) {
                ExpressionSuffix es = (ExpressionSuffix)it.next();
                if (es instanceof DotIdentifierSuffix) {
                    DotIdentifierSuffix dis = (DotIdentifierSuffix)es;
                    Expression exp = prefix;
                    if (it.hasNext()) {
                        exp = ((ExpressionSuffix)it.next()).createExpression(prefix, it);
                    } else if (prefix instanceof CompileTimeExpression) {
                        exp = ((CompileTimeExpression)prefix).createRuntimeExpression();
                    }
                    return new ObjectMethodCall
                        (exp, dis.identifier.image, arguments,
                         filename,
                         exp.getBeginLine(), exp.getBeginColumn(),
                         endLine,            endColumn);
                } else {
                    throw new ParseError(reader.getMessage("parameter.list", null),
                                         filename,
                                         endLine, endColumn);
                }
            } else {
                if (prefix instanceof CompileTimeQualifiedName) {
                    // Remove the last identifier from the qualified name
                    List  l = ((CompileTimeQualifiedName)prefix).identifiers;
                    Token f = ((TreeToken)l.get(0)).getToken();
                    Token t = ((TreeToken)l.remove(l.size()-1)).getToken();
                    Expression exp = null;
                    if (l.size() >= 1) {
                        exp = ((CompileTimeQualifiedName)prefix).
                            createRuntimeExpression();
                    }
                    return new ObjectMethodCall(exp, t.image, arguments,
                                                filename,
                                                f.beginLine, f.beginColumn,
                                                endLine,   endColumn);
                } else if (prefix instanceof CompileTimeSuperExpression) {
                    // Transform the super expression into a super method call
                    CompileTimeSuperExpression se = (CompileTimeSuperExpression)prefix;
                    return new SuperMethodCall(se.identifier, arguments,
                                               filename,
                                               se.getBeginLine(), se.getBeginColumn(),
                                               endLine,           endColumn);
                } else {
                    throw new ParseError(reader.getMessage("parameter.list", null),
                                         filename,
                                         endLine, endColumn);
                }
            }
        }
    }

    interface CompileTimeExpression {
        /**
	 * Builds a runtime expression from this compile-time one.
	 * This method must only be called when the expression has no suffix.
	 */
        Expression createRuntimeExpression();

    }

    class CompileTimeSuperExpression
        extends Expression implements CompileTimeExpression {
        /**
	 * The identifier from the superclass
	 */
        public String identifier;

        /**
	 * Initializes the expression
	 * @param ident the identifier from the super class
	 * @param bl    the begin line
	 * @param bc    the begin column
	 * @param el    the end line
	 * @param ec    the end column
	 */
        public CompileTimeSuperExpression(String ident, int bl, int bc, int el, int ec) {
            super("", bl, bc, el, ec);
            identifier = ident;
        }

        /**
	 * Builds a runtime expression from this compile-time one.
	 * This method must be called when the expression has no suffix
	 */
        public Expression createRuntimeExpression() {
            return new SuperFieldAccess(identifier,
                                        filename,
                                        getBeginLine(), getBeginColumn(),
                                        getEndLine(),   getEndColumn());
        }

        /**
	 * Not used
	 */
        public Object acceptVisitor(Visitor visitor) {
            return null;
        }
    }

    class CompileTimeQualifiedName extends Expression implements CompileTimeExpression {
        /**
	 * The identifiers (tokens)
	 */
        public List identifiers;

        /**
	 * Initializes the expression
	 * @param ids a list of token
	 */
        public CompileTimeQualifiedName(List ids) {
            super("", 0, 0, 0, 0);
            identifiers = ids;
        }

        /**
	 * Creates a runtime qualified name
	 */
        public Expression createFieldAccess() {
            if (identifiers.size() == 1) {
                Token t = ((TreeToken)identifiers.get(0)).getToken();
                return new QualifiedName(identifiers,
                                         filename,
                                         t.beginLine, t.beginColumn,
                                         t.endLine,   t.endColumn);
            } else {
                Token f = ((TreeToken)identifiers.get(0)).getToken();
                Token t = ((TreeToken)identifiers.remove
                              (identifiers.size()-1)).getToken();;
                Token l = ((TreeToken)identifiers.get
                              (identifiers.size()-1)).getToken();
                return new ObjectFieldAccess
                    (new QualifiedName(identifiers,
                                       filename,
                                       f.beginLine, f.beginColumn,
                                       l.endLine,   l.endColumn),
                     t.image,
                     filename,
                     f.beginLine, f.beginColumn,
                     t.endLine,   t.endColumn);
            }
        }

        /**
	 * Builds a runtime expression from this compile-time one.
	 * This method must be called when the expression has no suffix
	 */
        public Expression createRuntimeExpression() {
            Token first = ((TreeToken)identifiers.get(0)).getToken();
            Token last  = ((TreeToken)identifiers.get(identifiers.size()-1)).getToken();
            return new QualifiedName(identifiers,
                                     filename,
                                     first.beginLine, first.beginColumn,
                                     last.endLine,    last.endColumn);
        }

        /**
	 * Not used
	 */
        public Object acceptVisitor(Visitor visitor) {
            return null;
        }
    }

    /**
     * To store modifier flags
     */
    static class ModifierFlags {
        int accessFlags;
        int beginLine;
        int beginColumn;

        ModifierFlags(int flags, int bl, int bc) {
            accessFlags = flags;
            beginLine   = bl;
            beginColumn = bc;
        }
    }

    /**
     * To store a class body
     */
    static class ClassBody {
        List list;
        int  endLine;
        int  endColumn;

        ClassBody(List l, int el, int ec) {
            list      = l;
            endLine   = el;
            endColumn = ec;
        }
    }

/*
 * The syntactic grammar
 */

// Productions for the intepreter ////////////////////////////////////////////////

/**
 * Parses top level statements. This production is
 * not a Java language rule. It is used by DynamicJava.
 * @return a list of nodes (possibly empty)
 * @see koala.dynamicjava.tree.Node
 */
  final public List parseStream() throws ParseException {
    List list = new LinkedList();
    List l;
    Node root = null;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case IMPORT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case NEW:
      case NULL:
      case PACKAGE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case RETURN:
      case SHORT:
      case STATIC:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRANSIENT:
      case TRUE:
      case TRY:
      case VOID:
      case VOLATILE:
      case WHILE:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case BANG:
      case TILDE:
      case INCREMENT:
      case DECREMENT:
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PACKAGE:
        root = packageDeclaration();
        break;
      case IMPORT:
        root = importDeclaration();
        break;
      default:
        jj_la1[1] = jj_gen;
        if (jj_2_1(2147483647)) {
          root = methodDeclaration();
        } else if (jj_2_2(2147483647)) {
          l = localVariableDeclaration();
          jj_consume_token(SEMICOLON);
            list.addAll(l);
        } else if (jj_2_3(2)) {
          root = topLevelStatement();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ABSTRACT:
          case CLASS:
          case FINAL:
          case INTERFACE:
          case NATIVE:
          case PRIVATE:
          case PROTECTED:
          case PUBLIC:
          case STATIC:
          case SYNCHRONIZED:
          case TRANSIENT:
          case VOLATILE:
            root = typeDeclaration();
            break;
          default:
            jj_la1[2] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
          if (root != null) {
              list.add(root);
              root = null;
          }
    }
    jj_consume_token(0);
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses one top level statement. This production is
 * not a Java language rule. It is used by DynamicJava.

 * @return a node
 * @see koala.dynamicjava.tree.Node
 */
  final public Node topLevelStatement() throws ParseException {
    Node node;
    if (jj_2_4(2)) {
      node = labeledStatement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        node = emptyStatement();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCREMENT:
      case DECREMENT:
      case PLUS:
      case MINUS:
        node = expression();
        jj_consume_token(SEMICOLON);
        break;
      case LBRACE:
        node = block();
        break;
      case IF:
        node = ifStatement();
        break;
      case WHILE:
        node = whileStatement();
        break;
      case DO:
        node = doStatement();
        break;
      case SWITCH:
        node = switchStatement();
        break;
      case FOR:
        node = forStatement();
        break;
      case BREAK:
        node = breakStatement();
        break;
      case CONTINUE:
        node = continueStatement();
        break;
      case RETURN:
        node = returnStatement();
        break;
      case THROW:
        node = throwStatement();
        break;
      case SYNCHRONIZED:
        node = synchronizedStatement();
        break;
      case TRY:
        node = tryStatement();
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

// Productions for Packages ////////////////////////////////////////////////////////

/**
 * Parses a Java compilation unit
 * @return a list of nodes (possibly empty)
 * @see koala.dynamicjava.tree.Node
 */
  final public List parseCompilationUnit() throws ParseException {
    List list = new LinkedList();
    Node node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PACKAGE:
      node = packageDeclaration();
          list.add(node);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      node = importDeclaration();
          list.add(node);
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case CLASS:
      case FINAL:
      case INTERFACE:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case SEMICOLON:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case CLASS:
      case FINAL:
      case INTERFACE:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
        node = typeDeclaration();
            list.add(node);
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a package declaration
 * @see koala.dynamicjava.tree.PackageDeclaration
 */
  final public PackageDeclaration packageDeclaration() throws ParseException {
    List  list = null;
    Token t1, t2;
    t1 = jj_consume_token(PACKAGE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      list = name();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    t2 = jj_consume_token(SEMICOLON);
        {if (true) return new PackageDeclaration(list,
                                      filename,
                                      t1.beginLine, t1.beginColumn,
                                      t2.endLine,   t2.endColumn);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an import declaration
 * @see koala.dynamicjava.tree.ImportDeclaration
 */
  final public ImportDeclaration importDeclaration() throws ParseException {
    List  list;
    Token star = null;
    Token t1, t2;
    t1 = jj_consume_token(IMPORT);
    list = name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      star = jj_consume_token(STAR);
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    t2 = jj_consume_token(SEMICOLON);
        {if (true) return new ImportDeclaration(list, star != null,
                                     filename,
                                     t1.beginLine, t1.beginColumn,
                                     t2.endLine,   t2.endColumn);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a type declaration
 * @see koala.dynamicjava.tree.TypeDeclaration
 */
  final public TypeDeclaration typeDeclaration() throws ParseException {
    TypeDeclaration node;
    if (jj_2_5(2147483647)) {
      node = classDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case INTERFACE:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
        node = interfaceDeclaration();
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

// Productions for Names ////////////////////////////////////////////////////////

/**
 * Parses a name
 * @return a list of tree token
 * @see koala.dynamicjava.parser.wrapper.TreeToken
 */
  final public List name() throws ParseException {
    Token id;
    List  list = new LinkedList();
    id = jj_consume_token(IDENTIFIER);
        list.add(new TreeToken(id));
    label_4:
    while (true) {
      if (jj_2_6(2)) {
        ;
      } else {
        break label_4;
      }
      jj_consume_token(DOT);
      id = jj_consume_token(IDENTIFIER);
          list.add(new TreeToken(id));
    }
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a comma separated list of names
 * @return a list of list of token
 * @see koala.dynamicjava.parser.wrapper.TreeToken
 */
  final public List nameList() throws ParseException {
    List   list = new LinkedList();
    Object obj;
    obj = name();
        list.add(obj);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      obj = name();
          list.add(obj);
    }
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

// Productions for Classes //////////////////////////////////////////////////////

// Productions for Class Declaration ============================================

/**
 * Parses a class declaration
 * @see koala.dynamicjava.tree.ClassDeclaration
 */
  final public ClassDeclaration classDeclaration() throws ParseException {
    ClassDeclaration cd;
    ModifierFlags    md;
    md = modifiers();
    cd = unmodifiedClassDeclaration(md);
        {if (true) return cd;}
    throw new Error("Missing return statement in function");
  }

/**
 * Used internally to parse a modifier
 */
  final public ModifierFlags modifiers() throws ParseException {
    Token t;
    int   flags = 0;
    Token ft    = null;
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
        t = jj_consume_token(ABSTRACT);
          if (ft == null) {
              ft = t;
          } else if ((flags & Modifier.ABSTRACT) != 0) {
              {if (true) throw new ParseError(reader.getMessage("abstract.abstract", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          } else if ((flags & Modifier.FINAL) != 0) {
              {if (true) throw new ParseError(reader.getMessage("abstract.final", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }
          flags |= Modifier.ABSTRACT;
        break;
      case FINAL:
        t = jj_consume_token(FINAL);
          if (ft == null) {
              ft = t;
          } else if ((flags & Modifier.FINAL) != 0) {
              {if (true) throw new ParseError(reader.getMessage("final.final", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          } else if ((flags & Modifier.ABSTRACT) != 0) {
              {if (true) throw new ParseError(reader.getMessage("abstract.final", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }
          flags |= Modifier.FINAL;
        break;
      case PUBLIC:
        t = jj_consume_token(PUBLIC);
          if (ft == null) {
              ft = t;
          } else if ((flags & Modifier.PUBLIC) != 0) {
              {if (true) throw new ParseError(reader.getMessage("public.public", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          } else if ((flags & Modifier.PROTECTED) != 0) {
              {if (true) throw new ParseError(reader.getMessage("public.protected", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          } else if ((flags & Modifier.PRIVATE) != 0) {
              {if (true) throw new ParseError(reader.getMessage("public.private", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }

          flags |= Modifier.PUBLIC;
        break;
      case PROTECTED:
        t = jj_consume_token(PROTECTED);
          if (ft == null) {
              ft = t;
          } else if ((flags & Modifier.PROTECTED) != 0) {
              {if (true) throw new ParseError(reader.getMessage("protected.protected", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          } else if ((flags & Modifier.PUBLIC) != 0) {
              {if (true) throw new ParseError(reader.getMessage("public.protected", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          } else if ((flags & Modifier.PRIVATE) != 0) {
              {if (true) throw new ParseError(reader.getMessage("protected.private", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }
          flags |= Modifier.PROTECTED;
        break;
      case PRIVATE:
        t = jj_consume_token(PRIVATE);
          if (ft == null) {
              ft = t;
          }  else if ((flags & Modifier.PRIVATE) != 0) {
              {if (true) throw new ParseError(reader.getMessage("private.private", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          } else if ((flags & Modifier.PUBLIC) != 0) {
              {if (true) throw new ParseError(reader.getMessage("public.private", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          } else if ((flags & Modifier.PROTECTED) != 0) {
              {if (true) throw new ParseError(reader.getMessage("protected.private", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }
          flags |= Modifier.PRIVATE;
        break;
      case TRANSIENT:
        t = jj_consume_token(TRANSIENT);
          if (ft == null) {
              ft = t;
          } else if ((flags & Modifier.TRANSIENT) != 0) {
              {if (true) throw new ParseError(reader.getMessage("transient.transient", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }
          flags |= Modifier.TRANSIENT;
        break;
      case VOLATILE:
        t = jj_consume_token(VOLATILE);
          if (ft == null) {
              ft = t;
          } else if ((flags & Modifier.VOLATILE) != 0) {
              {if (true) throw new ParseError(reader.getMessage("volatile.volatile", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }
          flags |= Modifier.VOLATILE;
        break;
      case NATIVE:
        t = jj_consume_token(NATIVE);
          if (ft == null) {
              ft = t;
          } else if ((flags & Modifier.NATIVE) != 0) {
              {if (true) throw new ParseError(reader.getMessage("native.native", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }  else if ((flags & Modifier.ABSTRACT) != 0) {
              {if (true) throw new ParseError(reader.getMessage("abstract.native", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }
          flags |= Modifier.NATIVE;
        break;
      case STATIC:
        t = jj_consume_token(STATIC);
          if (ft == null) {
              ft = t;
          } else if ((flags & Modifier.STATIC) != 0) {
              {if (true) throw new ParseError(reader.getMessage("static.static", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }
          flags |= Modifier.STATIC;
        break;
      case SYNCHRONIZED:
        t = jj_consume_token(SYNCHRONIZED);
          if (ft == null) {
              ft = t;
          } else if ((flags & Modifier.SYNCHRONIZED) != 0) {
              {if (true) throw new ParseError(reader.getMessage("synchronized.synchronized", null),
                                   filename,
                                   t.beginLine, t.beginColumn);}
          }
          flags |= Modifier.SYNCHRONIZED;
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return (ft == null)
            ? null
            : new ModifierFlags(flags, ft.beginLine, ft.beginColumn);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a class declaration without modifier
 * @see koala.dynamicjava.tree.ClassDeclaration
 */
  final public ClassDeclaration unmodifiedClassDeclaration(ModifierFlags mf) throws ParseException {
    Token t;
    Token id;
    List  ext  = null;
    List  impl = null;
    ClassBody body;
    t = jj_consume_token(CLASS);
    id = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      jj_consume_token(EXTENDS);
      ext = name();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTS:
      jj_consume_token(IMPLEMENTS);
      impl = nameList();
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    body = classBody();
        if (mf == null) {
            {if (true) return new ClassDeclaration(0, id.image, ext, impl, body.list,
                                        filename,
                                        t.beginLine,  t.beginColumn,
                                        body.endLine, body.endColumn);}
        } else {
            {if (true) return new ClassDeclaration(mf.accessFlags, id.image, ext, impl, body.list,
                                        filename,
                                        mf.beginLine, mf.beginColumn,
                                        body.endLine, body.endColumn);}
        }
    throw new Error("Missing return statement in function");
  }

/**
 * Used internally to parse the body of a class
 */
  final public ClassBody classBody() throws ParseException {
    Token t;
    List list = new LinkedList();
    List decl;
    jj_consume_token(LBRACE);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case IDENTIFIER:
      case LBRACE:
      case SEMICOLON:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_7;
      }
      decl = classBodyDeclaration();
         list.addAll(decl);
    }
    t = jj_consume_token(RBRACE);
        {if (true) return new ClassBody(list, t.endLine, t.endColumn);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses one declaration in the body of a class.
 * @return a list of node because one field declaration can
 *         contain multiple declarations.
 * @see koala.dynamicjava.tree.Node
 */
  final public List classBodyDeclaration() throws ParseException {
    Node node = null;
    List list = new LinkedList();
    if (jj_2_7(2)) {
      node = initializer();
    } else if (jj_2_8(2147483647)) {
      node = classDeclaration();
    } else if (jj_2_9(2147483647)) {
      node = interfaceDeclaration();
    } else if (jj_2_10(2147483647)) {
      node = constructorDeclaration();
    } else if (jj_2_11(2147483647)) {
      node = methodDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case IDENTIFIER:
        list = fieldDeclaration();
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        if (node != null) {
            list.add(node);
        }
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

// Productions for Field Declaration ============================================

/**
 * Parses a field declaration.
 * @return a list of field declaration because one field declaration can
 *         contain multiple declarations.
 * @see koala.dynamicjava.tree.FieldDeclaration
 */
  final public List fieldDeclaration() throws ParseException {
    ModifierFlags mf;
    Type          typ;
    Token         id;
    int           dim  = 0;
    Expression    exp  = null;
    List          list = new LinkedList();
    mf = modifiers();
    typ = type();
    id = jj_consume_token(IDENTIFIER);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_8;
      }
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
                dim++;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      exp = variableInitializer();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
            list.add(createFieldDeclaration(mf, typ, id, exp, dim));
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
            dim = 0; exp = null;
      id = jj_consume_token(IDENTIFIER);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_10;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
                  dim++;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        exp = variableInitializer();
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
            list.add(createFieldDeclaration(mf, typ, id, exp, dim));
    }
    jj_consume_token(SEMICOLON);
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

// Productions for Method Declaration ===========================================

/**
 * Parses a method declaration
 * @see koala.dynamicjava.tree.MethodDeclaration
 */
  final public MethodDeclaration methodDeclaration() throws ParseException {
    MethodDeclaration md;
    ModifierFlags     mf;
    int               bl;
    int               bc;
    int               flags = 0;
    Type              typ;
    Token             id;
    int               dim = 0;
    List              params;
    List              exceptions = new LinkedList();
    Node              body = null;
    mf = modifiers();
    typ = resultType();
    id = jj_consume_token(IDENTIFIER);
    params = formalParameters();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_11;
      }
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
                dim++;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THROWS:
      jj_consume_token(THROWS);
      exceptions = nameList();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      body = block();
      break;
    case SEMICOLON:
      body = emptyStatement();
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if (mf != null) {
            bl    = mf.beginLine;
            bc    = mf.beginColumn;
            flags = mf.accessFlags;
        } else {
            bl = typ.getBeginLine();
            bc = typ.getBeginColumn();
        }

        if (dim > 0) {
            typ = new ArrayType(typ, dim,
                                filename,
                                typ.getBeginLine(), typ.getBeginColumn(),
                                typ.getEndLine(),   typ.getEndColumn());
        }

        {if (true) return new MethodDeclaration(flags, typ, id.image, params,
                                     exceptions,
                                     (body instanceof BlockStatement) ?
                                     (BlockStatement)body : null,
                                     filename,
                                     bl, bc, body.getEndLine(), body.getEndColumn());}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses formal parameters of the form '(param, param, ...)'
 * @see koala.dynamicjava.tree.FormalParameter
 */
  final public List formalParameters() throws ParseException {
    List list = new LinkedList();
    Node node;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      node = formalParameter();
              list.add(node);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_12;
        }
        jj_consume_token(COMMA);
        node = formalParameter();
              list.add(node);
      }
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses one formal parameter
 * @see koala.dynamicjava.tree.FormalParameter
 */
  final public FormalParameter formalParameter() throws ParseException {
    Type  typ;
    Token id;
    Token f   = null;
    int   dim = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINAL:
      f = jj_consume_token(FINAL);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    typ = type();
    id = jj_consume_token(IDENTIFIER);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_13;
      }
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
                                                         dim++;
    }
        if (dim > 0) {
            typ = new ArrayType(typ, dim,
                                filename,
                                typ.getBeginLine(), typ.getBeginColumn(),
                                typ.getEndLine(),   typ.getEndColumn());
        }
        {if (true) return new FormalParameter(f != null, typ, id.image,
                                   filename,
                                   (f != null) ? f.beginLine   : typ.getBeginLine(),
                                   (f != null) ? f.beginColumn : typ.getBeginColumn(),
                                   id.endLine, id.endColumn);}
    throw new Error("Missing return statement in function");
  }

// Production for Initializer ===================================================

/**
 * Parses one initializer
 * @see koala.dynamicjava.tree.Initializer
 */
  final public Initializer initializer() throws ParseException {
    Token t = null;
    BlockStatement node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      t = jj_consume_token(STATIC);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    node = block();
        if (t == null) {
            {if (true) return new InstanceInitializer(node,
                                           filename,
                                           node.getBeginLine(), node.getEndColumn(),
                                           node.getEndLine(), node.getEndColumn());}
        } else {
            {if (true) return new ClassInitializer(node,
                                        filename,
                                        t.beginLine, t.beginColumn,
                                        node.getEndLine(), node.getEndColumn());}
        }
    throw new Error("Missing return statement in function");
  }

// Productions for Constructor Declaration ======================================

/**
 * Parses a constructor declaration
 * @see koala.dynamicjava.tree.ConstructorDeclaration
 */
  final public ConstructorDeclaration constructorDeclaration() throws ParseException {
    Token                 t = null;
    int                   flag = 0;
    Token                 id;
    List                  params;
    List                  exceptions = new LinkedList();
    ConstructorInvocation ci = null;
    List                  stmt;
    List                  stmts = new LinkedList();
    int                   bl, bc;
    Token                 e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUBLIC:
        t = jj_consume_token(PUBLIC);
          flag = Modifier.PUBLIC;
        break;
      case PROTECTED:
        t = jj_consume_token(PROTECTED);
          flag = Modifier.PROTECTED;
        break;
      case PRIVATE:
        t = jj_consume_token(PRIVATE);
          flag = Modifier.PRIVATE;
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    id = jj_consume_token(IDENTIFIER);
    params = formalParameters();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THROWS:
      jj_consume_token(THROWS);
      exceptions = nameList();
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    jj_consume_token(LBRACE);
    if (jj_2_12(2147483647)) {
      ci = explicitConstructorInvocation();
    } else {
      ;
    }
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case INTERFACE:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCREMENT:
      case DECREMENT:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_14;
      }
      stmt = blockStatement();
              stmts.addAll(stmt);
    }
    e = jj_consume_token(RBRACE);
        if (t == null) {
            bl = id.beginLine;
            bc = id.beginColumn;
        } else {
            bl = t.beginLine;
            bc = t.beginColumn;
        }
        {if (true) return new ConstructorDeclaration(flag, id.image, params, exceptions, ci, stmts,
                                          filename,
                                          bl, bc,
                                          e.endLine, e.endColumn);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a constructor invocation
 * @see koala.dynamicjava.tree.ConstructorInvocation
 */
  final public ConstructorInvocation explicitConstructorInvocation() throws ParseException {
    Token           b, e;
    ArgumentsSuffix args;
    Expression      exp = null;
    if (jj_2_14(2147483647)) {
      b = jj_consume_token(THIS);
      args = arguments();
      e = jj_consume_token(SEMICOLON);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
        if (jj_2_13(2)) {
          exp = primaryExpression();
          jj_consume_token(DOT);
        } else {
          ;
        }
        b = jj_consume_token(SUPER);
        args = arguments();
        e = jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return new ConstructorInvocation(exp, args.arguments, b.image.equals("super"),
                                         filename,
                                         b.beginLine, b.beginColumn,
                                         e.endLine,   e.endColumn);}
    throw new Error("Missing return statement in function");
  }

// Productions for Interfaces ///////////////////////////////////////////////////

/**
 * Parses a interface declaration
 * @see koala.dynamicjava.tree.InterfaceDeclaration
 */
  final public InterfaceDeclaration interfaceDeclaration() throws ParseException {
    InterfaceDeclaration id;
    ModifierFlags        md;
    md = modifiers();
    id = unmodifiedInterfaceDeclaration(md);
        {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a interface declaration without modifier
 * @see koala.dynamicjava.tree.InterfaceDeclaration
 */
  final public InterfaceDeclaration unmodifiedInterfaceDeclaration(ModifierFlags mf) throws ParseException {
    Token t;
    Token id;
    Token e;
    List  impl = null;
    List  list = new LinkedList();
    List  decl;
    int   m = 0;
    t = jj_consume_token(INTERFACE);
    id = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      jj_consume_token(EXTENDS);
      impl = nameList();
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(LBRACE);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case CLASS:
      case DOUBLE:
      case FINAL:
      case FLOAT:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOID:
      case VOLATILE:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_15;
      }
      decl = interfaceMemberDeclaration();
            list.addAll(decl);
    }
    e = jj_consume_token(RBRACE);
        if (mf != null) {
            m = mf.accessFlags;
        }
        {if (true) return new InterfaceDeclaration(m, id.image, impl, list,
                                        filename,
                                        t.beginLine, t.beginColumn,
                                        e.endLine,   e.endColumn);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses one declaration in the body of an interface.
 * @return a list of node because one field declaration can
 *         contain multiple declarations.
 * @see koala.dynamicjava.tree.Node
 */
  final public List interfaceMemberDeclaration() throws ParseException {
    Node node = null;
    List list = new LinkedList();
    if (jj_2_15(2147483647)) {
      node = classDeclaration();
    } else if (jj_2_16(2147483647)) {
      node = interfaceDeclaration();
    } else if (jj_2_17(2147483647)) {
      node = methodDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case IDENTIFIER:
        list = fieldDeclaration();
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        if (node != null) {
            list.add(node);
        }
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

// Productions for Arrays ////////////////////////////////////////////////////////

/**
 * Parses an array initializer
 * @see koala.dynamicjava.tree.ArrayInitializer
 */
  final public ArrayInitializer arrayInitializer() throws ParseException {
    Expression init;
    Token      t = null, b, e;
    List       list = new LinkedList();
    b = jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOAT_LITERAL:
    case DOUBLE_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCREMENT:
    case DECREMENT:
    case PLUS:
    case MINUS:
      init = variableInitializer();
                list.add(init);
      label_16:
      while (true) {
        if (jj_2_18(2)) {
          ;
        } else {
          break label_16;
        }
        jj_consume_token(COMMA);
        init = variableInitializer();
                  list.add(init);
      }
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      t = jj_consume_token(COMMA);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    e = jj_consume_token(RBRACE);
        {if (true) return new ArrayInitializer(list,
                                    filename,
                                    b.beginLine, b.beginColumn,
                                    e.endLine,   e.endColumn);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a variable initializer (ie. an expression or an array initializer)
 * @see koala.dynamicjava.tree.Expression
 */
  final public Expression variableInitializer() throws ParseException {
    Expression exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      exp = arrayInitializer();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOAT_LITERAL:
    case DOUBLE_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCREMENT:
    case DECREMENT:
    case PLUS:
    case MINUS:
      exp = expression();
      break;
    default:
      jj_la1[41] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

// Productions for Blocks And Statements ////////////////////////////////////////////

/**
 * Parses a block
 * @see koala.dynamicjava.tree.BlockStatement
 */
  final public BlockStatement block() throws ParseException {
    Token p1;
    Token p2;
    List  nodes;
    List  list = new LinkedList();
    p1 = jj_consume_token(LBRACE);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case INTERFACE:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCREMENT:
      case DECREMENT:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_17;
      }
      nodes = blockStatement();
             list.addAll(nodes);
    }
    p2 = jj_consume_token(RBRACE);
        {if (true) return new BlockStatement(list,
                                  filename,
                                  p1.beginLine, p1.beginColumn,
                                  p2.endLine,   p2.endColumn);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses one block statement.
 * @return a list of node because one variable declaration can
 *         contain multiple declarations.
 * @see koala.dynamicjava.tree.Node
 */
  final public List blockStatement() throws ParseException {
    Node node = null;
    List list = new LinkedList();
    if (jj_2_19(2147483647)) {
      list = localVariableDeclaration();
      jj_consume_token(SEMICOLON);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LIT
