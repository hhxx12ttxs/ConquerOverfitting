package loa;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import static loa.Side.*;

/** An automated Player.
 *  @author Siyuan He*/
class MachinePlayer extends Player {

    /** A MachinePlayer that plays the SIDE pieces in GAME as index N. */
    MachinePlayer(Side side, Game game, int N) {
        super(side, game, N);
        _random = game.getRandomSource();
        _start = false;
    }

    @Override
    boolean isAI() {
        return true;
    }

    @Override
    Move makeMove() {
        return _start ? makeAIMove() : makeHumanMove();
    }

    /** Return a move generated by a human move input from terminal. */
    Move makeHumanMove() {
        String mvstr = this.getGame().getMove(this);
        if (mvstr.equals("GO!")) {
            _start = true;
            return makeAIMove();
        }
        String sq0 = mvstr.substring(0, 2);
        String sq1 = mvstr.substring(3, 5);
        Move move =
                Move.create(Board.col(sq0), Board.row(sq0), Board.col(sq1),
                        Board.row(sq1));
        return move;
    }

    /** Return a move generated by this AI. */
    Move makeAIMove() {
        if (this.getGame().timeRemaining(this.side()) < 1.0) {
            Move move = makeRandomMove();
            System.out.printf("%s::%s\n", side() == BLACK
                    ? "B" : "W", move.toString());
            return move;
        }
        Move move = findBestMove(this.side(), this.getBoard(), DEPTH, CUTOFF);
        if (move == null) {
            System.out.println("No moves avaliable to make.");
            return move;
        }
        System.out.printf("%s::%s\n", side() == BLACK
                ? "B" : "W", move.toString());
        return move;
    }

    /** Return a random legal move when there is no time. */
    Move makeRandomMove() {
        List<Move> moves = this.getBoard().legalMovesList();
        return moves.get(this.getRandom(moves.size() - 1));
    }

    /**Return a legal move for WHO that either has an estimated value >= CUTOFF
     * or that has the best estimated value for player WHO, starting from
     * position START, and looking up to DEPTH moves ahead.
     * Assume WHO.opponent() just moved. */
    Move findBestMove(Side who, Board start, int depth, double cutoff) {
        double weight = heuristic(start, who.opponent());
        if (weight == Double.POSITIVE_INFINITY) {
            Move move = Move.create(0, 0, 0, 0);
            move.setValue(Double.POSITIVE_INFINITY);
            return move;
        } else if (weight == Double.NEGATIVE_INFINITY) {
            Move move = Move.create(0, 0, 0, 0);
            move.setValue(Double.NEGATIVE_INFINITY);
            return move;
        } else if (depth == 0) {
            return guessBestMove(who, start, cutoff);
        } else {
            Iterator<Move> moves = start.legalMoves();
            Move bestSoFar = null;
            if (moves.hasNext()) {
                bestSoFar = moves.next();
                bestSoFar.setValue(Double.NEGATIVE_INFINITY);
            }
            while (moves.hasNext()) {
                Move M = moves.next();
                MutableBoard next = new MutableBoard(start);
                if (Reporter.getMessageLevel() >= 1) {
                    System.out.println(M.toString());
                    System.out.printf(next.toString());
                }
                next.makeMove(M);
                Move response = findBestMove(who.opponent(), next, depth - 1,
                        -bestSoFar.value());
                if (-response.value() > bestSoFar.value()) {
                    M.setValue(-response.value());
                    bestSoFar = M;
                    if (M.value() >= cutoff) {
                        break;
                    }
                }
            }
            return bestSoFar;
        }
    }

    /** Return the best move for WHO with START as current board.
     *  estimate until CUTOFF. */
    Move guessBestMove(Side who, Board start, double cutoff) {
        Move bestSoFar = null;
        Iterator<Move> moves = start.legalMoves();
        if (moves.hasNext()) {
            bestSoFar = moves.next();
            bestSoFar.setValue(Double.NEGATIVE_INFINITY);
        }
        while (moves.hasNext()) {
            Move M = moves.next();
            MutableBoard next = new MutableBoard(start);
            next.makeMove(M);
            M.setValue(heuristic(next, who));
            if (M.value() > bestSoFar.value()) {
                bestSoFar = M;
            }
            if (M.value() >= cutoff) {
                break;
            }
        }
        return bestSoFar;
    }

    /** Return a random integer between 0 and MAX from the random source. */
    int getRandom(int max) {
        float rand = _random.nextFloat();
        return (int) (rand * max);
    }

    /** Return the weighted heuristic value of BOARD for PLAYER.
     *  Assume PLAYER just moved. */
    double heuristic(Board board, Side player) {
        List<Integer> mygraph = convertToIntList(
                board.getPiecesGraph(this.side()));
        if (mygraph.size() == 1) {
            return Double.POSITIVE_INFINITY;
        }
        Collections.sort(mygraph);
        List<Integer> oppgraph = convertToIntList(
                board.getPiecesGraph(this.side().opponent()));
        if (oppgraph.size() == 1) {
            return Double.NEGATIVE_INFINITY;
        }
        Collections.sort(oppgraph);
        double myheur = SCALE / mygraph.size() + SCALE * var(mygraph);
        double oppheur = SCALE / oppgraph.size() + SCALE * var(oppgraph);
        return myheur - oppheur;
    }

    /** Return the sum of a list of integer L. */
    static double sum(List<Integer> L) {
        double result = 0;
        for (Integer i : L) {
            result += i.doubleValue();
        }
        return result;
    }

    /** Return the mean of a list of integer L. */
    static double mean(List<Integer> L) {
        return mean(L) / ((double) L.size());
    }

    /** Return the square sum of a list of integer L. */
    static double squaresum(List<Integer> L) {
        double result = 0;
        for (Integer i : L) {
            result += Math.pow(i.doubleValue(), 2);
        }
        return result;
    }

    /** Return the variance of a list of integer L. */
    static double var(List<Integer> L) {
        return squaresum(L) - Math.pow(sum(L), 2);
    }

    /** Convert a list of list of items L of type T to a list of its sizes.
     *  Return that list.
     */
    static <T> List<Integer> convertToIntList(List<List<T>> L) {
        List<Integer> result = new ArrayList<Integer>();
        for (List<T> l : L) {
            result.add(l.size());
        }
        return result;
    }

    /** The random number generator used for this player. */
    private Random _random;

    /** Indicate if the AI has been started. */
    private boolean _start;

    /** The maximum search depth of this AI. */
    private static final int DEPTH = 3;

    /** The cutoff for the heuristics in this AI for Alpha-Beta-Pruning. */
    private static final double CUTOFF = 70.0;

    /** A scaling factor for the heuristic function. */
    private static final double SCALE = 100.0;
}

