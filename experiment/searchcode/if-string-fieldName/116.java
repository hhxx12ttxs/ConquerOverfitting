/**
 * Abiquo community edition
 * cloud management application for hybrid clouds
 * Copyright (C) 2008-2010 - Abiquo Holdings S.L.
 *
 * This application is free software; you can redistribute it and/or
 * modify it under the terms of the GNU LESSER GENERAL PUBLIC
 * LICENSE as published by the Free Software Foundation under
 * version 3 of the License
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * LESSER GENERAL PUBLIC LICENSE v.3 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package com.abiquo.aimstub;

/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class Aim {

  public interface Iface {

    public void checkRimpConfiguration() throws RimpException, TException;

    public long getDatastoreSize() throws RimpException, TException;

    public long getDiskFileSize(String virtualImageDatastorePath) throws RimpException, TException;

    public List<Datastore> getDatastores() throws RimpException, TException;

    public List<NetInterface> getNetInterfaces() throws RimpException, TException;

    public void copyFromRepositoryToDatastore(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID) throws RimpException, TException;

    public void deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID) throws RimpException, TException;

    public void copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath) throws RimpException, TException;

    public void createVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws VLanException, TException;

    public void deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws VLanException, TException;

    public void checkVLANConfiguration() throws VLanException, TException;

    public String getInitiatorIQN() throws TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void checkRimpConfiguration() throws RimpException, TException
    {
      send_checkRimpConfiguration();
      recv_checkRimpConfiguration();
    }

    public void send_checkRimpConfiguration() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.CALL, seqid_));
      checkRimpConfiguration_args args = new checkRimpConfiguration_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_checkRimpConfiguration() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      checkRimpConfiguration_result result = new checkRimpConfiguration_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.re != null) {
        throw result.re;
      }
      return;
    }

    public long getDatastoreSize() throws RimpException, TException
    {
      send_getDatastoreSize();
      return recv_getDatastoreSize();
    }

    public void send_getDatastoreSize() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.CALL, seqid_));
      getDatastoreSize_args args = new getDatastoreSize_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_getDatastoreSize() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getDatastoreSize_result result = new getDatastoreSize_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.re != null) {
        throw result.re;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getDatastoreSize failed: unknown result");
    }

    public long getDiskFileSize(String virtualImageDatastorePath) throws RimpException, TException
    {
      send_getDiskFileSize(virtualImageDatastorePath);
      return recv_getDiskFileSize();
    }

    public void send_getDiskFileSize(String virtualImageDatastorePath) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.CALL, seqid_));
      getDiskFileSize_args args = new getDiskFileSize_args();
      args.virtualImageDatastorePath = virtualImageDatastorePath;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_getDiskFileSize() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getDiskFileSize_result result = new getDiskFileSize_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.re != null) {
        throw result.re;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getDiskFileSize failed: unknown result");
    }

    public List<Datastore> getDatastores() throws RimpException, TException
    {
      send_getDatastores();
      return recv_getDatastores();
    }

    public void send_getDatastores() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getDatastores", TMessageType.CALL, seqid_));
      getDatastores_args args = new getDatastores_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Datastore> recv_getDatastores() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getDatastores_result result = new getDatastores_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.re != null) {
        throw result.re;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getDatastores failed: unknown result");
    }

    public List<NetInterface> getNetInterfaces() throws RimpException, TException
    {
      send_getNetInterfaces();
      return recv_getNetInterfaces();
    }

    public void send_getNetInterfaces() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.CALL, seqid_));
      getNetInterfaces_args args = new getNetInterfaces_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<NetInterface> recv_getNetInterfaces() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getNetInterfaces_result result = new getNetInterfaces_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.re != null) {
        throw result.re;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getNetInterfaces failed: unknown result");
    }

    public void copyFromRepositoryToDatastore(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID) throws RimpException, TException
    {
      send_copyFromRepositoryToDatastore(virtualImageRepositoryPath, datastorePath, virtualMachineUUID);
      recv_copyFromRepositoryToDatastore();
    }

    public void send_copyFromRepositoryToDatastore(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.CALL, seqid_));
      copyFromRepositoryToDatastore_args args = new copyFromRepositoryToDatastore_args();
      args.virtualImageRepositoryPath = virtualImageRepositoryPath;
      args.datastorePath = datastorePath;
      args.virtualMachineUUID = virtualMachineUUID;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_copyFromRepositoryToDatastore() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      copyFromRepositoryToDatastore_result result = new copyFromRepositoryToDatastore_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.re != null) {
        throw result.re;
      }
      return;
    }

    public void deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID) throws RimpException, TException
    {
      send_deleteVirtualImageFromDatastore(datastorePath, virtualMachineUUID);
      recv_deleteVirtualImageFromDatastore();
    }

    public void send_deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.CALL, seqid_));
      deleteVirtualImageFromDatastore_args args = new deleteVirtualImageFromDatastore_args();
      args.datastorePath = datastorePath;
      args.virtualMachineUUID = virtualMachineUUID;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteVirtualImageFromDatastore() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      deleteVirtualImageFromDatastore_result result = new deleteVirtualImageFromDatastore_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.re != null) {
        throw result.re;
      }
      return;
    }

    public void copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath) throws RimpException, TException
    {
      send_copyFromDatastoreToRepository(virtualMachineUUID, snapshot, destinationRepositoryPath, sourceDatastorePath);
      recv_copyFromDatastoreToRepository();
    }

    public void send_copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.CALL, seqid_));
      copyFromDatastoreToRepository_args args = new copyFromDatastoreToRepository_args();
      args.virtualMachineUUID = virtualMachineUUID;
      args.snapshot = snapshot;
      args.destinationRepositoryPath = destinationRepositoryPath;
      args.sourceDatastorePath = sourceDatastorePath;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_copyFromDatastoreToRepository() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      copyFromDatastoreToRepository_result result = new copyFromDatastoreToRepository_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.re != null) {
        throw result.re;
      }
      return;
    }

    public void createVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws VLanException, TException
    {
      send_createVLAN(vlanTag, vlanInterface, bridgeInterface);
      recv_createVLAN();
    }

    public void send_createVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("createVLAN", TMessageType.CALL, seqid_));
      createVLAN_args args = new createVLAN_args();
      args.vlanTag = vlanTag;
      args.vlanInterface = vlanInterface;
      args.bridgeInterface = bridgeInterface;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_createVLAN() throws VLanException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createVLAN_result result = new createVLAN_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ve != null) {
        throw result.ve;
      }
      return;
    }

    public void deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws VLanException, TException
    {
      send_deleteVLAN(vlanTag, vlanInterface, bridgeInterface);
      recv_deleteVLAN();
    }

    public void send_deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.CALL, seqid_));
      deleteVLAN_args args = new deleteVLAN_args();
      args.vlanTag = vlanTag;
      args.vlanInterface = vlanInterface;
      args.bridgeInterface = bridgeInterface;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteVLAN() throws VLanException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      deleteVLAN_result result = new deleteVLAN_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ve != null) {
        throw result.ve;
      }
      return;
    }

    public void checkVLANConfiguration() throws VLanException, TException
    {
      send_checkVLANConfiguration();
      recv_checkVLANConfiguration();
    }

    public void send_checkVLANConfiguration() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.CALL, seqid_));
      checkVLANConfiguration_args args = new checkVLANConfiguration_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_checkVLANConfiguration() throws VLanException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      checkVLANConfiguration_result result = new checkVLANConfiguration_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ve != null) {
        throw result.ve;
      }
      return;
    }

    public String getInitiatorIQN() throws TException
    {
      send_getInitiatorIQN();
      return recv_getInitiatorIQN();
    }

    public void send_getInitiatorIQN() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.CALL, seqid_));
      getInitiatorIQN_args args = new getInitiatorIQN_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_getInitiatorIQN() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getInitiatorIQN_result result = new getInitiatorIQN_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getInitiatorIQN failed: unknown result");
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("checkRimpConfiguration", new checkRimpConfiguration());
      processMap_.put("getDatastoreSize", new getDatastoreSize());
      processMap_.put("getDiskFileSize", new getDiskFileSize());
      processMap_.put("getDatastores", new getDatastores());
      processMap_.put("getNetInterfaces", new getNetInterfaces());
      processMap_.put("copyFromRepositoryToDatastore", new copyFromRepositoryToDatastore());
      processMap_.put("deleteVirtualImageFromDatastore", new deleteVirtualImageFromDatastore());
      processMap_.put("copyFromDatastoreToRepository", new copyFromDatastoreToRepository());
      processMap_.put("createVLAN", new createVLAN());
      processMap_.put("deleteVLAN", new deleteVLAN());
      processMap_.put("checkVLANConfiguration", new checkVLANConfiguration());
      processMap_.put("getInitiatorIQN", new getInitiatorIQN());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class checkRimpConfiguration implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        checkRimpConfiguration_args args = new checkRimpConfiguration_args();
        args.read(iprot);
        iprot.readMessageEnd();
        checkRimpConfiguration_result result = new checkRimpConfiguration_result();
        try {
          iface_.checkRimpConfiguration();
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing checkRimpConfiguration", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing checkRimpConfiguration");
          oprot.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getDatastoreSize implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getDatastoreSize_args args = new getDatastoreSize_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getDatastoreSize_result result = new getDatastoreSize_result();
        try {
          result.success = iface_.getDatastoreSize();
          result.setSuccessIsSet(true);
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getDatastoreSize", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getDatastoreSize");
          oprot.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getDiskFileSize implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getDiskFileSize_args args = new getDiskFileSize_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getDiskFileSize_result result = new getDiskFileSize_result();
        try {
          result.success = iface_.getDiskFileSize(args.virtualImageDatastorePath);
          result.setSuccessIsSet(true);
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getDiskFileSize", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getDiskFileSize");
          oprot.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getDatastores implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getDatastores_args args = new getDatastores_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getDatastores_result result = new getDatastores_result();
        try {
          result.success = iface_.getDatastores();
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getDatastores", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getDatastores");
          oprot.writeMessageBegin(new TMessage("getDatastores", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getDatastores", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getNetInterfaces implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getNetInterfaces_args args = new getNetInterfaces_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getNetInterfaces_result result = new getNetInterfaces_result();
        try {
          result.success = iface_.getNetInterfaces();
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getNetInterfaces", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getNetInterfaces");
          oprot.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class copyFromRepositoryToDatastore implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        copyFromRepositoryToDatastore_args args = new copyFromRepositoryToDatastore_args();
        args.read(iprot);
        iprot.readMessageEnd();
        copyFromRepositoryToDatastore_result result = new copyFromRepositoryToDatastore_result();
        try {
          iface_.copyFromRepositoryToDatastore(args.virtualImageRepositoryPath, args.datastorePath, args.virtualMachineUUID);
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing copyFromRepositoryToDatastore", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing copyFromRepositoryToDatastore");
          oprot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteVirtualImageFromDatastore implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteVirtualImageFromDatastore_args args = new deleteVirtualImageFromDatastore_args();
        args.read(iprot);
        iprot.readMessageEnd();
        deleteVirtualImageFromDatastore_result result = new deleteVirtualImageFromDatastore_result();
        try {
          iface_.deleteVirtualImageFromDatastore(args.datastorePath, args.virtualMachineUUID);
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing deleteVirtualImageFromDatastore", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing deleteVirtualImageFromDatastore");
          oprot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class copyFromDatastoreToRepository implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        copyFromDatastoreToRepository_args args = new copyFromDatastoreToRepository_args();
        args.read(iprot);
        iprot.readMessageEnd();
        copyFromDatastoreToRepository_result result = new copyFromDatastoreToRepository_result();
        try {
          iface_.copyFromDatastoreToRepository(args.virtualMachineUUID, args.snapshot, args.destinationRepositoryPath, args.sourceDatastorePath);
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing copyFromDatastoreToRepository", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing copyFromDatastoreToRepository");
          oprot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class createVLAN implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        createVLAN_args args = new createVLAN_args();
        args.read(iprot);
        iprot.readMessageEnd();
        createVLAN_result result = new createVLAN_result();
        try {
          iface_.createVLAN(args.vlanTag, args.vlanInterface, args.bridgeInterface);
        } catch (VLanException ve) {
          result.ve = ve;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing createVLAN", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing createVLAN");
          oprot.writeMessageBegin(new TMessage("createVLAN", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createVLAN", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteVLAN implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteVLAN_args args = new deleteVLAN_args();
        args.read(iprot);
        iprot.readMessageEnd();
        deleteVLAN_result result = new deleteVLAN_result();
        try {
          iface_.deleteVLAN(args.vlanTag, args.vlanInterface, args.bridgeInterface);
        } catch (VLanException ve) {
          result.ve = ve;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing deleteVLAN", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing deleteVLAN");
          oprot.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class checkVLANConfiguration implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        checkVLANConfiguration_args args = new checkVLANConfiguration_args();
        args.read(iprot);
        iprot.readMessageEnd();
        checkVLANConfiguration_result result = new checkVLANConfiguration_result();
        try {
          iface_.checkVLANConfiguration();
        } catch (VLanException ve) {
          result.ve = ve;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing checkVLANConfiguration", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing checkVLANConfiguration");
          oprot.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getInitiatorIQN implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getInitiatorIQN_args args = new getInitiatorIQN_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getInitiatorIQN_result result = new getInitiatorIQN_result();
        result.success = iface_.getInitiatorIQN();
        oprot.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class checkRimpConfiguration_args implements TBase<checkRimpConfiguration_args._Fields>, java.io.Serializable, Cloneable, Comparable<checkRimpConfiguration_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("checkRimpConfiguration_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(checkRimpConfiguration_args.class, metaDataMap);
    }

    public checkRimpConfiguration_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkRimpConfiguration_args(checkRimpConfiguration_args other) {
    }

    public checkRimpConfiguration_args deepCopy() {
      return new checkRimpConfiguration_args(this);
    }

    @Deprecated
    public checkRimpConfiguration_args clone() {
      return new checkRimpConfiguration_args(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkRimpConfiguration_args)
        return this.equals((checkRimpConfiguration_args)that);
      return false;
    }

    public boolean equals(checkRimpConfiguration_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkRimpConfiguration_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkRimpConfiguration_args typedOther = (checkRimpConfiguration_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkRimpConfiguration_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkRimpConfiguration_result implements TBase<checkRimpConfiguration_result._Fields>, java.io.Serializable, Cloneable, Comparable<checkRimpConfiguration_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("checkRimpConfiguration_result");

    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      RE((short)1, "re");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(checkRimpConfiguration_result.class, metaDataMap);
    }

    public checkRimpConfiguration_result() {
    }

    public checkRimpConfiguration_result(
      RimpException re)
    {
      this();
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkRimpConfiguration_result(checkRimpConfiguration_result other) {
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public checkRimpConfiguration_result deepCopy() {
      return new checkRimpConfiguration_result(this);
    }

    @Deprecated
    public checkRimpConfiguration_result clone() {
      return new checkRimpConfiguration_result(this);
    }

    public RimpException getRe() {
      return this.re;
    }

    public checkRimpConfiguration_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkRimpConfiguration_result)
        return this.equals((checkRimpConfiguration_result)that);
      return false;
    }

    public boolean equals(checkRimpConfiguration_result that) {
      if (that == null)
        return false;

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkRimpConfiguration_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkRimpConfiguration_result typedOther = (checkRimpConfiguration_result)other;

      lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(re, typedOther.re);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case RE:
              if (field.type == TType.STRUCT) {
                this.re = new RimpException();
                this.re.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkRimpConfiguration_result(");
      boolean first = true;

      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDatastoreSize_args implements TBase<getDatastoreSize_args._Fields>, java.io.Serializable, Cloneable, Comparable<getDatastoreSize_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getDatastoreSize_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getDatastoreSize_args.class, metaDataMap);
    }

    public getDatastoreSize_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDatastoreSize_args(getDatastoreSize_args other) {
    }

    public getDatastoreSize_args deepCopy() {
      return new getDatastoreSize_args(this);
    }

    @Deprecated
    public getDatastoreSize_args clone() {
      return new getDatastoreSize_args(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDatastoreSize_args)
        return this.equals((getDatastoreSize_args)that);
      return false;
    }

    public boolean equals(getDatastoreSize_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDatastoreSize_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDatastoreSize_args typedOther = (getDatastoreSize_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDatastoreSize_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDatastoreSize_result implements TBase<getDatastoreSize_result._Fields>, java.io.Serializable, Cloneable, Comparable<getDatastoreSize_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getDatastoreSize_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public long success;
    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      RE((short)1, "re");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getDatastoreSize_result.class, metaDataMap);
    }

    public getDatastoreSize_result() {
    }

    public getDatastoreSize_result(
      long success,
      RimpException re)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDatastoreSize_result(getDatastoreSize_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public getDatastoreSize_result deepCopy() {
      return new getDatastoreSize_result(this);
    }

    @Deprecated
    public getDatastoreSize_result clone() {
      return new getDatastoreSize_result(this);
    }

    public long getSuccess() {
      return this.success;
    }

    public getDatastoreSize_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public RimpException getRe() {
      return this.re;
    }

    public getDatastoreSize_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDatastoreSize_result)
        return this.equals((getDatastoreSize_result)that);
      return false;
    }

    public boolean equals(getDatastoreSize_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDatastoreSize_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDatastoreSize_result typedOther = (getDatastoreSize_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(re, typedOther.re);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.I64) {
                this.success = iprot.readI64();
                setSuccessIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case RE:
              if (field.type == TType.STRUCT) {
                this.re = new RimpException();
                this.re.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDatastoreSize_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDiskFileSize_args implements TBase<getDiskFileSize_args._Fields>, java.io.Serializable, Cloneable, Comparable<getDiskFileSize_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getDiskFileSize_args");

    private static final TField VIRTUAL_IMAGE_DATASTORE_PATH_FIELD_DESC = new TField("virtualImageDatastorePath", TType.STRING, (short)1);

    public String virtualImageDatastorePath;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VIRTUAL_IMAGE_DATASTORE_PATH((short)1, "virtualImageDatastorePath");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.VIRTUAL_IMAGE_DATASTORE_PATH, new FieldMetaData("virtualImageDatastorePath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getDiskFileSize_args.class, metaDataMap);
    }

    public getDiskFileSize_args() {
    }

    public getDiskFileSize_args(
      String virtualImageDatastorePath)
    {
      this();
      this.virtualImageDatastorePath = virtualImageDatastorePath;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDiskFileSize_args(getDiskFileSize_args other) {
      if (other.isSetVirtualImageDatastorePath()) {
        this.virtualImageDatastorePath = other.virtualImageDatastorePath;
      }
    }

    public getDiskFileSize_args deepCopy() {
      return new getDiskFileSize_args(this);
    }

    @Deprecated
    public getDiskFileSize_args clone() {
      return new getDiskFileSize_args(this);
    }

    public String getVirtualImageDatastorePath() {
      return this.virtualImageDatastorePath;
    }

    public getDiskFileSize_args setVirtualImageDatastorePath(String virtualImageDatastorePath) {
      this.virtualImageDatastorePath = virtualImageDatastorePath;
      return this;
    }

    public void unsetVirtualImageDatastorePath() {
      this.virtualImageDatastorePath = null;
    }

    /** Returns true if field virtualImageDatastorePath is set (has been asigned a value) and false otherwise */
    public boolean isSetVirtualImageDatastorePath() {
      return this.virtualImageDatastorePath != null;
    }

    public void setVirtualImageDatastorePathIsSet(boolean value) {
      if (!value) {
        this.virtualImageDatastorePath = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VIRTUAL_IMAGE_DATASTORE_PATH:
        if (value == null) {
          unsetVirtualImageDatastorePath();
        } else {
          setVirtualImageDatastorePath((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VIRTUAL_IMAGE_DATASTORE_PATH:
        return getVirtualImageDatastorePath();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case VIRTUAL_IMAGE_DATASTORE_PATH:
        return isSetVirtualImageDatastorePath();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDiskFileSize_args)
        return this.equals((getDiskFileSize_args)that);
      return false;
    }

    public boolean equals(getDiskFileSize_args that) {
      if (that == null)
        return false;

      boolean this_present_virtualImageDatastorePath = true && this.isSetVirtualImageDatastorePath();
      boolean that_present_virtualImageDatastorePath = true && that.isSetVirtualImageDatastorePath();
      if (this_present_virtualImageDatastorePath || that_present_virtualImageDatastorePath) {
        if (!(this_present_virtualImageDatastorePath && that_present_virtualImageDatastorePath))
          return false;
        if (!this.virtualImageDatastorePath.equals(that.virtualImageDatastorePath))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDiskFileSize_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDiskFileSize_args typedOther = (getDiskFileSize_args)other;

      lastComparison = Boolean.valueOf(isSetVirtualImageDatastorePath()).compareTo(isSetVirtualImageDatastorePath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(virtualImageDatastorePath, typedOther.virtualImageDatastorePath);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case VIRTUAL_IMAGE_DATASTORE_PATH:
              if (field.type == TType.STRING) {
                this.virtualImageDatastorePath = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.virtualImageDatastorePath != null) {
        oprot.writeFieldBegin(VIRTUAL_IMAGE_DATASTORE_PATH_FIELD_DESC);
        oprot.writeString(this.virtualImageDatastorePath);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDiskFileSize_args(");
      boolean first = true;

      sb.append("virtualImageDatastorePath:");
      if (this.virtualImageDatastorePath == null) {
        sb.append("null");
      } else {
        sb.append(this.virtualImageDatastorePath);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDiskFileSize_result implements TBase<getDiskFileSize_result._Fields>, java.io.Serializable, Cloneable, Comparable<getDiskFileSize_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getDiskFileSize_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public long success;
    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      RE((short)1, "re");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getDiskFileSize_result.class, metaDataMap);
    }

    public getDiskFileSize_result() {
    }

    public getDiskFileSize_result(
      long success,
      RimpException re)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDiskFileSize_result(getDiskFileSize_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public getDiskFileSize_result deepCopy() {
      return new getDiskFileSize_result(this);
    }

    @Deprecated
    public getDiskFileSize_result clone() {
      return new getDiskFileSize_result(this);
    }

    public long getSuccess() {
      return this.success;
    }

    public getDiskFileSize_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public RimpException getRe() {
      return this.re;
    }

    public getDiskFileSize_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDiskFileSize_result)
        return this.equals((getDiskFileSize_result)that);
      return false;
    }

    public boolean equals(getDiskFileSize_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDiskFileSize_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDiskFileSize_result typedOther = (getDiskFileSize_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(re, typedOther.re);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.I64) {
                this.success = iprot.readI64();
                setSuccessIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case RE:
              if (field.type == TType.STRUCT) {
                this.re = new RimpException();
                this.re.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDiskFileSize_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDatastores_args implements TBase<getDatastores_args._Fields>, java.io.Serializable, Cloneable, Comparable<getDatastores_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getDatastores_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getDatastores_args.class, metaDataMap);
    }

    public getDatastores_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDatastores_args(getDatastores_args other) {
    }

    public getDatastores_args deepCopy() {
      return new getDatastores_args(this);
    }

    @Deprecated
    public getDatastores_args clone() {
      return new getDatastores_args(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDatastores_args)
        return this.equals((getDatastores_args)that);
      return false;
    }

    public boolean equals(getDatastores_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDatastores_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDatastores_args typedOther = (getDatastores_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDatastores_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDatastores_result implements TBase<getDatastores_result._Fields>, java.io.Serializable, Cloneable, Comparable<getDatastores_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getDatastores_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public List<Datastore> success;
    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      RE((short)1, "re");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Datastore.class))));
      put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getDatastores_result.class, metaDataMap);
    }

    public getDatastores_result() {
    }

    public getDatastores_result(
      List<Datastore> success,
      RimpException re)
    {
      this();
      this.success = success;
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDatastores_result(getDatastores_result other) {
      if (other.isSetSuccess()) {
        List<Datastore> __this__success = new ArrayList<Datastore>();
        for (Datastore other_element : other.success) {
          __this__success.add(new Datastore(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public getDatastores_result deepCopy() {
      return new getDatastores_result(this);
    }

    @Deprecated
    public getDatastores_result clone() {
      return new getDatastores_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Datastore> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Datastore elem) {
      if (this.success == null) {
        this.success = new ArrayList<Datastore>();
      }
      this.success.add(elem);
    }

    public List<Datastore> getSuccess() {
      return this.success;
    }

    public getDatastores_result setSuccess(List<Datastore> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RimpException getRe() {
      return this.re;
    }

    public getDatastores_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Datastore>)value);
        }
        break;

      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDatastores_result)
        return this.equals((getDatastores_result)that);
      return false;
    }

    public boolean equals(getDatastores_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDatastores_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDatastores_result typedOther = (getDatastores_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(re, typedOther.re);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.LIST) {
                {
                  TList _list0 = iprot.readListBegin();
                  this.success = new ArrayList<Datastore>(_list0.size);
                  for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                  {
                    Datastore _elem2;
                    _elem2 = new Datastore();
                    _elem2.read(iprot);
                    this.success.add(_elem2);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case RE:
              if (field.type == TType.STRUCT) {
                this.re = new RimpException();
                this.re.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Datastore _iter3 : this.success)
          {
            _iter3.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDatastores_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getNetInterfaces_args implements TBase<getNetInterfaces_args._Fields>, java.io.Serializable, Cloneable, Comparable<getNetInterfaces_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getNetInterfaces_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getNetInterfaces_args.class, metaDataMap);
    }

    public getNetInterfaces_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getNetInterfaces_args(getNetInterfaces_args other) {
    }

    public getNetInterfaces_args deepCopy() {
      return new getNetInterfaces_args(this);
    }

    @Deprecated
    public getNetInterfaces_args clone() {
      return new getNetInterfaces_args(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getNetInterfaces_args)
        return this.equals((getNetInterfaces_args)that);
      return false;
    }

    public boolean equals(getNetInterfaces_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getNetInterfaces_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getNetInterfaces_args typedOther = (getNetInterfaces_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getNetInterfaces_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getNetInterfaces_result implements TBase<getNetInterfaces_result._Fields>, java.io.Serializable, Cloneable, Comparable<getNetInterfaces_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getNetInterfaces_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public List<NetInterface> success;
    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      RE((short)1, "re");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, NetInterface.class))));
      put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getNetInterfaces_result.class, metaDataMap);
    }

    public getNetInterfaces_result() {
    }

    public getNetInterfaces_result(
      List<NetInterface> success,
      RimpException re)
    {
      this();
      this.success = success;
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getNetInterfaces_result(getNetInterfaces_result other) {
      if (other.isSetSuccess()) {
        List<NetInterface> __this__success = new ArrayList<NetInterface>();
        for (NetInterface other_element : other.success) {
          __this__success.add(new NetInterface(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public getNetInterfaces_result deepCopy() {
      return new getNetInterfaces_result(this);
    }

    @Deprecated
    public getNetInterfaces_result clone() {
      return new getNetInterfaces_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<NetInterface> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(NetInterface elem) {
      if (this.success == null) {
        this.success = new ArrayList<NetInterface>();
      }
      this.success.add(elem);
    }

    public List<NetInterface> getSuccess() {
      return this.success;
    }

    public getNetInterfaces_result setSuccess(List<NetInterface> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RimpException getRe() {
      return this.re;
    }

    public getNetInterfaces_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<NetInterface>)value);
        }
        break;

      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getNetInterfaces_result)
        return this.equals((getNetInterfaces_result)that);
      return false;
    }

    public boolean equals(getNetInterfaces_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getNetInterfaces_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getNetInterfaces_result typedOther = (getNetInterfaces_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(re, typedOther.re);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.LIST) {
                {
                  TList _list4 = iprot.readListBegin();
                  this.success = new ArrayList<NetInterface>(_list4.size);
                  for (int _i5 = 0; _i5 < _list4.size; ++_i5)
                  {
                    NetInterface _elem6;
                    _elem6 = new NetInterface();
                    _elem6.read(iprot);
                    this.success.add(_elem6);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case RE:
              if (field.type == TType.STRUCT) {
                this.re = new RimpException();
                this.re.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (NetInterface _iter7 : this.success)
          {
            _iter7.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getNetInterfaces_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class copyFromRepositoryToDatastore_args implements TBase<copyFromRepositoryToDatastore_args._Fields>, java.io.Serializable, Cloneable, Comparable<copyFromRepositoryToDatastore_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("copyFromRepositoryToDatastore_args");

    private static final TField VIRTUAL_IMAGE_REPOSITORY_PATH_FIELD_DESC = new TField("virtualImageRepositoryPath", TType.STRING, (short)1);
    private static final TField DATASTORE_PATH_FIELD_DESC = new TField("datastorePath", TType.STRING, (short)2);
    private static final TField VIRTUAL_MACHINE_UUID_FIELD_DESC = new TField("virtualMachineUUID", TType.STRING, (short)3);

    public String virtualImageRepositoryPath;
    public String datastorePath;
    public String virtualMachineUUID;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VIRTUAL_IMAGE_REPOSITORY_PATH((short)1, "virtualImageRepositoryPath"),
      DATASTORE_PATH((short)2, "datastorePath"),
      VIRTUAL_MACHINE_UUID((short)3, "virtualMachineUUID");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.VIRTUAL_IMAGE_REPOSITORY_PATH, new FieldMetaData("virtualImageRepositoryPath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.DATASTORE_PATH, new FieldMetaData("datastorePath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.VIRTUAL_MACHINE_UUID, new FieldMetaData("virtualMachineUUID", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(copyFromRepositoryToDatastore_args.class, metaDataMap);
    }

    public copyFromRepositoryToDatastore_args() {
    }

    public copyFromRepositoryToDatastore_args(
      String virtualImageRepositoryPath,
      String datastorePath,
      String virtualMachineUUID)
    {
      this();
      this.virtualImageRepositoryPath = virtualImageRepositoryPath;
      this.datastorePath = datastorePath;
      this.virtualMachineUUID = virtualMachineUUID;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public copyFromRepositoryToDatastore_args(copyFromRepositoryToDatastore_args other) {
      if (other.isSetVirtualImageRepositoryPath()) {
        this.virtualImageRepositoryPath = other.virtualImageRepositoryPath;
      }
      if (other.isSetDatastorePath()) {
        this.datastorePath = other.datastorePath;
      }
      if (other.isSetVirtualMachineUUID()) {
        this.virtualMachineUUID = other.virtualMachineUUID;
      }
    }

    public copyFromRepositoryToDatastore_args deepCopy() {
      return new copyFromRepositoryToDatastore_args(this);
    }

    @Deprecated
    public copyFromRepositoryToDatastore_args clone() {
      return new copyFromRepositoryToDatastore_args(this);
    }

    public String getVirtualImageRepositoryPath() {
      return this.virtualImageRepositoryPath;
    }

    public copyFromRepositoryToDatastore_args setVirtualImageRepositoryPath(String virtualImageRepositoryPath) {
      this.virtualImageRepositoryPath = virtualImageRepositoryPath;
      return this;
    }

    public void unsetVirtualImageRepositoryPath() {
      this.virtualImageRepositoryPath = null;
    }

    /** Returns true if field virtualImageRepositoryPath is set (has been asigned a value) and false otherwise */
    public boolean isSetVirtualImageRepositoryPath() {
      return this.virtualImageRepositoryPath != null;
    }

    public void setVirtualImageRepositoryPathIsSet(boolean value) {
      if (!value) {
        this.virtualImageRepositoryPath = null;
      }
    }

    public String getDatastorePath() {
      return this.datastorePath;
    }

    public copyFromRepositoryToDatastore_args setDatastorePath(String datastorePath) {
      this.datastorePath = datastorePath;
      return this;
    }

    public void unsetDatastorePath() {
      this.datastorePath = null;
    }

    /** Returns true if field datastorePath is set (has been asigned a value) and false otherwise */
    public boolean isSetDatastorePath() {
      return this.datastorePath != null;
    }

    public void setDatastorePathIsSet(boolean value) {
      if (!value) {
        this.datastorePath = null;
      }
    }

    public String getVirtualMachineUUID() {
      return this.virtualMachineUUID;
    }

    public copyFromRepositoryToDatastore_args setVirtualMachineUUID(String virtualMachineUUID) {
      this.virtualMachineUUID = virtualMachineUUID;
      return this;
    }

    public void unsetVirtualMachineUUID() {
      this.virtualMachineUUID = null;
    }

    /** Returns true if field virtualMachineUUID is set (has been asigned a value) and false otherwise */
    public boolean isSetVirtualMachineUUID() {
      return this.virtualMachineUUID != null;
    }

    public void setVirtualMachineUUIDIsSet(boolean value) {
      if (!value) {
        this.virtualMachineUUID = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VIRTUAL_IMAGE_REPOSITORY_PATH:
        if (value == null) {
          unsetVirtualImageRepositoryPath();
        } else {
          setVirtualImageRepositoryPath((String)value);
        }
        break;

      case DATASTORE_PATH:
        if (value == null) {
          unsetDatastorePath();
        } else {
          setDatastorePath((String)value);
        }
        break;

      case VIRTUAL_MACHINE_UUID:
        if (value == null) {
          unsetVirtualMachineUUID();
        } else {
          setVirtualMachineUUID((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VIRTUAL_IMAGE_REPOSITORY_PATH:
        return getVirtualImageRepositoryPath();

      case DATASTORE_PATH:
        return getDatastorePath();

      case VIRTUAL_MACHINE_UUID:
        return getVirtualMachineUUID();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case VIRTUAL_IMAGE_REPOSITORY_PATH:
        return isSetVirtualImageRepositoryPath();
      case DATASTORE_PATH:
        return isSetDatastorePath();
      case VIRTUAL_MACHINE_UUID:
        return isSetVirtualMachineUUID();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof copyFromRepositoryToDatastore_args)
        return this.equals((copyFromRepositoryToDatastore_args)that);
      return false;
    }

    public boolean equals(copyFromRepositoryToDatastore_args that) {
      if (that == null)
        return false;

      boolean this_present_virtualImageRepositoryPath = true && this.isSetVirtualImageRepositoryPath();
      boolean that_present_virtualImageRepositoryPath = true && that.isSetVirtualImageRepositoryPath();
      if (this_present_virtualImageRepositoryPath || that_present_virtualImageRepositoryPath) {
        if (!(this_present_virtualImageRepositoryPath && that_present_virtualImageRepositoryPath))
          return false;
        if (!this.virtualImageRepositoryPath.equals(that.virtualImageRepositoryPath))
          return false;
      }

      boolean this_present_datastorePath = true && this.isSetDatastorePath();
      boolean that_present_datastorePath = true && that.isSetDatastorePath();
      if (this_present_datastorePath || that_present_datastorePath) {
        if (!(this_present_datastorePath && that_present_datastorePath))
          return false;
        if (!this.datastorePath.equals(that.datastorePath))
          return false;
      }

      boolean this_present_virtualMachineUUID = true && this.isSetVirtualMachineUUID();
      boolean that_present_virtualMachineUUID = true && that.isSetVirtualMachineUUID();
      if (this_present_virtualMachineUUID || that_present_virtualMachineUUID) {
        if (!(this_present_virtualMachineUUID && that_present_virtualMachineUUID))
          return false;
        if (!this.virtualMachineUUID.equals(that.virtualMachineUUID))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(copyFromRepositoryToDatastore_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      copyFromRepositoryToDatastore_args typedOther = (copyFromRepositoryToDatastore_args)other;

      lastComparison = Boolean.valueOf(isSetVirtualImageRepositoryPath()).compareTo(isSetVirtualImageRepositoryPath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(virtualImageRepositoryPath, typedOther.virtualImageRepositoryPath);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetDatastorePath()).compareTo(isSetDatastorePath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(datastorePath, typedOther.datastorePath);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetVirtualMachineUUID()).compareTo(isSetVirtualMachineUUID());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(virtualMachineUUID, typedOther.virtualMachineUUID);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case VIRTUAL_IMAGE_REPOSITORY_PATH:
              if (field.type == TType.STRING) {
                this.virtualImageRepositoryPath = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case DATASTORE_PATH:
              if (field.type == TType.STRING) {
                this.datastorePath = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case VIRTUAL_MACHINE_UUID:
              if (field.type == TType.STRING) {
                this.virtualMachineUUID = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.virtualImageRepositoryPath != null) {
        oprot.writeFieldBegin(VIRTUAL_IMAGE_REPOSITORY_PATH_FIELD_DESC);
        oprot.writeString(this.virtualImageRepositoryPath);
        oprot.writeFieldEnd();
      }
      if (this.datastorePath != null) {
        oprot.writeFieldBegin(DATASTORE_PATH_FIELD_DESC);
        oprot.writeString(this.datastorePath);
        oprot.writeFieldEnd();
      }
      if (this.virtualMachineUUID != null) {
        oprot.writeFieldBegin(VIRTUAL_MACHINE_UUID_FIELD_DESC);
        oprot.writeString(this.virtualMachineUUID);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("copyFromRepositoryToDatastore_args(");
      boolean first = true;

      sb.append("virtualImageRepositoryPath:");
      if (this.virtualImageRepositoryPath == null) {
        sb.append("null");
      } else {
        sb.append(this.virtualImageRepositoryPath);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("datastorePath:");
      if (this.datastorePath == null) {
        sb.append("null");
      } else {
        sb.append(this.datastorePath);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("virtualMachineUUID:");
      if (this.virtualMachineUUID == null) {
        sb.append("null");
      } else {
        sb.append(this.virtualMachineUUID);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class copyFromRepositoryToDatastore_result implements TBase<copyFromRepositoryToDatastore_result._Fields>, java.io.Serializable, Cloneable, Comparable<copyFromRepositoryToDatastore_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("copyFromRepositoryToDatastore_result");

    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      RE((short)1, "re");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(copyFromRepositoryToDatastore_result.class, metaDataMap);
    }

    public copyFromRepositoryToDatastore_result() {
    }

    public copyFromRepositoryToDatastore_result(
      RimpException re)
    {
      this();
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public copyFromRepositoryToDatastore_result(copyFromRepositoryToDatastore_result other) {
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public copyFromRepositoryToDatastore_result deepCopy() {
      return new copyFromRepositoryToDatastore_result(this);
    }

    @Deprecated
    public copyFromRepositoryToDatastore_result clone() {
      return new copyFromRepositoryToDatastore_result(this);
    }

    public RimpException getRe() {
      return this.re;
    }

    public copyFromRepositoryToDatastore_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof copyFromRepositoryToDatastore_result)
        return this.equals((copyFromRepositoryToDatastore_result)that);
      return false;
    }

    public boolean equals(copyFromRepositoryToDatastore_result that) {
      if (that == null)
        return false;

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(copyFromRepositoryToDatastore_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      copyFromRepositoryToDatastore_result typedOther = (copyFromRepositoryToDatastore_result)other;

      lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(re, typedOther.re);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case RE:
              if (field.type == TType.STRUCT) {
                this.re = new RimpException();
                this.re.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("copyFromRepositoryToDatastore_result(");
      boolean first = true;

      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteVirtualImageFromDatastore_args implements TBase<deleteVirtualImageFromDatastore_args._Fields>, java.io.Serializable, Cloneable, Comparable<deleteVirtualImageFromDatastore_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteVirtualImageFromDatastore_args");

    private static final TField DATASTORE_PATH_FIELD_DESC = new TField("datastorePath", TType.STRING, (short)1);
    private static final TField VIRTUAL_MACHINE_UUID_FIELD_DESC = new TField("virtualMachineUUID", TType.STRING, (short)2);

    public String datastorePath;
    public String virtualMachineUUID;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DATASTORE_PATH((short)1, "datastorePath"),
      VIRTUAL_MACHINE_UUID((short)2, "virtualMachineUUID");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.DATASTORE_PATH, new FieldMetaData("datastorePath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.VIRTUAL_MACHINE_UUID, new FieldMetaData("virtualMachineUUID", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(deleteVirtualImageFromDatastore_args.class, metaDataMap);
    }

    public deleteVirtualImageFromDatastore_args() {
    }

    public deleteVirtualImageFromDatastore_args(
      String datastorePath,
      String virtualMachineUUID)
    {
      this();
      this.datastorePath = datastorePath;
      this.virtualMachineUUID = virtualMachineUUID;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteVirtualImageFromDatastore_args(deleteVirtualImageFromDatastore_args other) {
      if (other.isSetDatastorePath()) {
        this.datastorePath = other.datastorePath;
      }
      if (other.isSetVirtualMachineUUID()) {
        this.virtualMachineUUID = other.virtualMachineUUID;
      }
    }

    public deleteVirtualImageFromDatastore_args deepCopy() {
      return new deleteVirtualImageFromDatastore_args(this);
    }

    @Deprecated
    public deleteVirtualImageFromDatastore_args clone() {
      return new deleteVirtualImageFromDatastore_args(this);
    }

    public String getDatastorePath() {
      return this.datastorePath;
    }

    public deleteVirtualImageFromDatastore_args setDatastorePath(String datastorePath) {
      this.datastorePath = datastorePath;
      return this;
    }

    public void unsetDatastorePath() {
      this.datastorePath = null;
    }

    /** Returns true if field datastorePath is set (has been asigned a value) and false otherwise */
    public boolean isSetDatastorePath() {
      return this.datastorePath != null;
    }

    public void setDatastorePathIsSet(boolean value) {
      if (!value) {
        this.datastorePath = null;
      }
    }

    public String getVirtualMachineUUID() {
      return this.virtualMachineUUID;
    }

    public deleteVirtualImageFromDatastore_args setVirtualMachineUUID(String virtualMachineUUID) {
      this.virtualMachineUUID = virtualMachineUUID;
      return this;
    }

    public void unsetVirtualMachineUUID() {
      this.virtualMachineUUID = null;
    }

    /** Returns true if field virtualMachineUUID is set (has been asigned a value) and false otherwise */
    public boolean isSetVirtualMachineUUID() {
      return this.virtualMachineUUID != null;
    }

    public void setVirtualMachineUUIDIsSet(boolean value) {
      if (!value) {
        this.virtualMachineUUID = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DATASTORE_PATH:
        if (value == null) {
          unsetDatastorePath();
        } else {
          setDatastorePath((String)value);
        }
        break;

      case VIRTUAL_MACHINE_UUID:
        if (value == null) {
          unsetVirtualMachineUUID();
        } else {
          setVirtualMachineUUID((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DATASTORE_PATH:
        return getDatastorePath();

      case VIRTUAL_MACHINE_UUID:
        return getVirtualMachineUUID();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case DATASTORE_PATH:
        return isSetDatastorePath();
      case VIRTUAL_MACHINE_UUID:
        return isSetVirtualMachineUUID();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteVirtualImageFromDatastore_args)
        return this.equals((deleteVirtualImageFromDatastore_args)that);
      return false;
    }

    public boolean equals(deleteVirtualImageFromDatastore_args that) {
      if (that == null)
        return false;

      boolean this_present_datastorePath = true && this.isSetDatastorePath();
      boolean that_present_datastorePath = true && that.isSetDatastorePath();
      if (this_present_datastorePath || that_present_datastorePath) {
        if (!(this_present_datastorePath && that_present_datastorePath))
          return false;
        if (!this.datastorePath.equals(that.datastorePath))
          return false;
      }

      boolean this_present_virtualMachineUUID = true && this.isSetVirtualMachineUUID();
      boolean that_present_virtualMachineUUID = true && that.isSetVirtualMachineUUID();
      if (this_present_virtualMachineUUID || that_present_virtualMachineUUID) {
        if (!(this_present_virtualMachineUUID && that_present_virtualMachineUUID))
          return false;
        if (!this.virtualMachineUUID.equals(that.virtualMachineUUID))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteVirtualImageFromDatastore_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteVirtualImageFromDatastore_args typedOther = (deleteVirtualImageFromDatastore_args)other;

      lastComparison = Boolean.valueOf(isSetDatastorePath()).compareTo(isSetDatastorePath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(datastorePath, typedOther.datastorePath);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetVirtualMachineUUID()).compareTo(isSetVirtualMachineUUID());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(virtualMachineUUID, typedOther.virtualMachineUUID);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case DATASTORE_PATH:
              if (field.type == TType.STRING) {
                this.datastorePath = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case VIRTUAL_MACHINE_UUID:
              if (field.type == TType.STRING) {
                this.virtualMachineUUID = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.datastorePath != null) {
        oprot.writeFieldBegin(DATASTORE_PATH_FIELD_DESC);
        oprot.writeString(this.datastorePath);
        oprot.writeFieldEnd();
      }
      if (this.virtualMachineUUID != null) {
        oprot.writeFieldBegin(VIRTUAL_MACHINE_UUID_FIELD_DESC);
        oprot.writeString(this.virtualMachineUUID);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteVirtualImageFromDatastore_args(");
      boolean first = true;

      sb.append("datastorePath:");
      if (this.datastorePath == null) {
        sb.append("null");
      } else {
        sb.append(this.datastorePath);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("virtualMachineUUID:");
      if (this.virtualMachineUUID == null) {
        sb.append("null");
      } else {
        sb.append(this.virtualMachineUUID);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteVirtualImageFromDatastore_result implements TBase<deleteVirtualImageFromDatastore_result._Fields>, java.io.Serializable, Cloneable, Comparable<deleteVirtualImageFromDatastore_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteVirtualImageFromDatastore_result");

    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      RE((short)1, "re");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(deleteVirtualImageFromDatastore_result.class, metaDataMap);
    }

    public deleteVirtualImageFromDatastore_result() {
    }

    public deleteVirtualImageFromDatastore_result(
      RimpException re)
    {
      this();
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteVirtualImageFromDatastore_result(deleteVirtualImageFromDatastore_result other) {
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public deleteVirtualImageFromDatastore_result deepCopy() {
      return new deleteVirtualImageFromDatastore_result(this);
    }

    @Deprecated
    public deleteVirtualImageFromDatastore_result clone() {
      return new deleteVirtualImageFromDatastore_result(this);
    }

    public RimpException getRe() {
      return this.re;
    }

    public deleteVirtualImageFromDatastore_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteVirtualImageFromDatastore_result)
        return this.equals((deleteVirtualImageFromDatastore_result)that);
      return false;
    }

    public boolean equals(deleteVirtualImageFromDatastore_result that) {
      if (that == null)
        return false;

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteVirtualImageFromDatastore_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteVirtualImageFromDatastore_result typedOther = (deleteVirtualImageFromDatastore_result)other;

      lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(re, typedOther.re);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case RE:
              if (field.type == TType.STRUCT) {
                this.re = new RimpException();
                this.re.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteVirtualImageFromDatastore_result(");
      boolean first = true;

      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class copyFromDatastoreToRepository_args implements TBase<copyFromDatastoreToRepository_args._Fields>, java.io.Serializable, Cloneable, Comparable<copyFromDatastoreToRepository_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("copyFromDatastoreToRepository_args");

    private static final TField VIRTUAL_MACHINE_UUID_FIELD_DESC = new TField("virtualMachineUUID", TType.STRING, (short)1);
    private static final TField SNAPSHOT_FIELD_DESC = new TField("snapshot", TType.STRING, (short)2);
    private static final TField DESTINATION_REPOSITORY_PATH_FIELD_DESC = new TField("destinationRepositoryPath", TType.STRING, (short)3);
    private static final TField SOURCE_DATASTORE_PATH_FIELD_DESC = new TField("sourceDatastorePath", TType.STRING, (short)4);

    public String virtualMachineUUID;
    public String snapshot;
    public String destinationRepositoryPath;
    public String sourceDatastorePath;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VIRTUAL_MACHINE_UUID((short)1, "virtualMachineUUID"),
      SNAPSHOT((short)2, "snapshot"),
      DESTINATION_REPOSITORY_PATH((short)3, "destinationRepositoryPath"),
      SOURCE_DATASTORE_PATH((short)4, "sourceDatastorePath");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.VIRTUAL_MACHINE_UUID, new FieldMetaData("virtualMachineUUID", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.SNAPSHOT, new FieldMetaData("snapshot", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.DESTINATION_REPOSITORY_PATH, new FieldMetaData("destinationRepositoryPath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.SOURCE_DATASTORE_PATH, new FieldMetaData("sourceDatastorePath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(copyFromDatastoreToRepository_args.class, metaDataMap);
    }

    public copyFromDatastoreToRepository_args() {
    }

    public copyFromDatastoreToRepository_args(
      String virtualMachineUUID,
      String snapshot,
      String destinationRepositoryPath,
      String sourceDatastorePath)
    {
      this();
      this.virtualMachineUUID = virtualMachineUUID;
      this.snapshot = snapshot;
      this.destinationRepositoryPath = destinationRepositoryPath;
      this.sourceDatastorePath = sourceDatastorePath;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public copyFromDatastoreToRepository_args(copyFromDatastoreToRepository_args other) {
      if (other.isSetVirtualMachineUUID()) {
        this.virtualMachineUUID = other.virtualMachineUUID;
      }
      if (other.isSetSnapshot()) {
        this.snapshot = other.snapshot;
      }
      if (other.isSetDestinationRepositoryPath()) {
        this.destinationRepositoryPath = other.destinationRepositoryPath;
      }
      if (other.isSetSourceDatastorePath()) {
        this.sourceDatastorePath = other.sourceDatastorePath;
      }
    }

    public copyFromDatastoreToRepository_args deepCopy() {
      return new copyFromDatastoreToRepository_args(this);
    }

    @Deprecated
    public copyFromDatastoreToRepository_args clone() {
      return new copyFromDatastoreToRepository_args(this);
    }

    public String getVirtualMachineUUID() {
      return this.virtualMachineUUID;
    }

    public copyFromDatastoreToRepository_args setVirtualMachineUUID(String virtualMachineUUID) {
      this.virtualMachineUUID = virtualMachineUUID;
      return this;
    }

    public void unsetVirtualMachineUUID() {
      this.virtualMachineUUID = null;
    }

    /** Returns true if field virtualMachineUUID is set (has been asigned a value) and false otherwise */
    public boolean isSetVirtualMachineUUID() {
      return this.virtualMachineUUID != null;
    }

    public void setVirtualMachineUUIDIsSet(boolean value) {
      if (!value) {
        this.virtualMachineUUID = null;
      }
    }

    public String getSnapshot() {
      return this.snapshot;
    }

    public copyFromDatastoreToRepository_args setSnapshot(String snapshot) {
      this.snapshot = snapshot;
      return this;
    }

    public void unsetSnapshot() {
      this.snapshot = null;
    }

    /** Returns true if field snapshot is set (has been asigned a value) and false otherwise */
    public boolean isSetSnapshot() {
      return this.snapshot != null;
    }

    public void setSnapshotIsSet(boolean value) {
      if (!value) {
        this.snapshot = null;
      }
    }

    public String getDestinationRepositoryPath() {
      return this.destinationRepositoryPath;
    }

    public copyFromDatastoreToRepository_args setDestinationRepositoryPath(String destinationRepositoryPath) {
      this.destinationRepositoryPath = destinationRepositoryPath;
      return this;
    }

    public void unsetDestinationRepositoryPath() {
      this.destinationRepositoryPath = null;
    }

    /** Returns true if field destinationRepositoryPath is set (has been asigned a value) and false otherwise */
    public boolean isSetDestinationRepositoryPath() {
      return this.destinationRepositoryPath != null;
    }

    public void setDestinationRepositoryPathIsSet(boolean value) {
      if (!value) {
        this.destinationRepositoryPath = null;
      }
    }

    public String getSourceDatastorePath() {
      return this.sourceDatastorePath;
    }

    public copyFromDatastoreToRepository_args setSourceDatastorePath(String sourceDatastorePath) {
      this.sourceDatastorePath = sourceDatastorePath;
      return this;
    }

    public void unsetSourceDatastorePath() {
      this.sourceDatastorePath = null;
    }

    /** Returns true if field sourceDatastorePath is set (has been asigned a value) and false otherwise */
    public boolean isSetSourceDatastorePath() {
      return this.sourceDatastorePath != null;
    }

    public void setSourceDatastorePathIsSet(boolean value) {
      if (!value) {
        this.sourceDatastorePath = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VIRTUAL_MACHINE_UUID:
        if (value == null) {
          unsetVirtualMachineUUID();
        } else {
          setVirtualMachineUUID((String)value);
        }
        break;

      case SNAPSHOT:
        if (value == null) {
          unsetSnapshot();
        } else {
          setSnapshot((String)value);
        }
        break;

      case DESTINATION_REPOSITORY_PATH:
        if (value == null) {
          unsetDestinationRepositoryPath();
        } else {
          setDestinationRepositoryPath((String)value);
        }
        break;

      case SOURCE_DATASTORE_PATH:
        if (value == null) {
          unsetSourceDatastorePath();
        } else {
          setSourceDatastorePath((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VIRTUAL_MACHINE_UUID:
        return getVirtualMachineUUID();

      case SNAPSHOT:
        return getSnapshot();

      case DESTINATION_REPOSITORY_PATH:
        return getDestinationRepositoryPath();

      case SOURCE_DATASTORE_PATH:
        return getSourceDatastorePath();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case VIRTUAL_MACHINE_UUID:
        return isSetVirtualMachineUUID();
      case SNAPSHOT:
        return isSetSnapshot();
      case DESTINATION_REPOSITORY_PATH:
        return isSetDestinationRepositoryPath();
      case SOURCE_DATASTORE_PATH:
        return isSetSourceDatastorePath();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof copyFromDatastoreToRepository_args)
        return this.equals((copyFromDatastoreToRepository_args)that);
      return false;
    }

    public boolean equals(copyFromDatastoreToRepository_args that) {
      if (that == null)
        return false;

      boolean this_present_virtualMachineUUID = true && this.isSetVirtualMachineUUID();
      boolean that_present_virtualMachineUUID = true && that.isSetVirtualMachineUUID();
      if (this_present_virtualMachineUUID || that_present_virtualMachineUUID) {
        if (!(this_present_virtualMachineUUID && that_present_virtualMachineUUID))
          return false;
        if (!this.virtualMachineUUID.equals(that.virtualMachineUUID))
          return false;
      }

      boolean this_present_snapshot = true && this.isSetSnapshot();
      boolean that_present_snapshot = true && that.isSetSnapshot();
      if (this_present_snapshot || that_present_snapshot) {
        if (!(this_present_snapshot && that_present_snapshot))
          return false;
        if (!this.snapshot.equals(that.snapshot))
          return false;
      }

      boolean this_present_destinationRepositoryPath = true && this.isSetDestinationRepositoryPath();
      boolean that_present_destinationRepositoryPath = true && that.isSetDestinationRepositoryPath();
      if (this_present_destinationRepositoryPath || that_present_destinationRepositoryPath) {
        if (!(this_present_destinationRepositoryPath && that_present_destinationRepositoryPath))
          return false;
        if (!this.destinationRepositoryPath.equals(that.destinationRepositoryPath))
          return false;
      }

      boolean this_present_sourceDatastorePath = true && this.isSetSourceDatastorePath();
      boolean that_present_sourceDatastorePath = true && that.isSetSourceDatastorePath();
      if (this_present_sourceDatastorePath || that_present_sourceDatastorePath) {
        if (!(this_present_sourceDatastorePath && that_present_sourceDatastorePath))
          return false;
        if (!this.sourceDatastorePath.equals(that.sourceDatastorePath))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(copyFromDatastoreToRepository_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      copyFromDatastoreToRepository_args typedOther = (copyFromDatastoreToRepository_args)other;

      lastComparison = Boolean.valueOf(isSetVirtualMachineUUID()).compareTo(isSetVirtualMachineUUID());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(virtualMachineUUID, typedOther.virtualMachineUUID);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetSnapshot()).compareTo(isSetSnapshot());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(snapshot, typedOther.snapshot);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetDestinationRepositoryPath()).compareTo(isSetDestinationRepositoryPath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(destinationRepositoryPath, typedOther.destinationRepositoryPath);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetSourceDatastorePath()).compareTo(isSetSourceDatastorePath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(sourceDatastorePath, typedOther.sourceDatastorePath);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case VIRTUAL_MACHINE_UUID:
              if (field.type == TType.STRING) {
                this.virtualMachineUUID = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case SNAPSHOT:
              if (field.type == TType.STRING) {
                this.snapshot = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case DESTINATION_REPOSITORY_PATH:
              if (field.type == TType.STRING) {
                this.destinationRepositoryPath = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case SOURCE_DATASTORE_PATH:
              if (field.type == TType.STRING) {
                this.sourceDatastorePath = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.virtualMachineUUID != null) {
        oprot.writeFieldBegin(VIRTUAL_MACHINE_UUID_FIELD_DESC);
        oprot.writeString(this.virtualMachineUUID);
        oprot.writeFieldEnd();
      }
      if (this.snapshot != null) {
        oprot.writeFieldBegin(SNAPSHOT_FIELD_DESC);
        oprot.writeString(this.snapshot);
        oprot.writeFieldEnd();
      }
      if (this.destinationRepositoryPath != null) {
        oprot.writeFieldBegin(DESTINATION_REPOSITORY_PATH_FIELD_DESC);
        oprot.writeString(this.destinationRepositoryPath);
        oprot.writeFieldEnd();
      }
      if (this.sourceDatastorePath != null) {
        oprot.writeFieldBegin(SOURCE_DATASTORE_PATH_FIELD_DESC);
        oprot.writeString(this.sourceDatastorePath);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("copyFromDatastoreToRepository_args(");
      boolean first = true;

      sb.append("virtualMachineUUID:");
      if (this.virtualMachineUUID == null) {
        sb.append("null");
      } else {
        sb.append(this.virtualMachineUUID);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("snapshot:");
      if (this.snapshot == null) {
        sb.append("null");
      } else {
        sb.append(this.snapshot);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("destinationRepositoryPath:");
      if (this.destinationRepositoryPath == null) {
        sb.append("null");
      } else {
        sb.append(this.destinationRepositoryPath);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sourceDatastorePath:");
      if (this.sourceDatastorePath == null) {
        sb.append("null");
      } else {
        sb.append(this.sourceDatastorePath);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class copyFromDatastoreToRepository_result implements TBase<copyFromDatastoreToRepository_result._Fields>, java.io.Serializable, Cloneable, Comparable<copyFromDatastoreToRepository_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("copyFromDatastoreToRepository_result");

    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      RE((short)1, "re");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(copyFromDatastoreToRepository_result.class, metaDataMap);
    }

    public copyFromDatastoreToRepository_result() {
    }

    public copyFromDatastoreToRepository_result(
      RimpException re)
    {
      this();
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public copyFromDatastoreToRepository_result(copyFromDatastoreToRepository_result other) {
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public copyFromDatastoreToRepository_result deepCopy() {
      return new copyFromDatastoreToRepository_result(this);
    }

    @Deprecated
    public copyFromDatastoreToRepository_result clone() {
      return new copyFromDatastoreToRepository_result(this);
    }

    public RimpException getRe() {
      return this.re;
    }

    public copyFromDatastoreToRepository_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof copyFromDatastoreToRepository_result)
        return this.equals((copyFromDatastoreToRepository_result)that);
      return false;
    }

    public boolean equals(copyFromDatastoreToRepository_result that) {
      if (that == null)
        return false;

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(copyFromDatastoreToRepository_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      copyFromDatastoreToRepository_result typedOther = (copyFromDatastoreToRepository_result)other;

      lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(re, typedOther.re);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case RE:
              if (field.type == TType.STRUCT) {
                this.re = new RimpException();
                this.re.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("copyFromDatastoreToRepository_result(");
      boolean first = true;

      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createVLAN_args implements TBase<createVLAN_args._Fields>, java.io.Serializable, Cloneable, Comparable<createVLAN_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createVLAN_args");

    private static final TField VLAN_TAG_FIELD_DESC = new TField("vlanTag", TType.I32, (short)1);
    private static final TField VLAN_INTERFACE_FIELD_DESC = new TField("vlanInterface", TType.STRING, (short)2);
    private static final TField BRIDGE_INTERFACE_FIELD_DESC = new TField("bridgeInterface", TType.STRING, (short)3);

    public int vlanTag;
    public String vlanInterface;
    public String bridgeInterface;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VLAN_TAG((short)1, "vlanTag"),
      VLAN_INTERFACE((short)2, "vlanInterface"),
      BRIDGE_INTERFACE((short)3, "bridgeInterface");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __VLANTAG_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.VLAN_TAG, new FieldMetaData("vlanTag", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(_Fields.VLAN_INTERFACE, new FieldMetaData("vlanInterface", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.BRIDGE_INTERFACE, new FieldMetaData("bridgeInterface", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(createVLAN_args.class, metaDataMap);
    }

    public createVLAN_args() {
    }

    public createVLAN_args(
      int vlanTag,
      String vlanInterface,
      String bridgeInterface)
    {
      this();
      this.vlanTag = vlanTag;
      setVlanTagIsSet(true);
      this.vlanInterface = vlanInterface;
      this.bridgeInterface = bridgeInterface;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createVLAN_args(createVLAN_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.vlanTag = other.vlanTag;
      if (other.isSetVlanInterface()) {
        this.vlanInterface = other.vlanInterface;
      }
      if (other.isSetBridgeInterface()) {
        this.bridgeInterface = other.bridgeInterface;
      }
    }

    public createVLAN_args deepCopy() {
      return new createVLAN_args(this);
    }

    @Deprecated
    public createVLAN_args clone() {
      return new createVLAN_args(this);
    }

    public int getVlanTag() {
      return this.vlanTag;
    }

    public createVLAN_args setVlanTag(int vlanTag) {
      this.vlanTag = vlanTag;
      setVlanTagIsSet(true);
      return this;
    }

    public void unsetVlanTag() {
      __isset_bit_vector.clear(__VLANTAG_ISSET_ID);
    }

    /** Returns true if field vlanTag is set (has been asigned a value) and false otherwise */
    public boolean isSetVlanTag() {
      return __isset_bit_vector.get(__VLANTAG_ISSET_ID);
    }

    public void setVlanTagIsSet(boolean value) {
      __isset_bit_vector.set(__VLANTAG_ISSET_ID, value);
    }

    public String getVlanInterface() {
      return this.vlanInterface;
    }

    public createVLAN_args setVlanInterface(String vlanInterface) {
      this.vlanInterface = vlanInterface;
      return this;
    }

    public void unsetVlanInterface() {
      this.vlanInterface = null;
    }

    /** Returns true if field vlanInterface is set (has been asigned a value) and false otherwise */
    public boolean isSetVlanInterface() {
      return this.vlanInterface != null;
    }

    public void setVlanInterfaceIsSet(boolean value) {
      if (!value) {
        this.vlanInterface = null;
      }
    }

    public String getBridgeInterface() {
      return this.bridgeInterface;
    }

    public createVLAN_args setBridgeInterface(String bridgeInterface) {
      this.bridgeInterface = bridgeInterface;
      return this;
    }

    public void unsetBridgeInterface() {
      this.bridgeInterface = null;
    }

    /** Returns true if field bridgeInterface is set (has been asigned a value) and false otherwise */
    public boolean isSetBridgeInterface() {
      return this.bridgeInterface != null;
    }

    public void setBridgeInterfaceIsSet(boolean value) {
      if (!value) {
        this.bridgeInterface = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VLAN_TAG:
        if (value == null) {
          unsetVlanTag();
        } else {
          setVlanTag((Integer)value);
        }
        break;

      case VLAN_INTERFACE:
        if (value == null) {
          unsetVlanInterface();
        } else {
          setVlanInterface((String)value);
        }
        break;

      case BRIDGE_INTERFACE:
        if (value == null) {
          unsetBridgeInterface();
        } else {
          setBridgeInterface((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VLAN_TAG:
        return new Integer(getVlanTag());

      case VLAN_INTERFACE:
        return getVlanInterface();

      case BRIDGE_INTERFACE:
        return getBridgeInterface();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case VLAN_TAG:
        return isSetVlanTag();
      case VLAN_INTERFACE:
        return isSetVlanInterface();
      case BRIDGE_INTERFACE:
        return isSetBridgeInterface();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createVLAN_args)
        return this.equals((createVLAN_args)that);
      return false;
    }

    public boolean equals(createVLAN_args that) {
      if (that == null)
        return false;

      boolean this_present_vlanTag = true;
      boolean that_present_vlanTag = true;
      if (this_present_vlanTag || that_present_vlanTag) {
        if (!(this_present_vlanTag && that_present_vlanTag))
          return false;
        if (this.vlanTag != that.vlanTag)
          return false;
      }

      boolean this_present_vlanInterface = true && this.isSetVlanInterface();
      boolean that_present_vlanInterface = true && that.isSetVlanInterface();
      if (this_present_vlanInterface || that_present_vlanInterface) {
        if (!(this_present_vlanInterface && that_present_vlanInterface))
          return false;
        if (!this.vlanInterface.equals(that.vlanInterface))
          return false;
      }

      boolean this_present_bridgeInterface = true && this.isSetBridgeInterface();
      boolean that_present_bridgeInterface = true && that.isSetBridgeInterface();
      if (this_present_bridgeInterface || that_present_bridgeInterface) {
        if (!(this_present_bridgeInterface && that_present_bridgeInterface))
          return false;
        if (!this.bridgeInterface.equals(that.bridgeInterface))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(createVLAN_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      createVLAN_args typedOther = (createVLAN_args)other;

      lastComparison = Boolean.valueOf(isSetVlanTag()).compareTo(isSetVlanTag());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(vlanTag, typedOther.vlanTag);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetVlanInterface()).compareTo(isSetVlanInterface());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(vlanInterface, typedOther.vlanInterface);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetBridgeInterface()).compareTo(isSetBridgeInterface());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(bridgeInterface, typedOther.bridgeInterface);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case VLAN_TAG:
              if (field.type == TType.I32) {
                this.vlanTag = iprot.readI32();
                setVlanTagIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case VLAN_INTERFACE:
              if (field.type == TType.STRING) {
                this.vlanInterface = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case BRIDGE_INTERFACE:
              if (field.type == TType.STRING) {
                this.bridgeInterface = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(VLAN_TAG_FIELD_DESC);
      oprot.writeI32(this.vlanTag);
      oprot.writeFieldEnd();
      if (this.vlanInterface != null) {
        oprot.writeFieldBegin(VLAN_INTERFACE_FIELD_DESC);
        oprot.writeString(this.vlanInterface);
        oprot.writeFieldEnd();
      }
      if (this.bridgeInterface != null) {
        oprot.writeFieldBegin(BRIDGE_INTERFACE_FIELD_DESC);
        oprot.writeString(this.bridgeInterface);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createVLAN_args(");
      boolean first = true;

      sb.append("vlanTag:");
      sb.append(this.vlanTag);
      first = false;
      if (!first) sb.append(", ");
      sb.append("vlanInterface:");
      if (this.vlanInterface == null) {
        sb.append("null");
      } else {
        sb.append(this.vlanInterface);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("bridgeInterface:");
      if (this.bridgeInterface == null) {
        sb.append("null");
      } else {
        sb.append(this.bridgeInterface);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createVLAN_result implements TBase<createVLAN_result._Fields>, java.io.Serializable, Cloneable, Comparable<createVLAN_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createVLAN_result");

    private static final TField VE_FIELD_DESC = new TField("ve", TType.STRUCT, (short)1);

    public VLanException ve;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VE((short)1, "ve");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.VE, new FieldMetaData("ve", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(createVLAN_result.class, metaDataMap);
    }

    public createVLAN_result() {
    }

    public createVLAN_result(
      VLanException ve)
    {
      this();
      this.ve = ve;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createVLAN_result(createVLAN_result other) {
      if (other.isSetVe()) {
        this.ve = new VLanException(other.ve);
      }
    }

    public createVLAN_result deepCopy() {
      return new createVLAN_result(this);
    }

    @Deprecated
    public createVLAN_result clone() {
      return new createVLAN_result(this);
    }

    public VLanException getVe() {
      return this.ve;
    }

    public createVLAN_result setVe(VLanException ve) {
      this.ve = ve;
      return this;
    }

    public void unsetVe() {
      this.ve = null;
    }

    /** Returns true if field ve is set (has been asigned a value) and false otherwise */
    public boolean isSetVe() {
      return this.ve != null;
    }

    public void setVeIsSet(boolean value) {
      if (!value) {
        this.ve = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VE:
        if (value == null) {
          unsetVe();
        } else {
          setVe((VLanException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VE:
        return getVe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case VE:
        return isSetVe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createVLAN_result)
        return this.equals((createVLAN_result)that);
      return false;
    }

    public boolean equals(createVLAN_result that) {
      if (that == null)
        return false;

      boolean this_present_ve = true && this.isSetVe();
      boolean that_present_ve = true && that.isSetVe();
      if (this_present_ve || that_present_ve) {
        if (!(this_present_ve && that_present_ve))
          return false;
        if (!this.ve.equals(that.ve))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(createVLAN_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      createVLAN_result typedOther = (createVLAN_result)other;

      lastComparison = Boolean.valueOf(isSetVe()).compareTo(isSetVe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ve, typedOther.ve);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case VE:
              if (field.type == TType.STRUCT) {
                this.ve = new VLanException();
                this.ve.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetVe()) {
        oprot.writeFieldBegin(VE_FIELD_DESC);
        this.ve.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createVLAN_result(");
      boolean first = true;

      sb.append("ve:");
      if (this.ve == null) {
        sb.append("null");
      } else {
        sb.append(this.ve);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteVLAN_args implements TBase<deleteVLAN_args._Fields>, java.io.Serializable, Cloneable, Comparable<deleteVLAN_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteVLAN_args");

    private static final TField VLAN_TAG_FIELD_DESC = new TField("vlanTag", TType.I32, (short)1);
    private static final TField VLAN_INTERFACE_FIELD_DESC = new TField("vlanInterface", TType.STRING, (short)2);
    private static final TField BRIDGE_INTERFACE_FIELD_DESC = new TField("bridgeInterface", TType.STRING, (short)3);

    public int vlanTag;
    public String vlanInterface;
    public String bridgeInterface;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VLAN_TAG((short)1, "vlanTag"),
      VLAN_INTERFACE((short)2, "vlanInterface"),
      BRIDGE_INTERFACE((short)3, "bridgeInterface");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __VLANTAG_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.VLAN_TAG, new FieldMetaData("vlanTag", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(_Fields.VLAN_INTERFACE, new FieldMetaData("vlanInterface", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.BRIDGE_INTERFACE, new FieldMetaData("bridgeInterface", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(deleteVLAN_args.class, metaDataMap);
    }

    public deleteVLAN_args() {
    }

    public deleteVLAN_args(
      int vlanTag,
      String vlanInterface,
      String bridgeInterface)
    {
      this();
      this.vlanTag = vlanTag;
      setVlanTagIsSet(true);
      this.vlanInterface = vlanInterface;
      this.bridgeInterface = bridgeInterface;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteVLAN_args(deleteVLAN_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.vlanTag = other.vlanTag;
      if (other.isSetVlanInterface()) {
        this.vlanInterface = other.vlanInterface;
      }
      if (other.isSetBridgeInterface()) {
        this.bridgeInterface = other.bridgeInterface;
      }
    }

    public deleteVLAN_args deepCopy() {
      return new deleteVLAN_args(this);
    }

    @Deprecated
    public deleteVLAN_args clone() {
      return new deleteVLAN_args(this);
    }

    public int getVlanTag() {
      return this.vlanTag;
    }

    public deleteVLAN_args setVlanTag(int vlanTag) {
      this.vlanTag = vlanTag;
      setVlanTagIsSet(true);
      return this;
    }

    public void unsetVlanTag() {
      __isset_bit_vector.clear(__VLANTAG_ISSET_ID);
    }

    /** Returns true if field vlanTag is set (has been asigned a value) and false otherwise */
    public boolean isSetVlanTag() {
      return __isset_bit_vector.get(__VLANTAG_ISSET_ID);
    }

    public void setVlanTagIsSet(boolean value) {
      __isset_bit_vector.set(__VLANTAG_ISSET_ID, value);
    }

    public String getVlanInterface() {
      return this.vlanInterface;
    }

    public deleteVLAN_args setVlanInterface(String vlanInterface) {
      this.vlanInterface = vlanInterface;
      return this;
    }

    public void unsetVlanInterface() {
      this.vlanInterface = null;
    }

    /** Returns true if field vlanInterface is set (has been asigned a value) and false otherwise */
    public boolean isSetVlanInterface() {
      return this.vlanInterface != null;
    }

    public void setVlanInterfaceIsSet(boolean value) {
      if (!value) {
        this.vlanInterface = null;
      }
    }

    public String getBridgeInterface() {
      return this.bridgeInterface;
    }

    public deleteVLAN_args setBridgeInterface(String bridgeInterface) {
      this.bridgeInterface = bridgeInterface;
      return this;
    }

    public void unsetBridgeInterface() {
      this.bridgeInterface = null;
    }

    /** Returns true if field bridgeInterface is set (has been asigned a value) and false otherwise */
    public boolean isSetBridgeInterface() {
      return this.bridgeInterface != null;
    }

    public void setBridgeInterfaceIsSet(boolean value) {
      if (!value) {
        this.bridgeInterface = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VLAN_TAG:
        if (value == null) {
          unsetVlanTag();
        } else {
          setVlanTag((Integer)value);
        }
        break;

      case VLAN_INTERFACE:
        if (value == null) {
          unsetVlanInterface();
        } else {
          setVlanInterface((String)value);
        }
        break;

      case BRIDGE_INTERFACE:
        if (value == null) {
          unsetBridgeInterface();
        } else {
          setBridgeInterface((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VLAN_TAG:
        return new Integer(getVlanTag());

      case VLAN_INTERFACE:
        return getVlanInterface();

      case BRIDGE_INTERFACE:
        return getBridgeInterface();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case VLAN_TAG:
        return isSetVlanTag();
      case VLAN_INTERFACE:
        return isSetVlanInterface();
      case BRIDGE_INTERFACE:
        return isSetBridgeInterface();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteVLAN_args)
        return this.equals((deleteVLAN_args)that);
      return false;
    }

    public boolean equals(deleteVLAN_args that) {
      if (that == null)
        return false;

      boolean this_present_vlanTag = true;
      boolean that_present_vlanTag = true;
      if (this_present_vlanTag || that_present_vlanTag) {
        if (!(this_present_vlanTag && that_present_vlanTag))
          return false;
        if (this.vlanTag != that.vlanTag)
          return false;
      }

      boolean this_present_vlanInterface = true && this.isSetVlanInterface();
      boolean that_present_vlanInterface = true && that.isSetVlanInterface();
      if (this_present_vlanInterface || that_present_vlanInterface) {
        if (!(this_present_vlanInterface && that_present_vlanInterface))
          return false;
        if (!this.vlanInterface.equals(that.vlanInterface))
          return false;
      }

      boolean this_present_bridgeInterface = true && this.isSetBridgeInterface();
      boolean that_present_bridgeInterface = true && that.isSetBridgeInterface();
      if (this_present_bridgeInterface || that_present_bridgeInterface) {
        if (!(this_present_bridgeInterface && that_present_bridgeInterface))
          return false;
        if (!this.bridgeInterface.equals(that.bridgeInterface))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteVLAN_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteVLAN_args typedOther = (deleteVLAN_args)other;

      lastComparison = Boolean.valueOf(isSetVlanTag()).compareTo(isSetVlanTag());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(vlanTag, typedOther.vlanTag);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetVlanInterface()).compareTo(isSetVlanInterface());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(vlanInterface, typedOther.vlanInterface);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetBridgeInterface()).compareTo(isSetBridgeInterface());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(bridgeInterface, typedOther.bridgeInterface);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case VLAN_TAG:
              if (field.type == TType.I32) {
                this.vlanTag = iprot.readI32();
                setVlanTagIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case VLAN_INTERFACE:
              if (field.type == TType.STRING) {
                this.vlanInterface = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case BRIDGE_INTERFACE:
              if (field.type == TType.STRING) {
                this.bridgeInterface = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(VLAN_TAG_FIELD_DESC);
      oprot.writeI32(this.vlanTag);
      oprot.writeFieldEnd();
      if (this.vlanInterface != null) {
        oprot.writeFieldBegin(VLAN_INTERFACE_FIELD_DESC);
        oprot.writeString(this.vlanInterface);
        oprot.writeFieldEnd();
      }
      if (this.bridgeInterface != null) {
        oprot.writeFieldBegin(BRIDGE_INTERFACE_FIELD_DESC);
        oprot.writeString(this.bridgeInterface);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteVLAN_args(");
      boolean first = true;

      sb.append("vlanTag:");
      sb.append(this.vlanTag);
      first = false;
      if (!first) sb.append(", ");
      sb.append("vlanInterface:");
      if (this.vlanInterface == null) {
        sb.append("null");
      } else {
        sb.append(this.vlanInterface);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("bridgeInterface:");
      if (this.bridgeInterface == null) {
        sb.append("null");
      } else {
        sb.append(this.bridgeInterface);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteVLAN_result implements TBase<deleteVLAN_result._Fields>, java.io.Serializable, Cloneable, Comparable<deleteVLAN_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteVLAN_result");

    private static final TField VE_FIELD_DESC = new TField("ve", TType.STRUCT, (short)1);

    public VLanException ve;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VE((short)1, "ve");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.VE, new FieldMetaData("ve", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(deleteVLAN_result.class, metaDataMap);
    }

    public deleteVLAN_result() {
    }

    public deleteVLAN_result(
      VLanException ve)
    {
      this();
      this.ve = ve;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteVLAN_result(deleteVLAN_result other) {
      if (other.isSetVe()) {
        this.ve = new VLanException(other.ve);
      }
    }

    public deleteVLAN_result deepCopy() {
      return new deleteVLAN_result(this);
    }

    @Deprecated
    public deleteVLAN_result clone() {
      return new deleteVLAN_result(this);
    }

    public VLanException getVe() {
      return this.ve;
    }

    public deleteVLAN_result setVe(VLanException ve) {
      this.ve = ve;
      return this;
    }

    public void unsetVe() {
      this.ve = null;
    }

    /** Returns true if field ve is set (has been asigned a value) and false otherwise */
    public boolean isSetVe() {
      return this.ve != null;
    }

    public void setVeIsSet(boolean value) {
      if (!value) {
        this.ve = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VE:
        if (value == null) {
          unsetVe();
        } else {
          setVe((VLanException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VE:
        return getVe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case VE:
        return isSetVe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteVLAN_result)
        return this.equals((deleteVLAN_result)that);
      return false;
    }

    public boolean equals(deleteVLAN_result that) {
      if (that == null)
        return false;

      boolean this_present_ve = true && this.isSetVe();
      boolean that_present_ve = true && that.isSetVe();
      if (this_present_ve || that_present_ve) {
        if (!(this_present_ve && that_present_ve))
          return false;
        if (!this.ve.equals(that.ve))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteVLAN_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteVLAN_result typedOther = (deleteVLAN_result)other;

      lastComparison = Boolean.valueOf(isSetVe()).compareTo(isSetVe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ve, typedOther.ve);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case VE:
              if (field.type == TType.STRUCT) {
                this.ve = new VLanException();
                this.ve.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetVe()) {
        oprot.writeFieldBegin(VE_FIELD_DESC);
        this.ve.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteVLAN_result(");
      boolean first = true;

      sb.append("ve:");
      if (this.ve == null) {
        sb.append("null");
      } else {
        sb.append(this.ve);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkVLANConfiguration_args implements TBase<checkVLANConfiguration_args._Fields>, java.io.Serializable, Cloneable, Comparable<checkVLANConfiguration_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("checkVLANConfiguration_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(checkVLANConfiguration_args.class, metaDataMap);
    }

    public checkVLANConfiguration_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkVLANConfiguration_args(checkVLANConfiguration_args other) {
    }

    public checkVLANConfiguration_args deepCopy() {
      return new checkVLANConfiguration_args(this);
    }

    @Deprecated
    public checkVLANConfiguration_args clone() {
      return new checkVLANConfiguration_args(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkVLANConfiguration_args)
        return this.equals((checkVLANConfiguration_args)that);
      return false;
    }

    public boolean equals(checkVLANConfiguration_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkVLANConfiguration_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkVLANConfiguration_args typedOther = (checkVLANConfiguration_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkVLANConfiguration_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkVLANConfiguration_result implements TBase<checkVLANConfiguration_result._Fields>, java.io.Serializable, Cloneable, Comparable<checkVLANConfiguration_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("checkVLANConfiguration_result");

    private static final TField VE_FIELD_DESC = new TField("ve", TType.STRUCT, (short)1);

    public VLanException ve;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VE((short)1, "ve");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.VE, new FieldMetaData("ve", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(checkVLANConfiguration_result.class, metaDataMap);
    }

    public checkVLANConfiguration_result() {
    }

    public checkVLANConfiguration_result(
      VLanException ve)
    {
      this();
      this.ve = ve;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkVLANConfiguration_result(checkVLANConfiguration_result other) {
      if (other.isSetVe()) {
        this.ve = new VLanException(other.ve);
      }
    }

    public checkVLANConfiguration_result deepCopy() {
      return new checkVLANConfiguration_result(this);
    }

    @Deprecated
    public checkVLANConfiguration_result clone() {
      return new checkVLANConfiguration_result(this);
    }

    public VLanException getVe() {
      return this.ve;
    }

    public checkVLANConfiguration_result setVe(VLanException ve) {
      this.ve = ve;
      return this;
    }

    public void unsetVe() {
      this.ve = null;
    }

    /** Returns true if field ve is set (has been asigned a value) and false otherwise */
    public boolean isSetVe() {
      return this.ve != null;
    }

    public void setVeIsSet(boolean value) {
      if (!value) {
        this.ve = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VE:
        if (value == null) {
          unsetVe();
        } else {
          setVe((VLanException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VE:
        return getVe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case VE:
        return isSetVe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkVLANConfiguration_result)
        return this.equals((checkVLANConfiguration_result)that);
      return false;
    }

    public boolean equals(checkVLANConfiguration_result that) {
      if (that == null)
        return false;

      boolean this_present_ve = true && this.isSetVe();
      boolean that_present_ve = true && that.isSetVe();
      if (this_present_ve || that_present_ve) {
        if (!(this_present_ve && that_present_ve))
          return false;
        if (!this.ve.equals(that.ve))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkVLANConfiguration_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkVLANConfiguration_result typedOther = (checkVLANConfiguration_result)other;

      lastComparison = Boolean.valueOf(isSetVe()).compareTo(isSetVe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(ve, typedOther.ve);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case VE:
              if (field.type == TType.STRUCT) {
                this.ve = new VLanException();
                this.ve.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetVe()) {
        oprot.writeFieldBegin(VE_FIELD_DESC);
        this.ve.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkVLANConfiguration_result(");
      boolean first = true;

      sb.append("ve:");
      if (this.ve == null) {
        sb.append("null");
      } else {
        sb.append(this.ve);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getInitiatorIQN_args implements TBase<getInitiatorIQN_args._Fields>, java.io.Serializable, Cloneable, Comparable<getInitiatorIQN_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getInitiatorIQN_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getInitiatorIQN_args.class, metaDataMap);
    }

    public getInitiatorIQN_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getInitiatorIQN_args(getInitiatorIQN_args other) {
    }

    public getInitiatorIQN_args deepCopy() {
      return new getInitiatorIQN_args(this);
    }

    @Deprecated
    public getInitiatorIQN_args clone() {
      return new getInitiatorIQN_args(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getInitiatorIQN_args)
        return this.equals((getInitiatorIQN_args)that);
      return false;
    }

    public boolean equals(getInitiatorIQN_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getInitiatorIQN_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getInitiatorIQN_args typedOther = (getInitiatorIQN_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getInitiatorIQN_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getInitiatorIQN_result implements TBase<getInitiatorIQN_result._Fields>, java.io.Serializable, Cloneable, Comparable<getInitiatorIQN_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getInitiatorIQN_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getInitiatorIQN_result.class, metaDataMap);
    }

    public getInitiatorIQN_result() {
    }

    public getInitiatorIQN_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getInitiatorIQN_result(getInitiatorIQN_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    public getInitiatorIQN_result deepCopy() {
      return new getInitiatorIQN_result(this);
    }

    @Deprecated
    public getInitiatorIQN_result clone() {
      return new getInitiatorIQN_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public getInitiatorIQN_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getInitiatorIQN_result)
        return this.equals((getInitiatorIQN_result)that);
      return false;
    }

    public boolean equals(getInitiatorIQN_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getInitiatorIQN_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getInitiatorIQN_result typedOther = (getInitiatorIQN_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.STRING) {
                this.success = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getInitiatorIQN_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}

